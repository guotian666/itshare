<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 安装 Nexus3 并搭建 Docker 私有镜像仓库</title>
    <url>/2023/04/20/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Docker%20%E5%AE%89%E8%A3%85%20Nexus3%20%E5%B9%B6%E6%90%AD%E5%BB%BA%20Docker%20%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nexus 是 Sonatype 公司发布的一款仓库（Repository）管理软件，常用来搭建 Maven 私服，所以也有人将 Nexus 称为“Maven 仓库管理器”。</p>
<p>Nexus Repository 提供多种包格式的仓库：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220617133124.png" alt="image-20220617133124634"></p>
<blockquote>
<p>官方文档：<a href="https://help.sonatype.com/repomanager3">https://help.sonatype.com/repomanager3</a></p>
</blockquote>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>这里采用 Docker 进行安装</p>
<h3 id="安装-nexus3"><a href="#安装-nexus3" class="headerlink" title="安装 nexus3"></a>安装 nexus3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker run -itd \</span><br><span class="line">--privileged=true --name=nexus3 \</span><br><span class="line">-p 8081:8081 \</span><br><span class="line">-p 8082:8082 \</span><br><span class="line">-p 8083:8083 \</span><br><span class="line">-p 8084:8084 \</span><br><span class="line">-v /u01/cicd/nexus3/data:/nexus-data \</span><br><span class="line">sonatype/nexus3:3.30.0</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p><code>8081</code>：可以通过 http 访问 nexus 应用</p>
<p><code>8082</code>：docker(hosted)私有仓库，可以 pull 和 push</p>
<p><code>8083</code>：docker(proxy)代理远程仓库，只能 pull</p>
<p><code>8084</code>：docker(group)私有仓库和代理的组，只能 pull</p>
<p><code>-v</code>：建立容器与宿主机的连接，将容器中的数据持久化到宿主机上</p>
<p><code>/nexus-data</code>：容器内 nexus 存放数据的目录</p>
<p><code>/u01/cicd/nexus3/data</code>：宿主机映射容器内数据目录</p>
<h3 id="访问网页端"><a href="#访问网页端" class="headerlink" title="访问网页端"></a>访问网页端</h3><p>容器启动成功后访问：<a href="http://192.168.88.236:8081/">http://192.168.88.236:8081/</a></p>
<p>默认用户&#x2F;密码：admin&#x2F;admin123</p>
<h2 id="创建-Docker-镜像仓库"><a href="#创建-Docker-镜像仓库" class="headerlink" title="创建 Docker 镜像仓库"></a>创建 Docker 镜像仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Repository -&gt; Repositories -&gt; Create repository</span><br></pre></td></tr></table></figure>

<p><strong>repository 的类型</strong></p>
<ol>
<li><code>hosted</code>，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>
<li><code>proxy</code>，代理仓库，它们被用来代理远程的公共仓库，如 maven 中央仓库。</li>
<li><code>group</code>，仓库组，用来合并多个 hosted&#x2F;proxy 仓库，当你的项目希望在多个 repository 使用资源时就不需要多次引用了，只需要引用一个 group 即可。</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220617134246.png" alt="image-20220617134246522"></p>
<h3 id="创建-docker-hosted-类型的仓库"><a href="#创建-docker-hosted-类型的仓库" class="headerlink" title="创建 docker(hosted)类型的仓库"></a>创建 docker(hosted)类型的仓库</h3><p>hosted 类型的仓库主要用于将自己的镜像上传至私库。</p>
<p>在创建镜像仓库的页面中，设置镜像仓库的相关信息（名称、HTTP 端口、是否允许匿名拉取镜像等）。</p>
<p><strong>注意：这里设置的 HTTP 端口（8082）是后续拉取&#x2F;推送镜像的端口</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220617135103.png" alt="image-20220617135103754"></p>
<h3 id="创建-docker-proxy-类型的仓库"><a href="#创建-docker-proxy-类型的仓库" class="headerlink" title="创建 docker(proxy)类型的仓库"></a>创建 docker(proxy)类型的仓库</h3><p>proxy 类型的仓库主要是用于代理中央镜像仓库，从外网将镜像拉取至本地仓库中。</p>
<p>这里用的是阿里云的镜像地址，国内访问比较快。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220617141027.png" alt="image-20220617141027757"></p>
<h3 id="创建-docker-group-类型的仓库"><a href="#创建-docker-group-类型的仓库" class="headerlink" title="创建 docker(group)类型的仓库"></a>创建 docker(group)类型的仓库</h3><p>用于拉取镜像到本地使用，集成代理仓库和本地仓库的镜像。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220617141322.png" alt="image-20220617141322000"></p>
<h3 id="配置-Docker-Realm"><a href="#配置-Docker-Realm" class="headerlink" title="配置 Docker Realm"></a>配置 Docker Realm</h3><p>将 Docker Bearer Token Realm 配置到右边，保存</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220617141707.png" alt="image-20220617141707436"></p>
<h3 id="修改-docker-配置"><a href="#修改-docker-配置" class="headerlink" title="修改 docker 配置"></a>修改 docker 配置</h3><p>在 <code>/etc/docker/daemon.json</code> 文件中添加下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">$ vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.88.236:8082&quot;,&quot;192.168.88.236:8084&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>8082</code>：<code>docker-hosted</code> 仓库端口</li>
<li><code>8084</code>：<code>docker-group</code> 仓库端口</li>
</ul>
<p>重启 <code>docker</code> 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">$ service docker restart</span><br><span class="line"></span><br><span class="line"># 查看是否生效</span><br><span class="line">$ docker info</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 192.168.88.236:8082</span><br><span class="line"> 192.168.88.236:8084</span><br><span class="line"> 127.0.0.0/8</span><br></pre></td></tr></table></figure>

<h3 id="上传-x2F-拉取镜像"><a href="#上传-x2F-拉取镜像" class="headerlink" title="上传&#x2F;拉取镜像"></a>上传&#x2F;拉取镜像</h3><h4 id="登录私服"><a href="#登录私服" class="headerlink" title="登录私服"></a>登录私服</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">$ docker login -u admin -p wx123\!@# 192.168.88.236:8082</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded # 登录成功</span><br></pre></td></tr></table></figure>

<h4 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 拉取 hello-wrold 镜像</span><br><span class="line">$ docker pull hello-world</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">2db29710123e: Pull complete</span><br><span class="line">Digest: sha256:13e367d31ae85359f42d637adf6da428f76d75dc9afeb3c21faea0d976f5c651</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line">docker.io/library/hello-world:latest</span><br><span class="line"># 创建 tag（仓库地址/镜像名称:TAG）</span><br><span class="line">$ docker tag hello-world 192.168.88.236:8082/myhello-world:1.0</span><br><span class="line"># push 镜像</span><br><span class="line">$ docker push 192.168.88.236:8082/myhello-world:1.0</span><br><span class="line">The push refers to repository [192.168.88.236:8082/myhello-world]</span><br><span class="line">e07ee1baac5f: Pushed</span><br><span class="line">1.0: digest: sha256:f54a58bc1aac5ea1a25d796ae155dc228b3f0e11d046ae276b39c4bf2f13d8c4 size: 525</span><br></pre></td></tr></table></figure>

<p><strong>上传私库成功！</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220624120037.png" alt="image-20220624120029872"></p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">$ docker pull 192.168.88.236:8082/myhello-world:1.0</span><br><span class="line">1.0: Pulling from myhello-world</span><br><span class="line">Digest: sha256:f54a58bc1aac5ea1a25d796ae155dc228b3f0e11d046ae276b39c4bf2f13d8c4</span><br><span class="line">Status: Image is up to date for 192.168.88.236:8082/myhello-world:1.0</span><br><span class="line">192.168.88.236:8082/myhello-world:1.0</span><br></pre></td></tr></table></figure>

<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>默认是使用 <code>admin</code> 用户登录的，权限太高，可以创建一个 <code>docker</code> 账号，并创建对应的角色，分配 <code>nx-repository-view-docker-*-*</code> 权限</p>
<p><strong>创建角色</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220624131513.png" alt="image-20220624131513867"></p>
<p><strong>创建用户</strong></p>
<p>创建用户，并加入对应的角色组</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220624131705.png" alt="image-20220624131705122"></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 部署的微服务注册到 Nacos 的 IP 为私网无法访问</title>
    <url>/2023/04/25/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Docker%20%E9%83%A8%E7%BD%B2%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%88%B0%20Nacos%20%E7%9A%84%20IP%20%E4%B8%BA%E7%A7%81%E7%BD%91%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用 docker 集群部署微服务时，注册到 nacos 上的 ip 会使用 docker 容器的虚拟内网 ip 作为注册地址，这会导致集群部署服务时，nacos 无法解析对应服务的 ip。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>参考：<a href="https://github.com/alibaba/nacos/issues/310">注册服务获取 IP 的问题 · Issue #310 · alibaba&#x2F;nacos (github.com)</a></p>
</blockquote>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>docker compose 配置文件中设置网络模式为 host</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line">network_mode: host</span><br></pre></td></tr></table></figure>

<p>host 网络模式是直接使用宿主机的 IP 地址与外界进行通信</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>nacos 配置指定注册 ip&#x2F;host</p>
<p>application.yml 配置文件中添加如下配置即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 配置host，避免docker部署nacos注册服务ip为内网地址</span><br><span class="line">        ip: xxx</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Flow 工作流</title>
    <url>/2022/09/16/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Git%20Flow%20%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<h2 id="Git-Flow-简介"><a href="#Git-Flow-简介" class="headerlink" title="Git Flow 简介"></a><strong>Git Flow 简介</strong></h2><p><a href="http://nvie.com/posts/a-successful-git-branching-model/">Git Flow</a> 是构建在 Git 之上的一个组织软件开发活动的模型，是在 Git 之上构建的一项软件开发最佳实践。Git Flow 是一套使用 Git 进行源代码管理时的一套行为规范和简化部分 Git 操作的工具。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807173721.png" alt="img"></p>
<h2 id="分支约定"><a href="#分支约定" class="headerlink" title="分支约定"></a><strong>分支约定</strong></h2><p>Git Flow 有主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动；辅助分支组织为了解决特定的问题而进行的各种开发活动。</p>
<p><strong>主分支（长期分支）</strong></p>
<ul>
<li><a href="https://vanxhealth.feishu.cn/wiki/wikcnKl26BkARCg0YyaGTTYqbdg#JjEuXU">master </a>可执行版本记录分支，上面的每个节点都是发布到线上的一个版本，具体的版本号由 tag 确定</li>
<li><a href="https://vanxhealth.feishu.cn/wiki/wikcnKl26BkARCg0YyaGTTYqbdg#jmNw5a">develop </a>代码开发分支，所有开发</li>
</ul>
<p><strong>辅助分支（短期分支）</strong></p>
<ul>
<li><p><a href="https://vanxhealth.feishu.cn/wiki/wikcnKl26BkARCg0YyaGTTYqbdg#BglFMs">feature </a>详细功能分支，每个功能分支应该尽可能的小（最好一天以内），开发完成之后尽快移入仓库中</p>
</li>
<li><p><a href="https://vanxhealth.feishu.cn/wiki/wikcnKl26BkARCg0YyaGTTYqbdg#sUtR3F">release </a>测试版本发布分支，同时接收该版本的 bugfix，直到稳定之后再发布到 master，并合并到 develop 中。</p>
</li>
<li><p><a href="https://vanxhealth.feishu.cn/wiki/wikcnKl26BkARCg0YyaGTTYqbdg#Vq3QKh">hotfix </a>紧急修复线上 bug 分支，直接从 master 的版本分出，同时最小版本号加 1。修复完成后发布一个最新版本，同时合并到 develop 中。</p>
</li>
<li><h3 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a><strong>主分支</strong></h3></li>
</ul>
<p>主分支是所有开发活动的核心分支。所有的开发活动产生的输出物最终都会反映到主分支的代码中。主分支分为<strong>master</strong>分支和<strong>develop</strong>分支。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807173731.png" alt="img"></p>
<h3 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h3><ul>
<li>master 分支存放的是随时可供在生产环境中部署的稳定版本代码</li>
<li>master 分支保存官方发布版本历史，release tag 标识不同的发布版本</li>
<li>一个项目只能有一个 master 分支</li>
<li>仅在发布新的可供部署的代码时才更新 master 分支上的代码</li>
<li>每次更新 master，都需对 master 添加指定格式的 tag，用于发布或回滚</li>
<li>master 分支是保护分支，不可直接 push 到远程仓 master 分支</li>
<li>master 分支代码只能被 release 分支或 hotfix 分支合并</li>
</ul>
<h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a>develop 分支</h3><ul>
<li><p>develop 分支是保存当前最新开发成果的分支</p>
</li>
<li><p>一个项目只能有一个 develop 分支</p>
</li>
<li><p>develop 分支衍生出各个 feature 分支</p>
</li>
<li><p>develop 分支是保护分支，不可直接 push 到远程仓库 develop 分支</p>
</li>
<li><p>develop 分支不能与 master 分支直接交互</p>
</li>
<li><h3 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a><strong>辅助分支</strong></h3></li>
</ul>
<p>辅助分支是用于组织解决特定问题的各种软件开发活动的分支。辅助分支主要用于组织软件新功能的并行开发、简化新功能开发代码的跟踪、辅助完成版本发布工作以及对生产代码的缺陷进行紧急修复工作。这些分支与主分支不同，通常只会在有限的时间范围内存在。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807173734.png" alt="img"></p>
<p><strong>辅助分支包括</strong>：</p>
<ul>
<li>用于开发新功能时所使用的<code>feature</code>分支</li>
<li>用于辅助版本发布的<code>release</code>分支</li>
<li>用于修正生产代码中的缺陷的<code>hotfix</code>分支</li>
</ul>
<p>以上这些分支都有固定的使用目的和分支操作限制。从单纯技术的角度说，这些分支与 Git 其他分支并 没有什么区别，但通过命名，我们定义了使用这些分支的方法。</p>
<h3 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h3><p>使用规范：</p>
<ul>
<li>命名规则：<code>feature/*</code></li>
<li><code>develop</code>分支的功能分支</li>
<li>feature 分支使用<code>develop</code>分支作为它们的父类分支</li>
<li>以功能为单位从<code>develop</code>拉一个<code>feature</code>分支</li>
<li>每个<code>feature</code>分支颗粒要尽量小，以利于快速迭代和避免冲突</li>
<li>当其中一个 feature 分支完成后，它会合并回<code>develop</code>分支</li>
<li>当一个功能因为各种原因不开发了或者放弃了，这个分支直接废弃不影响<code>develop</code>分支</li>
<li>feature 分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里</li>
<li>feature 分支只与 develop 分支交互，不能与 master 分支直接交互</li>
</ul>
<p>如有几个同事同时开发，需要分割成几个小功能，每个人都需要从<code>develop</code>中拉出一个<code>feature</code>分支，但是每个<code>feature</code>颗粒要尽量小，因为它需要我们能尽早<code>merge</code>回<code>develop</code>分支，否则冲突解决起来就没完没了。同时，当一个功能因为各种原因不开发了或者放弃了，这个分支直接废弃，不影响<code>develop</code>分支。</p>
<h3 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a>release 分支</h3><p>使用规范：</p>
<ul>
<li>命名规则：<code>release/*</code>，“*”以本次发布的版本号为标识</li>
<li><code>release</code>分支主要用来为发布新版的测试、修复做准备</li>
<li>当需要为发布新版做准备时，从 develop 衍生出一个<code>release</code>分支</li>
<li><code>release</code>分支可以从<code>develop</code>分支上指定<code>commit</code>派生出</li>
<li><code>release</code>分支测试通过后，合并到<code>master</code>分支并且给 master 标记一个版本号</li>
<li><code>release</code>分支一旦建立就将独立，不可再从其他分支 pull 代码</li>
<li>必须合并回<code>develop</code>分支和<code>master</code>分支</li>
</ul>
<p><code>release</code>分支是为发布新的产品版本而设计的。在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等）。通过在<code>release</code>分支上进行这些工作可以让<code>develop</code>分支空闲出来以接受新的<code>feature</code>分支上的代码提交，进入新的软件开发迭代周期。</p>
<p>当<code>develop</code>分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，我们就可以考虑准备创建<code>release</code>分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到<code>release</code>分支之内（避免由此引入一些不可控的系统缺陷）。</p>
<p>成功的派生了<code>release</code>分支，并被赋予版本号之后，<code>develop</code>分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。版本号的命名可以依据项目定义的版本号命名规则进行。</p>
<h3 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="hotfix 分支"></a>hotfix 分支</h3><p>使用规范：</p>
<ul>
<li>命名规则：<code>hotfix/*</code></li>
<li><code>hotfix</code>分支用来快速给已发布产品修复 bug 或微调功能</li>
<li>只能从<code>master</code>分支指定 tag 版本衍生出来</li>
<li>一旦完成修复<code>bug</code>，必须合并回<code>master</code>分支和<code>develop</code>分支</li>
<li><code>master</code>被合并后，应该被标记一个新的版本号</li>
<li><code>hotfix</code>分支一旦建立就将独立，不可再从其他分支<code>pull</code>代码</li>
</ul>
<p>除了是计划外创建的以外，<code>hotfix</code>分支与<code>release</code>分支十分相似：都可以产生一个新的可供在生产环境部署的软件版本。</p>
<p>当生产环境中的软件遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从<code>master</code>分支上指定的<code>TAG</code>版本派生<code>hotfix</code>分支来组织代码的紧急修复工作。</p>
<p>这样做的显而易见的好处是不会打断正在进行的 develop 分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行的开展工作。</p>
<h2 id="IDEA-安装-gitflow-插件"><a href="#IDEA-安装-gitflow-插件" class="headerlink" title="IDEA 安装 gitflow 插件"></a>IDEA 安装 gitflow 插件</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>前提你的电脑上需要安装了 git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea -&gt; file-settings -&gt; Plugins -&gt; marketplace`- 搜索 `Git Flow Integretion` 安装重启 `idea</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807173738.png" alt="img"></p>
<p>点击<code>IDEA</code>右下角的<code>No flow</code>初始化分支</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807173742.png" alt="img"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807173944.png" alt="img"></p>
<p>果出现 <code>Gitflow</code> 了，就表示完成了，可以使用</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807173948.png" alt="img"></p>
<p>初始化插件设置建议勾选的设置</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807174004.png" alt="img"></p>
<blockquote>
<p>勾选配置说明：</p>
</blockquote>
<ul>
<li>Fetch from Origin （开启从远程拉取）</li>
<li>Push on finish feature（完成时自动推送）</li>
<li>Use custom tag commit message（使用自定义的打标签 commit message）</li>
</ul>
<h3 id="各工作流的执行样例"><a href="#各工作流的执行样例" class="headerlink" title="各工作流的执行样例"></a><strong>各工作流的执行样例</strong></h3><h4 id="新功能开发-feature"><a href="#新功能开发-feature" class="headerlink" title="新功能开发 feature"></a>新功能开发 <code>feature</code></h4><ol>
<li>点击 idea 右下角的 <code>Gitflow -&gt; Start Feature -&gt; 填写新需求的简单描述 — ok</code></li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807174052.png" alt="img"></p>
<ol>
<li>新生成的 <code>feature</code> 分支上编辑代码 -&gt; 提交到本地（或者同时推送到远程）</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807174108.png" alt="img"></p>
<ol>
<li>新需求开发完成且提交到本地完成 -&gt; 点击 <code>Finish Feature</code></li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807174120.png" alt="img"></p>
<ol>
<li>提测过程进行缺陷修改 -&gt; 在该 <code>release</code> 分支上进行修改</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807174132.png" alt="img"></p>
<ol>
<li><code>Gitflow</code> 插件会自动将该 <code>release</code> 分支的代码合并到 <code>master</code> 和 <code>develop</code> 分支（本地和远程），并自动删除 <code>release</code> 分支，与此同时会自动触发打 <code>tag</code> 的操作</li>
</ol>
<p><strong><code>tag</code> 即表示一个版本，也就是合并一个分支到 <code>master</code> 都需要打一个 tag。</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807174217.png" alt="img"></p>
<ol>
<li>提测过程完成——由管理员操作执行点击<code>Finish Releasea</code></li>
</ol>
<p><strong>注意：在提测未完成之前，严禁执行<code>Finish Releasea</code>！因为该操作会自动执行分支合并和删除的操作影响其他开发人员的工作</strong></p>
<h4 id="常规缺陷修复-bugfix"><a href="#常规缺陷修复-bugfix" class="headerlink" title="常规缺陷修复 bugfix"></a><strong>常规缺陷修复</strong> <code>bugfix</code></h4><p><strong>本地自测 bug 修复</strong></p>
<ol>
<li>点击 idea 右下角的 <code>Gitflow -&gt; Start Bugfix -&gt; 填写bug信息并选择需要修复的develop分支</code></li>
</ol>
<p>以 <code>develop</code> 分支自测发现了 <code>bug</code>，现在要对其进行修复为例</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220807174314.png" alt="img"></p>
<ol>
<li>在 <code>Bugfix</code> 分支上 <code>bug</code> 修复完成后 -&gt; 点击 <code>Finish Bugfix</code> 推送修改到本地 <code>develop</code> 分支</li>
<li>将本地 <code>develop</code> 分支推送到远程</li>
</ol>
<p><strong>注意：</strong><code>release</code><strong>分支上的缺陷修复也可以按照该流程执行</strong></p>
<h4 id="线上-bug-修复"><a href="#线上-bug-修复" class="headerlink" title="线上 bug 修复"></a>线上 bug 修复</h4><ol>
<li>修改线上 <code>bug</code> 的 <code>hotfix</code> 以 <code>master</code> 分支在运行时，出现了一个之前没有发现的 <code>bug</code>，现在要对其进行修复为例</li>
<li>点击 idea 右下角的 <code>Gitflow -&gt; Start hotfix</code></li>
<li>在 <code>hotfix</code> 分支上进行 <code>bug</code> 修复，提交到本地（可以一同推送到远程）</li>
<li>修复完成之后——点击 <code>Finish hotfix gitflow</code> 插件会自动将该 <code>hotfix</code> 分支的代码合并 <code>master</code> 和 <code>develop</code> 分支（本地和远程），并自动删除 <code>hotfix</code> 分支，与此同时会自动触发打 <code>tag</code> 的操作</li>
</ol>
]]></content>
      <tags>
        <tag>GitFlow工作流</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab 安装与使用</title>
    <url>/2021/11/18/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/GitLab%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Docker-安装-GitLab"><a href="#Docker-安装-GitLab" class="headerlink" title="Docker 安装 GitLab"></a>Docker 安装 GitLab</h2><p>DockerHub 上有许多制作完善的镜像，直接搜索 <code>gitlab</code> 查看镜像：</p>
<p><strong>搜索镜像</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker search gitlab</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220111153600.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220111153600.png" alt="image-20220111153600801"></a></p>
<blockquote>
<p>这里可以选择汉化的 GitLab 社区版的镜像进行下载</p>
</blockquote>
<p><strong>下载镜像</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker pull twang2218/gitlab-ce-zh</span><br></pre></td></tr></table></figure>

<p><strong>启动镜像</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker run -d -p 8443:443 -p 8090:80 -p 8022:22 --restart always --name gitlab -v /usr/local/gitlab/etc:/etc/gitlab -v /usr/local/gitlab/log:/var/log/gitlab -v /usr/local/gitlab/data:/var/opt/gitlab --privileged=true twang2218/gitlab-ce-zh</span><br><span class="line"></span><br><span class="line">命令解释：</span><br><span class="line">-d 后台启动</span><br><span class="line">-p 映射端口</span><br><span class="line">--restart 重启配置</span><br><span class="line">-v 卷挂载</span><br><span class="line">--privileged=true 设置root权限</span><br></pre></td></tr></table></figure>

<h2 id="配置-GitLab"><a href="#配置-GitLab" class="headerlink" title="配置 GitLab"></a>配置 GitLab</h2><p><strong>编辑 <code>gitlab.rb</code> 文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 直接修改 -v 挂载后的目录，docker会自动同步到容器内部</span><br><span class="line">vim /usr/local/gitlab/etc/gitlab.rb</span><br><span class="line"></span><br><span class="line"># 修改ip和端口 可以使用 / 来定位配置项</span><br><span class="line"># http地址 -- 无需配置端口</span><br><span class="line">external_url &#x27;http://xx.xx.xx.xx&#x27;</span><br><span class="line"># ssh地址 -- 无需配置端口</span><br><span class="line">gitlab_rails[&#x27;gitlab_ssh_host&#x27;] = &#x27;xx.xx.xx.xx&#x27;(不用添加端口)</span><br><span class="line"># ssh端口 默认22 启动容器时我们映射为8022</span><br><span class="line">gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 8022</span><br><span class="line"></span><br><span class="line"># ========== 邮箱配置 ==============</span><br><span class="line"># 是否启用</span><br><span class="line">gitlab_rails[&#x27;smtp_enable&#x27;] = true</span><br><span class="line"># SMTP服务的地址</span><br><span class="line">gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.qq.com&quot;</span><br><span class="line"># 端口</span><br><span class="line">gitlab_rails[&#x27;smtp_port&#x27;] = 465</span><br><span class="line"># 你的QQ邮箱（发送账号）</span><br><span class="line">gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;958317640@qq.com&quot;</span><br><span class="line"># 授权码</span><br><span class="line">gitlab_rails[&#x27;smtp_password&#x27;] = &quot;********&quot;</span><br><span class="line"># 域名</span><br><span class="line">gitlab_rails[&#x27;smtp_domain&#x27;] = &quot;smtp.qq.com&quot;</span><br><span class="line"># 登录验证</span><br><span class="line">gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;</span><br><span class="line"></span><br><span class="line"># 使用了465端口，就需要配置下面三项</span><br><span class="line">gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true</span><br><span class="line">gitlab_rails[&#x27;smtp_tls&#x27;] = true</span><br><span class="line">gitlab_rails[&#x27;smtp_openssl_verify_mode&#x27;] = &#x27;none&#x27;</span><br><span class="line"></span><br><span class="line"># 你的QQ邮箱（发送账号）</span><br><span class="line">gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;958317640@qq.com&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>应用配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 注意观察日志输出</span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220111154833.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220111154833.png" alt="image-20220111154833139"></a></p>
<p><strong>编辑 <code>gitlab.yml</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 进入容器</span><br><span class="line">docker exec -it gitlab bash</span><br><span class="line"># 编辑yml配置</span><br><span class="line">vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</span><br><span class="line"># 修改port为启动时映射的端口</span><br><span class="line">port: 8090</span><br><span class="line"></span><br><span class="line"># 重启服务并测试</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220111155220.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220111155220.png" alt="image-20220111155220504"></a></p>
]]></content>
      <tags>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8 新特性Stream</title>
    <url>/2022/10/11/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/JDK8%20%E6%96%B0%E7%89%B9%E6%80%A7%20/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java8 有一个非常显著的特点，就是提供了函数式编程，本文也将介绍 Java8 的几个新特性来实现函数式编程。学会这些 API 能够编写出简单、干净、易读的代码（尤其是对集合的操作）。Java8 新特性包括：</p>
<ul>
<li>Lambda 表达式</li>
<li>Stream API</li>
<li>接口新特性<ul>
<li>函数式接口（<code>@FunctionalInterface</code>）</li>
<li>默认方法（<code>default</code>）</li>
</ul>
</li>
<li>Optional API</li>
<li>方法引用</li>
</ul>
<p>JDK8 新特性</p>
<p>正在努力更新中…</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><ul>
<li>只包含了一个抽象方法的接口，称为函数式接口（可以有多个非抽象方法）。可以使用<code>@FunctionalInterface</code>注解自定义声明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">//JDK 1.8 之前已有的函数式接口:</span><br><span class="line">- java.lang.Runnable</span><br><span class="line">- java.util.concurrent.Callable</span><br><span class="line">- java.security.PrivilegedAction</span><br><span class="line">- java.util.Comparator</span><br><span class="line">- java.io.FileFilter</span><br><span class="line">- java.nio.file.PathMatcher</span><br><span class="line">- java.lang.reflect.InvocationHandler</span><br><span class="line">- java.beans.PropertyChangeListener</span><br><span class="line">- java.awt.event.ActionListener</span><br><span class="line">- javax.swing.event.ChangeListener</span><br><span class="line">//JDK 1.8 新增加的函数接口：</span><br><span class="line">- java.util.function</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><ul>
<li><code>Lambda</code>表达式的使用依赖于函数式接口</li>
<li>使用<code>Lambda</code>表达式来表示函数式接口的实现（JAVA 8 之前一般是用匿名类实现的）</li>
</ul>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><ul>
<li><code>-&gt; :Lambda操作符</code></li>
<li><code>-&gt; 左边(parameters):Lambda形参列表</code>(相当于接口中的抽象方法的形参列表)</li>
</ul>
<ol>
<li>参数类型可以省略，可由编译器推断得出(类型推断)</li>
<li>如果只有一个参数,<code>()</code>也可以省略</li>
</ol>
<ul>
<li><code>-&gt; 右边:Lambda体</code>(重写的抽象方法的方法体)</li>
</ul>
<ol>
<li>如果只有一条执行语句，<code>&#123;&#125;</code>及<code>return</code>可以省略</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line">// 1. 接收2个int型整数,返回他们的和</span><br><span class="line">(int x, int y) -&gt; x + y</span><br><span class="line">// 2. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    Runnable runnable=new Runnable()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            System.out.println(&quot;*********&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    runnable.run();</span><br><span class="line">    //Lambda表达式写法</span><br><span class="line">    Runnable runnable= () -&gt; System.out.println(&quot;*********&quot;);</span><br><span class="line">    runnable.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><table>
<thead>
<tr>
<th>使用案例</th>
<th>Lambda 的例子</th>
<th>对应的函数式接口</th>
</tr>
</thead>
<tbody><tr>
<td>布尔表达式</td>
<td><code>(List&lt;String&gt; list) -&gt; list.isEmpty()</code></td>
<td><code>Predicate&lt;List&lt;String&gt;&gt;</code></td>
</tr>
<tr>
<td>创建对象</td>
<td><code>() -&gt; new Project()</code></td>
<td><code>Supplier&lt;Project&gt;</code></td>
</tr>
<tr>
<td>消费一个对象</td>
<td><code>(Project p) -&gt; System.out.println(p.getStars())</code></td>
<td><code>Consumer&lt;Project&gt;</code></td>
</tr>
<tr>
<td>从一个对象中选择&#x2F;提取</td>
<td><code>(int a, int b) -&gt; a * b</code></td>
<td><code>IntBinaryOperator</code></td>
</tr>
<tr>
<td>比较两个对象</td>
<td><code>(Project p1, Project p2) -&gt; p1.getStars().compareTo(p2.getStars())</code></td>
<td><code>Comparator&lt;Project&gt; 或 BiFunction&lt;Project,</code> <code>Project, Integer&gt; 或 ToIntBiFunction&lt;Project, Project&gt;</code></td>
</tr>
</tbody></table>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><ul>
<li>使用操作符<code>::</code>类或对象与方法名分割</li>
<li>主要有三种使用情况</li>
</ul>
<p>对象<code>::</code>实例方法名</p>
<p>类<code>::</code>实例方法名</p>
<p>类<code>::</code>静态方法名</p>
<h4 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">LambdaQueryWrapper&lt;SysDictItem&gt; queryWrapper = new LambdaQueryWrapper&lt;SysDictItem&gt;();</span><br><span class="line">//相当于SysDictItem.getStatus();</span><br><span class="line">queryWrapper.eq(SysDictItem::getStatus, 1);</span><br><span class="line">queryWrapper.orderByAsc(SysDictItem::getSortOrder);</span><br></pre></td></tr></table></figure>

<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><ul>
<li><p>使用<code>Stream API</code>对集合数据进行操作</p>
</li>
<li><pre><code>stream
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
collection
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  集合的区别</span><br><span class="line"></span><br><span class="line">  - `collection`是一种静态的内存数据结构，而`stream`是有关计算的，前者主要面向内存，存储在内存中，后者主要面向`cpu`，通过`cpu`计算实现</span><br><span class="line"></span><br><span class="line">- `Stream`的创建方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA
</code></pre>
</li>
</ul>
<p>&#x2F;&#x2F;1.通过集合创建<br>&#x2F;&#x2F;default Stream<E> stream();&#x2F;&#x2F;返回一个顺序流<br>&#x2F;&#x2F;default Stream<E> parallelStream();&#x2F;&#x2F;返回一个并行流<br>List<Person> list &#x3D; new ArrayList<Person>();<br>Stream<Person> stream &#x3D; list.stream();</p>
<p>&#x2F;&#x2F;2.通过Arrays静态方法<br>String[] names &#x3D; {“chaimm”,”peter”,”john”};<br>Stream<String> stream &#x3D; Arrays.stream(names);</p>
<p>&#x2F;&#x2F;3.通过Stream of<br>Stream<String> stream &#x3D; Stream.of(“chaimm”,”peter”,”john”);</p>
<p>&#x2F;&#x2F;4.创建无限流<br>&#x2F;&#x2F;迭代 遍历0到9<br>Stream.iterate(0,t-&gt;t+1).limit(10).forEach(System.out::println);<br>&#x2F;&#x2F;生成 10个随机数<br>Stream.generate(Math::random).limit(10).forEach(System.out::println);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 中间操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>&#x2F;&#x2F;中间操作<br>&#x2F;&#x2F;filer(Predicate p)过滤数据<br>List<Person> result &#x3D; list.stream()<br>    .filter(Person::isStudent)<br>    .collect(toList());</p>
<p>&#x2F;&#x2F;limit(n)截断流<br>List<Person> result &#x3D; list.stream()<br>    .limit(3)<br>    .collect(toList());</p>
<p>&#x2F;&#x2F;skip(n)跳过元素<br>List<Person> result &#x3D; list.stream()<br>    .skip(3)<br>    .collect(toList());</p>
<p>&#x2F;&#x2F;distinct 筛选去重<br>List<Person> result &#x3D; list.stream()<br>    .distinct()<br>    .collect(toList());</p>
<p>&#x2F;&#x2F;映射map(Function f)  flatMap(Function f)合并多个流<br>List<String> result &#x3D; list.stream()<br>    .map(Person::getName)<br>    .collect(toList());</p>
<p>&#x2F;&#x2F;排序 sorted() 自然排序 sorted(Comparator c)定制顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 终止操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p> &#x2F;&#x2F;终止操作<br>&#x2F;&#x2F;匹配与查找<br>&#x2F;&#x2F;allMatch(Predicate e)检查是否匹配所有元素 返回boolean<br>boolean result &#x3D; list.stream()<br>    .allMatch(Person::isStudent);<br>&#x2F;&#x2F;anyMatch(Predicate e)检查是否至少匹配一个元素<br>boolean result &#x3D; list.stream()<br>    .anyMatch(Person::isStudent);<br>&#x2F;&#x2F;noneMatch(Predicate e)检查是否没有匹配的元素<br>boolean result &#x3D; list.stream()<br>    .noneMatch(Person::isStudent);<br>&#x2F;&#x2F;findFierst()返回第一个元素<br>Optional<Person> person &#x3D; list.stream().findFirst();<br>&#x2F;&#x2F;findAny()返回当前流中的任意元素<br>Optional<Person> person &#x3D; list.stream().findAny();<br>&#x2F;&#x2F;count 返回流中元素的总个数<br>&#x2F;&#x2F;max(Comparator c)返回流中最大值<br>&#x2F;&#x2F;min(Comparator c)返回流中最小值<br>&#x2F;&#x2F;forEach(Consumer c)内部迭代<br>&#x2F;&#x2F;归约 reduce(T identity,BinaryOperator)可以将流中元素结合起来得到一个值（求和）<br>&#x2F;&#x2F;例：计算所有人的年龄总和<br>int age &#x3D; list.stream().reduce(0, (person1,person2)-&gt;person1.getAge()+person2.getAge());<br>&#x2F;&#x2F;收集collect(Collector c) 将流中元素收集返回相应类型</p>
<pre><code>
#### 中间操作和收集操作

| 操作        | 类型 | 返回类型      | 使用的类型/函数式接口   | 函数描述符       |
| ----------- | ---- | ------------- | ----------------------- | ---------------- |
| `filter`    | 中间 | `Stream&lt;T&gt;`   | `Predicate&lt;T&gt;`          | `T -&gt; boolean`   |
| `distinct`  | 中间 | `Stream&lt;T&gt;`   |                         |                  |
| `skip`      | 中间 | `Stream&lt;T&gt;`   | `long`                  |                  |
| `map`       | 中间 | `Stream&lt;R&gt;`   | `Function&lt;T, R&gt;`        | `T -&gt; R`         |
| `flatMap`   | 中间 | `Stream&lt;R&gt;`   | `Function&lt;T,Stream&lt;R&gt;&gt;` | `T -&gt; Stream&lt;R&gt;` |
| `limit`     | 中间 | `Stream&lt;T&gt;`   | `long`                  |                  |
| `sorted`    | 中间 | `Stream&lt;T&gt;`   | `Comparator&lt;T&gt;`         | `(T, T) -&gt; int`  |
| `anyMatch`  | 终端 | `boolean`     | `Predicate&lt;T&gt;`          | `T -&gt; boolean`   |
| `noneMatch` | 终端 | `boolean`     | `Predicate&lt;T&gt;`          | `T -&gt; boolean`   |
| `allMatch`  | 终端 | `boolean`     | `Predicate&lt;T&gt;`          | `T -&gt; boolean`   |
| `findAny`   | 终端 | `Optional&lt;T&gt;` |                         |                  |
| `findFirst` | 终端 | `Optional&lt;T&gt;` |                         |                  |
| `forEach`   | 终端 | `void`        | `Consumer&lt;T&gt;`           | `T -&gt; void`      |
| `collect`   | 终端 | `R`           | `Collector&lt;T, A, R&gt;`    |                  |
| `reduce`    | 终端 | `Optional&lt;T&gt;` | `BinaryOperator&lt;T&gt;`     | `(T, T) -&gt; T`    |
| `count`     | 终端 | `long`        |                         |                  |

### [新的日期和 API](https://github.com/hellokaton/learn-java8/blob/master/java8-datetime-api/README.md)
</code></pre>
]]></content>
      <tags>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok 消除冗余代码</title>
    <url>/2022/08/17/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Lombok%20%E6%B6%88%E9%99%A4%E5%86%97%E4%BD%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p><code>Lombok</code> 是一款 Java 开发插件，使得 <code>Java</code> 开发者可以通过其定义的一些注解来消除业务过程中冗余的代码，尤其是简单的 <code>Java</code> 模型对象（<code>POJO</code>）。而当我们如果在开发环境中使用 <code>Lombok</code> 开发插件后，可以省出重复构建，诸如 <code>hashCode</code> 和 <code>equals</code> 这样的方法以及各种业务对象模型的 <code>accessor</code> 和 <code>ToString</code> 等方法的大量时间。对于这些方法，它能够在编译源代码期间自动帮我们生产这些方法，并没有如反射那样降低程序的性能。</p>
<p>可以用来帮助开发人员消除冗余的代码，对于一些简单的 <code>Java</code> 对象（<code>POJO</code>），它通过注释实现这一目的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Lombok 的实现原理，基于 <a href="https://jcp.org/en/jsr/detail?id=269">JSR269(Pluggable Annotation Processing API)</a> 规范，自定义编译器注解处理器，用于在 Javac 编译阶段时，扫描使用到 Lombok 定义的注解的类，进行自定义的代码生成。</p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>在 IDEA 中，已经提供了 <a href="https://plugins.jetbrains.com/plugin/6317-lombok">IntelliJ Lombok plugin</a> 插件，方便我们使用 Lombok。安装方式很简单，只需要在 IDEA Plugins 功能中，搜索 Lombok 关键字即可。如下图所示：</p>
<p>IDEA 2020.3 版本以上已经内置 Lombok Plugin 插件，无需手动安装</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220807160143.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220807160143.png" alt="img"></a></p>
<h2 id="Lombok-常用注解说明"><a href="#Lombok-常用注解说明" class="headerlink" title="Lombok 常用注解说明"></a><strong>Lombok 常用注解说明</strong></h2><table>
<thead>
<tr>
<th>@NonNull</th>
<th>给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出 NPE （<code>NullPointerException</code>）</th>
</tr>
</thead>
<tbody><tr>
<td>@Cleanup</td>
<td>自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成 <code>try-finally</code>这样的代码来关闭流</td>
</tr>
<tr>
<td>@Getter&#x2F;@Setter</td>
<td>用在属性上，再也不用自己手写 setter 和 getter 方法了，还可以指定访问范围</td>
</tr>
<tr>
<td>@ToString</td>
<td>用在类上，可以自动覆写 toString 方法，当然还可以加其他参数，例如@ <code>ToString</code>(<code>exclude</code>&#x3D;”<code>id</code>”)排除 id 属性，或者<code>@ToString</code>(<code>callSuper</code>&#x3D;<code>true</code>,<code>includeFieldNames</code>&#x3D;<code>true</code>)调用父类的 toString 方法，包含所有属性</td>
</tr>
<tr>
<td>@EqualsAndHashCode</td>
<td>用在类上，自动生成<code>equals</code>方法和<code>hashCode</code>方法</td>
</tr>
<tr>
<td>@NoArgsConstructor</td>
<td><code>@RequiredArgsConstructor</code> <code>and @AllArgsConstructor</code>：用在类上，自动生成无参构造和使用所有参数的构造函数以及把所有@NonNull 属性作为参数的构造函数，如果指定<code>staticName</code>&#x3D; <code>“of”</code>参数，同时还会生成一个返回类对象的静态工厂方法，比使用构造函数方便很多</td>
</tr>
<tr>
<td>@Data</td>
<td>注解在类上，相当于同时使用了<code>@ToString</code>、<code>@EqualsAndHashCode</code>、<code>@Gette</code>r、<code>@Setter</code>和<code>@RequiredArgsConstrutor</code>这些注解，对于<code>POJO</code>类十分有用</td>
</tr>
<tr>
<td>@Value</td>
<td>用在类上，是<code>@Data</code>的不可变形式，相当于为属性添加 final 声明，只提供<code>getter</code>方法，而不提供<code>setter</code>方法</td>
</tr>
<tr>
<td>@Builder</td>
<td>用在类、构造器、方法上，为你提供复杂的<code>builder APIs</code>，让你可以像如下方式一样调用<code>Person.builder().name(&quot;Adam Savage&quot;).city(&quot;San Francisco&quot;).job(&quot;Mythbusters&quot;).job(&quot;Unchained Reaction&quot;).build();</code>更多说明参考<code>Builder</code></td>
</tr>
<tr>
<td>@SneakyThrows</td>
<td>自动抛受检异常，而无需显式在方法上使用 throws 语句</td>
</tr>
<tr>
<td>@Synchronized</td>
<td>用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性<code>$lock</code>或$<code>LOCK，</code>而<code>java</code>中的<code>synchronized</code>关键字锁对象是<code>this</code>，锁在<code>this</code>或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁 this 或者类对象，这可能会导致竞争条件或者其它线程错误</td>
</tr>
<tr>
<td>@Getter(lazy&#x3D;true)</td>
<td>可以替代经典的<code>Double Check Lock</code>样板代码</td>
</tr>
<tr>
<td>@Log</td>
<td>根据不同的注解生成不同类型的<code>log</code>对象，但是实例名称都是<code>log</code>，有六种可选实现类</td>
</tr>
<tr>
<td>val</td>
<td>用在局部变量前面，相当于将变量声明为 final</td>
</tr>
</tbody></table>
<h2 id="Lombok-代码示范"><a href="#Lombok-代码示范" class="headerlink" title="Lombok 代码示范"></a><strong>Lombok 代码示范</strong></h2><ul>
<li><h6 id="Nonnull-为方法和构造函数的参数提供非空检查"><a href="#Nonnull-为方法和构造函数的参数提供非空检查" class="headerlink" title="@Nonnull 为方法和构造函数的参数提供非空检查"></a>@Nonnull 为方法和构造函数的参数提供非空检查</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line">public void notNullExample(@NonNull String string) &#123;</span><br><span class="line">    string.length();</span><br><span class="line">&#125;</span><br><span class="line">//=&gt;相当于</span><br><span class="line">public void notNullExample(String string) &#123;</span><br><span class="line">    if (string != null) &#123;</span><br><span class="line">        string.length();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new NullPointerException(&quot;null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Cleanup-自动释放资源"><a href="#Cleanup-自动释放资源" class="headerlink" title="@Cleanup 自动释放资源"></a>@Cleanup 自动释放资源</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        @Cleanup InputStream inputStream = new FileInputStream(args[0]);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    //=&gt;相当于</span><br><span class="line">    InputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream = new FileInputStream(args[0]);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (inputStream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Getter-x2F-Setter-对类的属性字段自动生成-Get-x2F-Set-方法"><a href="#Getter-x2F-Setter-对类的属性字段自动生成-Get-x2F-Set-方法" class="headerlink" title="@Getter&#x2F;@Setter 对类的属性字段自动生成 Get&#x2F;Set 方法"></a>@Getter&#x2F;@Setter 对类的属性字段自动生成 Get&#x2F;Set 方法</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Setter(AccessLevel.PUBLIC)</span><br><span class="line">@Getter(AccessLevel.PROTECTED)</span><br><span class="line">private int id;</span><br><span class="line">private String shap;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="ToString-为类生成一个-toString-方法"><a href="#ToString-为类生成一个-toString-方法" class="headerlink" title="@ToString 为类生成一个 toString 方法"></a>@ToString 为类生成一个 toString 方法</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line">@ToString(exclude = &quot;id&quot;, callSuper = true, includeFieldNames = true)</span><br><span class="line">public class LombokDemo &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //输出LombokDemo(super=LombokDemo@48524010, name=null, age=0)</span><br><span class="line">        System.out.println(new LombokDemo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="EqualsAndHashCode-为类生成-equals-和-hasCode-方法"><a href="#EqualsAndHashCode-为类生成-equals-和-hasCode-方法" class="headerlink" title="@EqualsAndHashCode 为类生成 equals 和 hasCode 方法"></a>@EqualsAndHashCode 为类生成 equals 和 hasCode 方法</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line">@EqualsAndHashCode(exclude = &#123;&quot;id&quot;, &quot;shape&quot;&#125;, callSuper = false)</span><br><span class="line">public class LombokDemo &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String shap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="NoArgsConstructor，-RequiredArgsConstructor-and-AllArgsConstructor，分别为类自动生成无参构造，指定参数构造器和包含所有参数构造器"><a href="#NoArgsConstructor，-RequiredArgsConstructor-and-AllArgsConstructor，分别为类自动生成无参构造，指定参数构造器和包含所有参数构造器" class="headerlink" title="@NoArgsConstructor，@RequiredArgsConstructor and @AllArgsConstructor，分别为类自动生成无参构造，指定参数构造器和包含所有参数构造器"></a>@NoArgsConstructor，@RequiredArgsConstructor and @AllArgsConstructor，分别为类自动生成无参构造，指定参数构造器和包含所有参数构造器</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line"></span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class LombokDemo &#123;</span><br><span class="line">    @NonNull</span><br><span class="line">    private int id;</span><br><span class="line">    @NonNull</span><br><span class="line">    private String shap;</span><br><span class="line">    private int age;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new LombokDemo(1, &quot;circle&quot;);</span><br><span class="line">        //使用静态工厂方法</span><br><span class="line">        LombokDemo.of(2, &quot;circle&quot;);</span><br><span class="line">        //无参构造</span><br><span class="line">        new LombokDemo();</span><br><span class="line">        //包含所有参数</span><br><span class="line">        new LombokDemo(1, &quot;circle&quot;, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Data-在类上使用，相当于同时使用-ToString、-EqualsAndHashCode、-Getter、-Setter-和-RequiredArgsConstructor-这些注解"><a href="#Data-在类上使用，相当于同时使用-ToString、-EqualsAndHashCode、-Getter、-Setter-和-RequiredArgsConstructor-这些注解" class="headerlink" title="@Data 在类上使用，相当于同时使用@ToString、@EqualsAndHashCode、@Getter、@Setter 和@RequiredArgsConstructor 这些注解"></a>@Data 在类上使用，相当于同时使用@ToString、@EqualsAndHashCode、@Getter、@Setter 和@RequiredArgsConstructor 这些注解</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Menu &#123;</span><br><span class="line">    private String shopId;</span><br><span class="line">    private String skuMenuId;</span><br><span class="line">    private String skuName;</span><br><span class="line">    private String normalizeSkuName;</span><br><span class="line">    private String dishMenuId;</span><br><span class="line">    private String dishName;</span><br><span class="line">    private String dishNum;</span><br><span class="line">    //默认阈值</span><br><span class="line">    private float thresHold = 0;</span><br><span class="line">    //新阈值</span><br><span class="line">    private float newThresHold = 0;</span><br><span class="line">    //总得分</span><br><span class="line">    private float totalScore = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Value-为属性添加-final-声明"><a href="#Value-为属性添加-final-声明" class="headerlink" title="@Value 为属性添加 final 声明"></a>@Value 为属性添加 final 声明</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Value</span><br><span class="line">public class LombokDemo &#123;</span><br><span class="line">    @NonNull</span><br><span class="line">    private int id;</span><br><span class="line">    @NonNull</span><br><span class="line">    private String shap;</span><br><span class="line">    private int age;</span><br><span class="line">    //相当于</span><br><span class="line">    private final int id;</span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Builder-提供构建值对象方式"><a href="#Builder-提供构建值对象方式" class="headerlink" title="@Builder 提供构建值对象方式"></a>@Builder 提供构建值对象方式</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line">@Builder</span><br><span class="line">public class BuilderExample &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    @Singular</span><br><span class="line">    private Set&lt;String&gt; occupations;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BuilderExample test = BuilderExample.builder().age(11).name(&quot;test&quot;).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="SneakyThrows-自动抛受检异常"><a href="#SneakyThrows-自动抛受检异常" class="headerlink" title="@SneakyThrows 自动抛受检异常"></a>@SneakyThrows 自动抛受检异常</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    @SneakyThrows()</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        InputStream inputStream = new FileInputStream(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void write() &#123;</span><br><span class="line">        throw new UnsupportedEncodingException();</span><br><span class="line">    &#125;</span><br><span class="line">    //相当于</span><br><span class="line">    public void read() throws FileNotFoundException &#123;</span><br><span class="line">        InputStream inputStream = new FileInputStream(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void write() throws UnsupportedEncodingException &#123;</span><br><span class="line">        throw new UnsupportedEncodingException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Synchronized-将方法声明同步并自动加锁"><a href="#Synchronized-将方法声明同步并自动加锁" class="headerlink" title="@Synchronized 将方法声明同步并自动加锁"></a>@Synchronized 将方法声明同步并自动加锁</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line"></span><br><span class="line">public class SynchronizedDemo &#123;</span><br><span class="line">    @Synchronized</span><br><span class="line">    public static void hello() &#123;</span><br><span class="line">        System.out.println(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //相当于</span><br><span class="line">    private static final Object $LOCK = new Object[0];</span><br><span class="line">    public static void hello() &#123;</span><br><span class="line">        synchronized ($LOCK) &#123;</span><br><span class="line">            System.out.println(&quot;world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Getter-lazy-x3D-true-可以替代经典的-Double-check-Lock-样板代码"><a href="#Getter-lazy-x3D-true-可以替代经典的-Double-check-Lock-样板代码" class="headerlink" title="@Getter(lazy&#x3D;true)可以替代经典的 Double check Lock 样板代码"></a>@Getter(lazy&#x3D;true)可以替代经典的 Double check Lock 样板代码</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class GetterLazyExample &#123;</span><br><span class="line">    @Getter(lazy = true)</span><br><span class="line">    private final double[] cached = expensive();</span><br><span class="line">    private double[] expensive() &#123;</span><br><span class="line">        double[] result = new double[1000000];</span><br><span class="line">        for (int i = 0; i &lt; result.length; i++) &#123;</span><br><span class="line">            result[i] = Math.asin(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 相当于如下所示:</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line">public class GetterLazyExample &#123;</span><br><span class="line">    private final AtomicReference&lt;java.lang.Object&gt; cached = new AtomicReference&lt;&gt;();</span><br><span class="line">    public double[] getCached() &#123;</span><br><span class="line">        java.lang.Object value = this.cached.get();</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            synchronized (this.cached) &#123;</span><br><span class="line">                value = this.cached.get();</span><br><span class="line">                if (value == null) &#123;</span><br><span class="line">                    final double[] actualValue = expensive();</span><br><span class="line">                    value = actualValue == null ? this.cached : actualValue;</span><br><span class="line">                    this.cached.set(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (double[]) (value == this.cached ? null : value);</span><br><span class="line">    &#125;</span><br><span class="line">    private double[] expensive() &#123;</span><br><span class="line">        double[] result = new double[1000000];</span><br><span class="line">        for (int i = 0; i &lt; result.length; i++) &#123;</span><br><span class="line">            result[i] = Math.asin(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Log-根据不同的注解生成不同类型的-log-对象"><a href="#Log-根据不同的注解生成不同类型的-log-对象" class="headerlink" title="@Log 根据不同的注解生成不同类型的 log 对象"></a>@Log 根据不同的注解生成不同类型的 log 对象</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@CommonsLog Creates log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);</span><br><span class="line">@Log Creates log = java.util.logging.Logger.getLogger(LogExample.class.getName());</span><br><span class="line">@Log4j Creates log = org.apache.log4j.Logger.getLogger(LogExample.class);</span><br><span class="line">@Log4j2 Creates log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);</span><br><span class="line">@Slf4j Creates log = org.slf4j.LoggerFactory.getLogger(LogExample.class);</span><br><span class="line">@XSlf4j Creates log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="val-将变量声明-final-类型"><a href="#val-将变量声明-final-类型" class="headerlink" title="val 将变量声明 final 类型"></a>val 将变量声明 final 类型</h6></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DART</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    val sets = new HashSet&lt;String&gt;();</span><br><span class="line">    val lists = new ArrayList&lt;String&gt;();</span><br><span class="line">    val maps = new HashMap&lt;String, String&gt;();</span><br><span class="line">    //=&gt;相当于如下</span><br><span class="line">    final Set&lt;String&gt; sets2 = new HashSet&lt;&gt;();</span><br><span class="line">    final List&lt;String&gt; lists2 = new ArrayList&lt;&gt;();</span><br><span class="line">    final Map&lt;String, String&gt; maps2 = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 基本语法</title>
    <url>/2022/06/01/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Markdown%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 能被使用来撰写电子书、博客等，当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、Gitee 等。</p>
<p>本站的所有文章也是通过 Markdown 语法来写的。Markdown 语法虽然操作简单，但还是需要记一些语法，下面让我们来学习这些语法：</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个<code>#</code>号，二级标题对应两个<code>#</code>号，以此类推。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLEAN</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">*斜体文本*</span><br><span class="line">**粗体文本**</span><br><span class="line">***粗斜体文本***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>显示效果如下：<br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>*粗斜体文本*</strong><br><del>这是加删除线的文字</del></p>
<hr>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过 HTML 的<code>&lt;u&gt;</code>标签来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<p>带下划线文本</p>
<hr>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。</p>
<h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure>

<p>显示结果如下：</p>
<ul>
<li><p>第一项</p>
</li>
<li><p>第二项</p>
</li>
<li><p>第三项</p>
</li>
<li><p>第一项</p>
</li>
<li><p>第二项</p>
</li>
<li><p>第三项</p>
</li>
<li><p>第一项</p>
</li>
<li><p>第二项</p>
</li>
<li><p>第三项</p>
</li>
</ul>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表使用数字并加上 . 号来表示，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Markdown 引用是在段落开头使用<code>&gt;</code>符号 ，然后后面紧跟一个空格符号，引用也可以嵌套，例如两个<code>&gt;&gt;</code>，三个<code>&gt;&gt;&gt;</code>，以此类推：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">&gt; 这是引用的内容</span><br><span class="line">&gt;&gt; 这是引用的内容</span><br><span class="line">&gt;&gt;&gt; 这是引用的内容</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>分割线可以三个或三个以上的<code>-</code>或者<code>*</code>都可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASCIIDOC</span><br><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<hr>
<hr>
<hr>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>单行代码：代码之间分别用一个反引号包起来，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARCADE</span><br><span class="line">`这是单行代码`</span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AUTOHOTKEY</span><br><span class="line">(```)</span><br><span class="line">这是多行代码...</span><br><span class="line">这是多行代码...</span><br><span class="line">这是多行代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止演示代码与撰写博客文章的 markdown 语法转译，我这里用括号将三个反引号隔开了，实际使用时去掉括号就行了。</p>
</blockquote>
<p>显示效果如下：<br>单行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是单行代码</span><br></pre></td></tr></table></figure>

<p>代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERLANG</span><br><span class="line">这是多行代码...</span><br><span class="line">这是多行代码...</span><br><span class="line">这是多行代码...</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOS</span><br><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">[百度](http://baidu.com)</span><br><span class="line">[Irving的个人博客](https://ouwen666.gitee.io &quot;大爷，来玩啊！&quot;)</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<p><a href="http://baidu.com/">百度</a><br><a href="https://ouwen666.gitee.io/">Irving 的个人博客</a></p>
<hr>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GHERKIN</span><br><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PGSQL</span><br><span class="line">![图片alt](图片地址 &#x27;&#x27;图片title&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARCADE</span><br><span class="line">![Markdown](/images/md.jpg)</span><br></pre></td></tr></table></figure>

<p>显示效果如下：<br><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/img/md.jpg"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/img/md.jpg" alt="img"></a></p>
<blockquote>
<p>注：我这里图片是保存在本地的，所以图片地址哪里是本地目录，也可以用图片的在线链接地址</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此篇博客总结了我写 Hexo 博客常用的 Markdown 语法，如有不妥之处请查阅 MD 官方文档。</p>
<p>因为显示效果都是用 Markdown 语法呈现的，而我采用的主题又是通过文章的标题来显示文章目录，所以左侧的文章目录可能有点混乱···</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库</title>
    <url>/2023/04/11/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>MongoDB 数据库的学习</p>
<h2 id="MongoDB-的简介"><a href="#MongoDB-的简介" class="headerlink" title="MongoDB 的简介"></a>MongoDB 的简介</h2><h3 id="MongoDB-的概述"><a href="#MongoDB-的概述" class="headerlink" title="MongoDB 的概述"></a>MongoDB 的概述</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/mongo.jpg" alt="img"></p>
<ul>
<li>MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</li>
<li>在高负载的情况下，添加更多的节点，可以保证服务器性能。</li>
<li>MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li>
<li>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成</li>
<li>MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</li>
</ul>
<h2 id="MongoDB-的安装"><a href="#MongoDB-的安装" class="headerlink" title="MongoDB 的安装"></a>MongoDB 的安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install mongodb</span><br></pre></td></tr></table></figure>

<p>安装完成可以用<code>mongo -version</code>来查看版本检查是否安装成功</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/mongo1.jpg" alt="img"></p>
<h3 id="MongoDB-基本管理"><a href="#MongoDB-基本管理" class="headerlink" title="MongoDB 基本管理"></a>MongoDB 基本管理</h3><p>通过以下命令，可以对 mongoDB 数据库进行一些基本的操作：</p>
<ul>
<li>查看服务状态<br>service mongodb status</li>
<li>启动服务<br>service mongodb start</li>
<li>停止服务<br>service mongodb stop</li>
<li>重新载入资源<br>service mongodb reload</li>
</ul>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt --purge remove mongodb mongodb-clients mongodb-server</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB-基本配置"><a href="#MongoDB-基本配置" class="headerlink" title="MongoDB 基本配置"></a>MongoDB 基本配置</h2><h3 id="MongoDB-文件结构"><a href="#MongoDB-文件结构" class="headerlink" title="MongoDB 文件结构"></a>MongoDB 文件结构</h3><p>mongoDB 数据库安装好以后，有以下四个比较重要的文件和目录：</p>
<ul>
<li>主启动文件：&#x2F;usr&#x2F;bin&#x2F;mongod</li>
<li>配置文件：&#x2F;etc&#x2F;mongodb.conf</li>
<li>日志文件存放目录：&#x2F;var&#x2F;log&#x2F;mongodb</li>
<li>数据存放位置目录：&#x2F;var&#x2F;lib&#x2F;mongodb</li>
</ul>
<h2 id="MongoDB-基本操作"><a href="#MongoDB-基本操作" class="headerlink" title="MongoDB 基本操作"></a>MongoDB 基本操作</h2><p>启动 MongoDB 服务后可以进行 MongoDB 的基本操作</p>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>使用<code>mongo</code>命令连接数据库：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/mongo2.jpg" alt="img"></p>
<h3 id="查看已有的数据库"><a href="#查看已有的数据库" class="headerlink" title="查看已有的数据库"></a>查看已有的数据库</h3><p>使用<code>show dbs</code>命令进行查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NODE-REPL</span><br><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><p>如果使用的数据库不存在，就创建同名数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FSHARP</span><br><span class="line">&gt; use books</span><br><span class="line">switched to db books  //选中books数据库</span><br></pre></td></tr></table></figure>

<h3 id="创建数据集合"><a href="#创建数据集合" class="headerlink" title="创建数据集合"></a>创建数据集合</h3><p>类似于一张表，命令为<code>db.createCollection(&quot;表名&quot;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVASCRIPT</span><br><span class="line">&gt; db.createCollection(&quot;user&quot;)</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;   //user创建成功</span><br></pre></td></tr></table></figure>

<h3 id="对数据集合进行操作"><a href="#对数据集合进行操作" class="headerlink" title="对数据集合进行操作"></a>对数据集合进行操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>插入命令有两种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.表名.insert(&#123;&#125;)</span><br><span class="line">db.表名.save(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>两者区别在于：插入数据时，如果_id 存在，insert 操作时，则插入失败，save 操作时，则更新数据</p>
<h5 id="插入一条数据："><a href="#插入一条数据：" class="headerlink" title="插入一条数据："></a>插入一条数据：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STYLUS</span><br><span class="line">&gt; db.user.insert(&#123;_id:1,uname:&quot;zhangsan&quot;,age:20,sex:&quot;男&quot;&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)   //一般情况，第一个字段都是_id,如果没有，也会自动添加一个_id</span><br></pre></td></tr></table></figure>

<h5 id="插入多条数据："><a href="#插入多条数据：" class="headerlink" title="插入多条数据："></a>插入多条数据：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">&gt; db.user.insert([&#123;_id:2,uname:&quot;lisi&quot;,age:19,sex:&quot;男&quot;&#125;,&#123;_id:3,uname:&quot;wangwu&quot;,age:18,sex:&quot;女&quot;&#125;])   //插入多条数据中间用逗号分开，然后用[]包起来就行</span><br><span class="line">BulkWriteResult(&#123;</span><br><span class="line">        &quot;writeErrors&quot; : [ ],</span><br><span class="line">        &quot;writeConcernErrors&quot; : [ ],</span><br><span class="line">        &quot;nInserted&quot; : 2,</span><br><span class="line">        &quot;nUpserted&quot; : 0,</span><br><span class="line">        &quot;nMatched&quot; : 0,</span><br><span class="line">        &quot;nModified&quot; : 0,</span><br><span class="line">        &quot;nRemoved&quot; : 0,</span><br><span class="line">        &quot;upserted&quot; : [ ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><h5 id="不带条件的查询"><a href="#不带条件的查询" class="headerlink" title="不带条件的查询"></a>不带条件的查询</h5><p>查询命令：<code>db.表名.find()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVASCRIPT</span><br><span class="line">&gt; db.user.find()</span><br><span class="line">&#123; &quot;_id&quot; : 1, &quot;uname&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;男&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 2, &quot;uname&quot; : &quot;lisi&quot;, &quot;age&quot; : 19, &quot;sex&quot; : &quot;男&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 3, &quot;uname&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;女&quot; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="带条件的查询"><a href="#带条件的查询" class="headerlink" title="带条件的查询"></a>带条件的查询</h5><p>查询命令：<code>db.表名.find(&#123;条件&#125;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">&gt; db.user.find(&#123;sex:&quot;男&quot;,uname:&quot;zhangsan&quot;&#125;)  //支持多条件查询</span><br><span class="line">&#123; &quot;_id&quot; : 1, &quot;uname&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;男&quot; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>更新命令：<code>db.表名.update(&#123;条件&#125;,&#123;$set:&#123;&#125;&#125;)</code> &#x2F;&#x2F;这里条件也和查询一样支持多条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STYLUS</span><br><span class="line">&gt; db.user.update(&#123;_id:1&#125;,&#123;$set:&#123;uname:&quot;ouwen&quot;&#125;&#125;)  //把_id为1的uname改为ouwen</span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class="line">&gt; db.user.find()</span><br><span class="line">&#123; &quot;_id&quot; : 1, &quot;uname&quot; : &quot;ouwen&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;男&quot; &#125;  //修改成功</span><br><span class="line">&#123; &quot;_id&quot; : 2, &quot;uname&quot; : &quot;lisi&quot;, &quot;age&quot; : 19, &quot;sex&quot; : &quot;男&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 3, &quot;uname&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;女&quot; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>删除命令：<code>db.表名.remove(&#123;条件&#125;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STYLUS</span><br><span class="line">&gt; db.user.remove(&#123;uname:&quot;lisi&quot;&#125;) //删除uname为lisi的数据</span><br><span class="line">WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)</span><br><span class="line">&gt; db.user.find()</span><br><span class="line">&#123; &quot;_id&quot; : 1, &quot;uname&quot; : &quot;ouwen&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;男&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 3, &quot;uname&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;女&quot; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="查看所有的数据集"><a href="#查看所有的数据集" class="headerlink" title="查看所有的数据集"></a>查看所有的数据集</h4><p>相当于查看表：<code>show collections</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">show collections</span><br><span class="line">user    //我这里只有一张表</span><br></pre></td></tr></table></figure>

<h4 id="删除数据集合"><a href="#删除数据集合" class="headerlink" title="删除数据集合"></a>删除数据集合</h4><p>类似于删除表：<code>db.表名.drop()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PGSQL</span><br><span class="line">&gt; db.user.drop()</span><br><span class="line">true    //成功删除user表</span><br></pre></td></tr></table></figure>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>先使用要删除的数据库：<code>use books</code></p>
<p>删除命令：<code>db.dropDatabase()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STATA</span><br><span class="line">&gt; use books   //使用books数据库</span><br><span class="line">switched to db books</span><br><span class="line">&gt; db.dropDatabase()   //删除它</span><br><span class="line">&#123; &quot;dropped&quot; : &quot;books&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br></pre></td></tr></table></figure>

<h3 id="退出数据库连接"><a href="#退出数据库连接" class="headerlink" title="退出数据库连接"></a>退出数据库连接</h3><p>可以使用<code>Crl+C</code>或者输入<code>exit</code>回车</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">&gt; exit</span><br><span class="line">bye</span><br><span class="line">root@iZ2ze4ojx7qtz1wv44gajnZ:~#</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 集群部署案例设计</title>
    <url>/2023/03/04/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Redis%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="面试题：1-2-亿条数据需要缓存，请问如何设计这个存储案例？"><a href="#面试题：1-2-亿条数据需要缓存，请问如何设计这个存储案例？" class="headerlink" title="面试题：1~2 亿条数据需要缓存，请问如何设计这个存储案例？"></a>面试题：1~2 亿条数据需要缓存，请问如何设计这个存储案例？</h2><p>单机单台 100%不可能，肯定是分布式存储，用 redis 如何落地？</p>
<h3 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606231141.png" alt="image-20220606231134623"></p>
<p>2 亿条记录就是 2 亿个 k,v，我们单机不行必须要分布式多机，假设有 3 台机器构成一个集群，用户每次读写操作都是根据公式：</p>
<p>hash(key) % N 个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p>
<ul>
<li>优点</li>
</ul>
<p>简单粗暴，直接有效，只需要预估好数据规划好节点，例如 3 台、8 台、10 台，就能保证一段时间的数据支撑。使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p>
<ul>
<li>缺点</li>
</ul>
<p>原来规划好的节点，进行扩容或者缩容就比较麻烦了，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3 会变成 Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。某个 redis 机器宕机了，由于台数数量变化，会导致 hash 取余全部数据重新洗牌。</p>
<h3 id="一致性-Hash-算法分区"><a href="#一致性-Hash-算法分区" class="headerlink" title="一致性 Hash 算法分区"></a>一致性 Hash 算法分区</h3><blockquote>
<p>一致性 Hash 算法背景</p>
<p>一致性哈希算法在 1997 年由麻省理工学院中提出的，设计目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不 OK 了。</p>
</blockquote>
<ol>
<li>算法构建一致性哈希环</li>
</ol>
<p>一致性哈希环</p>
<p>一致性哈希算法必然有个 hash 函数并按照算法产生 hash 值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个 hash 空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32),这样让它逻辑上形成了一个环形空间。</p>
<p>它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性 Hash 算法是对 2^32 取模，简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2^32-1（即哈希值是一个 32 位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、……直到 2^32-1，也就是说 0 点左侧的第一个点代表 2^32-1， 0 和 2^32-1 在零点中方向重合，我们把这个由 2^32 个点组成的圆环称为 Hash 环。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606231532.png" alt="image-20220606231532166"></p>
<ol>
<li>服务器 IP 节点映射</li>
</ol>
<p>节点映射</p>
<p>将集群中各个 IP 节点映射到环上的某一个位置。将各个服务器使用 Hash 进行一个哈希，具体可以选择服务器的 IP 或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如 4 个节点 NodeA、B、C、D，经过 IP 地址的哈希函数计算(hash(ip))，使用 IP 地址哈希后在环空间的位置如下：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606231612.png" alt="image-20220606231612002"></p>
<ol>
<li>key 落到服务器的落键规则</li>
</ol>
<p>当我们需要存储一个 kv 键值对时，首先计算 key 的 hash 值，hash(key)，将这个 key 使用相同的函数 Hash 计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>
<p>如我们有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性 Hash 算法，数据 A 会被定为到 Node A 上，B 被定为到 Node B 上，C 被定为到 Node C 上，D 被定为到 Node D 上。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606231644.png" alt="image-20220606231644182"></p>
<ul>
<li>优点</li>
</ul>
<p><strong>容错性</strong></p>
<p>假设 Node C 宕机，可以看到此时对象 A、B、D 不会受到影响，只有 C 对象被重定位到 Node D。一般的，在一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是 C 挂了，受到影响的只是 B、C 之间的数据，并且这些数据会转移到 D 进行存储。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606231817.png" alt="image-20220606231816969"></p>
<p><strong>扩展性</strong></p>
<p>数据量增加了，需要增加一台节点 NodeX，X 的位置在 A 和 B 之间，那收到影响的也就是 A 到 X 之间的数据，重新把 A 到 X 的数据录入到 X 上即可，不会导致 hash 取余全部数据重新洗牌。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606231839.png" alt="image-20220606231839770"></p>
<ul>
<li>缺点</li>
</ul>
<p>Hash 环的数据倾斜问题</p>
<p>一致性 Hash 算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606231915.png" alt="image-20220606231915547"></p>
<blockquote>
<p><strong>总结</strong></p>
<p>为了在节点数目发生改变时尽可能少的迁移数据</p>
<p>将所有的存储节点排列在收尾相接的 Hash 环上，每个 key 在计算 Hash 后会&#x3D;&#x3D;顺时针&#x3D;&#x3D;找到临近的存储节点存放。</p>
<p>而当有节点加入或退出时仅影响该节点在 Hash 环上&#x3D;&#x3D;顺时针相邻的后续节点&#x3D;&#x3D;。</p>
<ul>
<li><strong>优点</strong></li>
</ul>
<p>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p>
</blockquote>
<h3 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h3><blockquote>
<p>&#x3D;&#x3D;为什么出现？&#x3D;&#x3D;</p>
<p>解决一致性哈希算法出现的数据倾斜问题</p>
<p>哈希槽实质就是一个数组，数组[0,2^14 -1]形成 hash slot 空间。</p>
<p>&#x3D;&#x3D;能干什么？&#x3D;&#x3D;</p>
<p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p>
<p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p>
<p>哈希解决的是映射问题，使用 key 的哈希值来计算所在的槽，便于数据分配。</p>
<p>&#x3D;&#x3D;多少个哈希槽？&#x3D;&#x3D;</p>
<p>一个集群只能有 16384 个槽，编号 0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对 key 求哈希值，然后对 16384 取余，余数是几 key 就落入对应的槽里。slot &#x3D; CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>
</blockquote>
<p><strong>哈希槽计算</strong></p>
<p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key 之 A 、B 在 Node2， key 之 C 落在 Node3 上。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606232459.png" alt="image-20220606232459710"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606232446.png" alt="image-20220606232446308"></p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Git分支管理规范</title>
    <url>/2022/07/26/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="分支分类"><a href="#分支分类" class="headerlink" title="分支分类"></a>分支分类</h2><ol>
<li><strong>根据生命周期区分</strong></li>
</ol>
<ul>
<li><strong>主分支：</strong>master，develop；</li>
<li><strong>临时分支：</strong>feature&#x2F;_，release&#x2F;_，hotfix&#x2F;*；</li>
</ul>
<ol>
<li><strong>根据用途区分</strong></li>
</ol>
<ul>
<li><p><strong>发布&#x2F;预发布分支：</strong>master，release&#x2F;*；</p>
</li>
<li><p><strong>开发分支：</strong>develop；</p>
</li>
<li><p>功能分支：</p>
<p>feature&#x2F;*；</p>
<ul>
<li><strong>热修复分支：</strong>hotfix&#x2F;*；</li>
</ul>
</li>
</ul>
<h2 id="分支用途"><a href="#分支用途" class="headerlink" title="分支用途"></a>分支用途</h2><h3 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h3><p>master 分支主要方稳定、随时可上线的版本。这个分支只能从别的分支上合并过来，一般来讲，从 develop 上合并，或者从 bugfix 分支上合并过来。不能直接在 master 分支上进行 commit 文件。因为是稳定的版本，所以每次版本发布都要在这个分支上添加<code>标签</code>(tag)。</p>
<h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a>develop 分支</h3><p>develop 分支是所有开发分支的母体，所有的开发分支都要从 develop 上切出来，开发完成之后最后都要合并到 develop 上。</p>
<h3 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="hotfix 分支"></a>hotfix 分支</h3><p>命名规则：<code>hotfix/*</code> –&gt; <code>hotfix/v+bug修复的版本号</code></p>
<p>hotfix 分支用来修复生产中的紧急 bug，由于 develop 分支尚处于开发过程中，代码不稳定，不能直接应用于生产。所以从 master 分支上切出一个分支，修复完成之后合并到 master 分支，并且合并到 develop 上。</p>
<h3 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a>release 分支</h3><p>命名规则：<code>release/*</code> –&gt; <code>release/v+发布的版本号</code></p>
<p>release 分支可以称之为预发布的版本。当我们认为 develop 版本的代码已经趋于成熟，我们可以打一个 release 分支。在 release 分支上测试完成之后，要将代码合并到 master 分支和 develop 上。master 分支是线上版本，而合并到 develop 版本是因为，在测试过程中，一些细节的东西可能会修改，因此这些优化的内容也应该合并到最终版本以及开发版本中。</p>
<h3 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h3><p>命名规则：<code>feature/*</code> –&gt; <code>feature/功能名称</code></p>
<p>feature 分支是最经常使用的分支了。当我们收到一个新的开发功能时，应该在 develop 分支上切出一个 feature 分支。用来完成新功能的开发，开发完成之后，要合并进 develop 分支上。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221028110813.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221028110813.png" alt="img"></a></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 配置 HTTPS 协议访问</title>
    <url>/2022/04/26/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Tomcat%20%E9%85%8D%E7%BD%AE%20HTTPS%20%E5%8D%8F%E8%AE%AE%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Tomcat 默认支持 HTTP 协议访问，项目需求要修改 Tomcat 支持 HTTPS 协议访问。</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="使用-Java-自带的-keytool-生成证书"><a href="#使用-Java-自带的-keytool-生成证书" class="headerlink" title="使用 Java 自带的 keytool 生成证书"></a>使用 Java 自带的 keytool 生成证书</h3><p>打开控制台输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">keytool -genkey -v -alias testKey -keyalg RSA -validity 3650 -keystore D:\apache-tomcat-7.0.26\keys\test.keystore -ext SAN=ip:127.0.0.1</span><br><span class="line"></span><br><span class="line">keytool -export -alias testKey -file wxsccp.cer -keystore test.jks</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APACHE</span><br><span class="line">alias: 别名 这里起名keys</span><br><span class="line">keyalg: 证书算法，RSA</span><br><span class="line">validity：证书有效时间，10年</span><br><span class="line">keystore：证书生成的目标路径和文件名,替换成你自己的路径即可,我定义的是D:\apache-tomcat-7.0.26\keys\test.keystore，其中keys文件夹必须存在</span><br></pre></td></tr></table></figure>

<p>之后回车，然后需要输入一些信息，其中秘钥库口令和秘钥口令最好一致，并且记下来（之后配置 Tomcat 需要用到）</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210607134909.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210607134909.png" alt="image-20210607134909105"></a></p>
<h3 id="配置-Tomcat"><a href="#配置-Tomcat" class="headerlink" title="配置 Tomcat"></a>配置 Tomcat</h3><p>打开 Tomcat 的 conf 目录下的 <code>server.xml</code>文件，定位 <code>https</code> 到指定位置，完整配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;</span><br><span class="line">               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;</span><br><span class="line">               keystoreFile=&quot;D:\software\EOS\apache-tomcat-7.0.54\keys\test.keystore&quot;</span><br><span class="line">               keystorePass=&quot;vansys&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>keystoreFile：上面生成的证书所在目录</li>
<li>keystorePass：生成证书时输入的秘钥</li>
</ul>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210607135533.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210607135533.png" alt="image-20210607135533347"></a></p>
<p>添加 http 跳转 https 协议访问，在 web.xml 文件末尾添加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;security-constraint&gt;</span><br><span class="line">    &lt;web-resource-collection &gt;</span><br><span class="line">        &lt;web-resource-name &gt;SSL&lt;/web-resource-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/web-resource-collection&gt;</span><br><span class="line">    &lt;user-data-constraint&gt;</span><br><span class="line">        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;</span><br><span class="line">    &lt;/user-data-constraint&gt;</span><br><span class="line">&lt;/security-constraint&gt;</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210607135715.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210607135715.png" alt="image-20210607135715701"></a></p>
<h3 id="重启-Tomcat-服务器"><a href="#重启-Tomcat-服务器" class="headerlink" title="重启 Tomcat 服务器"></a>重启 Tomcat 服务器</h3><p>这样就能通过 https 协议访问我们的项目：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210607140001.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210607140001.png" alt="image-20210607140001797"></a></p>
<p>但是发现：</p>
<p>使用自己生成的证书会遇到一些问题：</p>
<ul>
<li><strong>浏览器会对 HTTPS 使用危险标识。</strong></li>
<li><strong>浏览器默认不会加载非 HTTPS 域名下的 javascript</strong></li>
<li><strong>移动设备显示页面空白</strong></li>
</ul>
<h2 id="解决证书无效问题"><a href="#解决证书无效问题" class="headerlink" title="解决证书无效问题"></a>解决证书无效问题</h2><p>要解决自己生成的证书无效的问题，需要购买相应的 SSL 证书。<a href="https://www.aliyun.com/product/cas">证书服务<em>SSL 数字证书_HTTPS 加密</em>服务器证书_CA 认证-阿里云</a></p>
<p>不过我之前用过一些免费的证书申请网站 <a href="https://freessl.cn/">FreeSSL 首页 - FreeSSL.cn 一个提供免费 HTTPS 证书申请的网站</a></p>
<h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><p>略</p>
<h3 id="Tomcat-配置-PFX-证书"><a href="#Tomcat-配置-PFX-证书" class="headerlink" title="Tomcat 配置 PFX 证书"></a>Tomcat 配置 PFX 证书</h3><p>打开 Tomcat 配置文件 <code>conf\server.xml</code></p>
<p>定位 <code>https</code> 到指定位置，修改三个属性 ：<code>keystoreFile</code>，<code>keystoreType</code>，<code>keystorePass</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">  &lt;Connector</span><br><span class="line">        protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">        port=&quot;443&quot; maxThreads=&quot;200&quot;</span><br><span class="line">        scheme=&quot;https&quot; secure=&quot;true&quot; SSLEnabled=&quot;true&quot;</span><br><span class="line">     clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;</span><br><span class="line">        keystoreFile=&quot;/你的磁盘目录/证书文件名.pfx&quot;  &lt;!--这里是证书文件存放路径--&gt;</span><br><span class="line">        keystoreType=&quot;PKCS12&quot;   &lt;!--这里是证书格式，.pfx和.p12都是PKCS12格式的--&gt;</span><br><span class="line">        keystorePass=&quot;123456&quot;    &lt;!--刚才输入的密码--&gt;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="重启-Tomcat-服务器，访问测试"><a href="#重启-Tomcat-服务器，访问测试" class="headerlink" title="重启 Tomcat 服务器，访问测试"></a>重启 Tomcat 服务器，访问测试</h3>]]></content>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 入门学习</title>
    <url>/2022/07/18/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em><code>Git</code></em> 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br><em><code>Git</code></em> 是 <em><code>Linus Torvalds</code></em> 为了帮助管理 <code>Linux</code> 内核开发而开发的一个开放源码的版本控制软件。<br><em><code>Git</code></em> 与常用的版本控制工具 <code>CVS</code>, <code>Subversion</code> 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
<h2 id="Git安装配置"><a href="#Git安装配置" class="headerlink" title="Git安装配置"></a><em>Git</em>安装配置</h2><h3 id="下载-Git"><a href="#下载-Git" class="headerlink" title="下载 Git"></a>下载 Git</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 从入门到实战</title>
    <url>/2022/05/20/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h2><p>本文 <em>Linux</em> 环境基于 <em><code>centos7</code></em></p>
<h3 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h3><p>常用版本分为四大阵营</p>
<ul>
<li>Nginx 开源版 <a href="http://nginx.org/">http://nginx.org/</a></li>
<li>Nginx plus 商业版 <a href="https://www.nginx.com/">https://www.nginx.com</a></li>
<li>openresty <a href="http://openresty.org/cn/">http://openresty.org/cn/</a></li>
<li>Tengine <a href="http://tengine.taobao.org/">http://tengine.taobao.org/</a></li>
</ul>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>这里下载的是 <code>nginx-1.21.6.tar.gz</code> 解压后编译安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 解压</span><br><span class="line">tar zxvf nginx-1.21.6.tar.gz -C ./</span><br><span class="line">cd nginx-1.21.6</span><br><span class="line"># 执行配置脚本(不执行默认会安装在该目录)</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line"># 安装</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="如果出现警告或报错"><a href="#如果出现警告或报错" class="headerlink" title="如果出现警告或报错"></a>如果出现警告或报错</h4><p>一般是缺少依赖的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 安装gcc</span><br><span class="line">yum install -y gcc</span><br><span class="line"># 安装perl库</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line"># 安装zlib库</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line"># 重新执行安装</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="安装成系统服务"><a href="#安装成系统服务" class="headerlink" title="安装成系统服务"></a>安装成系统服务</h3><ol>
<li>创建服务脚本</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure>

<ol>
<li>服务脚本内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRADLE</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx - web server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">ExecQuit=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<ol>
<li>重新加载系统服务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<ol>
<li>启动服务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure>

<ol>
<li>开机自启</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure>

<h2 id="Nginx-基础使用"><a href="#Nginx-基础使用" class="headerlink" title="Nginx 基础使用"></a>Nginx 基础使用</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>进入 <em><code>Nginx</code></em> 的主目录可以看到这些文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIPSASM</span><br><span class="line">client_body_temp conf fastcgi_temp html logs proxy_temp sbin scgi_temp uwsgi_temp</span><br></pre></td></tr></table></figure>

<p>其中这几个文件夹在刚安装时是没有的， 主要用来存放运行过程中的临时文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EBNF</span><br><span class="line">client_body_temp fastcgi_temp proxy_temp scgi_temp</span><br></pre></td></tr></table></figure>

<ul>
<li>conf：用来存放配置文件</li>
<li>html：用来存放静态文件的默认目录 html、css 等</li>
<li>sbin：nginx 的主程序</li>
<li>logs：nginx 运行日志</li>
</ul>
<h3 id="基本运行原理"><a href="#基本运行原理" class="headerlink" title="基本运行原理"></a>基本运行原理</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220424022100.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220424022100.png" alt="image-20220424022053512"></a></p>
<h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><h3 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CRMSH</span><br><span class="line"></span><br><span class="line">#  默认为1，表示开启一个业务进程</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">	# 单个业务进程可接受连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">	# 引入http mime类型</span><br><span class="line">    include       mime.types;</span><br><span class="line">    # 如果mime类型没匹配上，默认使用二进制流的方式传输。</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">	使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。</span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">	# 虚拟主机 vhost</span><br><span class="line">    server &#123;</span><br><span class="line">    	# 监听端口号</span><br><span class="line">        listen       80;</span><br><span class="line">        # 域名、主机名</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">		# 匹配路径</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # 文件根目录</span><br><span class="line">            index  index.html index.htm; # 默认页名称</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		# 报错编码对应页面</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>原本一台服务器只能对应一个站点，通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务</p>
<p><strong>server_name 匹配规则</strong></p>
<p>我们需要注意的是 <code>server_name</code> 匹配分先后顺序，写在前面的匹配上就不会继续往下匹配了。</p>
<ul>
<li>完整匹配</li>
</ul>
<p>可以在同一个 <code>server_name</code> 中配置多个域名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABNF</span><br><span class="line">server_name abc.com abc123.com;</span><br></pre></td></tr></table></figure>

<ul>
<li>通配符匹配</li>
</ul>
<p>可以通过 <code>*</code> 通配符来模糊匹配多个域名，可以在开始和结尾使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line">server_name *.abc.com abc.*</span><br></pre></td></tr></table></figure>

<ul>
<li>正则匹配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APACHE</span><br><span class="line">server_name ~^[0-9]+\.abc\.com$</span><br></pre></td></tr></table></figure>

<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>通过关键字 <code>proxy_pass</code> 关键字来指定一个服务器地址（ip&#x2F;域名）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line">location / &#123;</span><br><span class="line">	proxy_pass http://www.baidu.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul>
<li>基于反向代理的负载均衡配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line">upstream app &#123;</span><br><span class="line">    server 192.168.88.102:80;</span><br><span class="line">    server 192.168.88.103:80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">	proxy_pass http://app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><ul>
<li><strong>轮询</strong></li>
</ul>
<p>默认情况下使用轮询方式，逐一转发，这种方式适用于无状态请求</p>
<ul>
<li>权重（weight）<ul>
<li>down：表示当前的主机暂时不参与负载</li>
<li>weight：默认为 1，weight 越大，负载的权重就越大</li>
<li>backup： 其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器</li>
</ul>
</li>
</ul>
<p>指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line">upstream app &#123;</span><br><span class="line">    server 192.168.88.102:80 weight=10 down;</span><br><span class="line">    server 192.168.88.103:80 weight=1;</span><br><span class="line">    server 127.0.0.1:8060 weight=1 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ip_hash</strong></li>
</ul>
<p>根据客户端的 ip 地址转发同一台服务器，可以保持回话</p>
<ul>
<li><strong>least_conn</strong></li>
</ul>
<p>最少连接数访问</p>
<ul>
<li><strong>url_hash</strong></li>
</ul>
<p>根据用户访问的 url 定向转发请求</p>
<ul>
<li><strong>fair</strong></li>
</ul>
<p>根据后端服务器响应时间转发请求</p>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><ul>
<li>配置后端服务的反向代理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line">location / &#123;</span><br><span class="line">	proxy_pass http://127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置前端静态资源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line"></span><br><span class="line">location /css &#123;</span><br><span class="line">    root /usr/local/nginx/static;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images &#123;</span><br><span class="line">    root /usr/local/nginx/static;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /js &#123;</span><br><span class="line">    root /usr/local/nginx/static;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 正则匹配</span><br><span class="line">location ~*/(css|img|js) &#123;</span><br><span class="line">    root /usr/local/nginx/static;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="location-配置规则"><a href="#location-配置规则" class="headerlink" title="location 配置规则"></a>location 配置规则</h3><h4 id="location-前缀"><a href="#location-前缀" class="headerlink" title="location 前缀"></a>location 前缀</h4><ul>
<li>&#x2F; 通用匹配，任何请求都会匹配到</li>
<li>&#x3D; 精准匹配，不是以指定模式开头</li>
<li>~ 正则匹配，区分大小写</li>
<li>~* 正则匹配，不区分大小写</li>
<li>^~ 非正则匹配，匹配以指定模式开头的 location</li>
</ul>
<h4 id="location-匹配规则"><a href="#location-匹配规则" class="headerlink" title="location 匹配规则"></a>location 匹配规则</h4><ul>
<li>多个正则 <code>location</code> 直接按书写顺序匹配，匹配成功后就不会往下匹配</li>
<li>普通（非正则）<code>location</code> 会一直往下，直到找到匹配度最高的（最大前缀匹配）</li>
<li>当普通 <code>location</code> 与正则 <code>location</code> 同时存在，如果正则匹配成功,则不会再执行普通匹配</li>
<li>所有类型 <code>location</code> 存在时，<code>=匹配</code> &gt; <code>^~匹配</code> &gt; <code>正则匹配</code> &gt; <code>普通（最大前缀匹配）</code></li>
</ul>
<h4 id="alias-与-root"><a href="#alias-与-root" class="headerlink" title="alias 与 root"></a>alias 与 root</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root` 用来设置根目录，而 `alias` 在接受请求的时候在路径上不会加上 `location</span><br><span class="line">NGINX</span><br><span class="line">location /css &#123;</span><br><span class="line">    alias /usr/local/nginx/static/css;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>alias 指定的目录是准确的，即 location 匹配访问的 path 目录下的文件直接是在 alias 目录下查找的；</li>
<li>root 指定 的目录是 location 匹配访问的 path 目录的上一级目录,这个 path 目录一定要是真实存在 root 指定目录下的；</li>
<li>使用 alias 标签的目录块中不能使用 rewrite 的 break（具体原因不明）；另外，alias 指定的目录后面必须要加上”&#x2F;“符 号！！</li>
<li>alias 虚拟目录配置中，location 匹配的 path 目录如果后面不带”&#x2F;“，那么访问的 url 地址中这个 path 目录后 面加不加”&#x2F;“不影响访问，访问时它会自动加上”&#x2F;“； 但是如果 location 匹配的 path 目录后面加上”&#x2F;“，那么访问的 url 地 址中这个 path 目录必须要加上”&#x2F;“，访问时它不会自动加上”&#x2F;“。如果不加上”&#x2F;“，访问就会失败！</li>
<li>root 目录配置中，location 匹配的 path 目录后面带不带”&#x2F;“，都不会影响访问。</li>
</ul>
<h3 id="URLRewrite"><a href="#URLRewrite" class="headerlink" title="URLRewrite"></a>URLRewrite</h3><p>rewirte 语法格式及参数语法：</p>
<p><code>rewrite</code> 是实现 URL 重写的关键指令，根据 <code>regex (正则表达式)</code> 部分内容，重定向到 <code>replacement</code>，结尾是 <code>flag</code> 标记。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">rewrite   &lt;regex&gt;   &lt;replacement&gt;   [flag];</span><br><span class="line">关键字     正则       替代内容         flag标记</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键字</strong>：其中关键字 <code>rewrite</code> 不能改变</li>
<li><strong>正则</strong>：正则表达式语句进行规则匹配</li>
<li><strong>替代内容</strong>：将正则匹配的内容替换成 <code>replacement</code></li>
<li><strong>flag 标记</strong>：<code>rewrite</code> 支持的 <code>flag</code> 标记</li>
</ul>
<blockquote>
<p>rewrite 参数的标签段位置：server、location、if</p>
</blockquote>
<p><strong>flag 标记说明：</strong></p>
<ul>
<li>last：本条规则匹配完成后，继续向下匹配新的 location URI 规则</li>
<li>break：本条规则匹配完成即终止，不再匹配后面的任何规则</li>
<li>redirect：返回 302 临时重定向，浏览器地址会显示跳转后的 URL 地址</li>
<li>permanent：返回 301 永久重定向，浏览器地址栏会显示跳转后的 URL 地址</li>
</ul>
<h3 id="防盗链配置"><a href="#防盗链配置" class="headerlink" title="防盗链配置"></a>防盗链配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line">valid_referers none | blocked | server_names | strings ....;</span><br></pre></td></tr></table></figure>

<ul>
<li>none：检测 <code>Referer</code> 头域不存在的情况</li>
<li>blocked：检测 <code>Referer</code> 头域的值被防火墙或者代理服务器删除或伪装的情况。这种情况该头域的值不以 <code>http://</code> 或 <code>https://</code> 开头</li>
<li>server_names：设置一个或多个 <code>URL</code> ，检测 <code>Referer</code> 头域的值是否是这些 <code>URL</code> 中的某一个。</li>
</ul>
<p><strong>使用 curl 测试</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">curl -I http://192.168.44.101/img/logo.png</span><br><span class="line"></span><br><span class="line"># -I 表示只显示响应的头信息</span><br></pre></td></tr></table></figure>

<p><strong>带引用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">curl -e &quot;http://baidu.com&quot; -I http://192.168.44.101/img/logo.png</span><br></pre></td></tr></table></figure>

<h3 id="高可用配置"><a href="#高可用配置" class="headerlink" title="高可用配置"></a>高可用配置</h3><h4 id="安装-Keepalived"><a href="#安装-Keepalived" class="headerlink" title="安装 Keepalived"></a>安装 Keepalived</h4><ul>
<li>编译安装</li>
</ul>
<p>下载地址：<a href="https://www.keepalived.org/download.html#">https://www.keepalived.org/download.html#</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERLANG-REPL</span><br><span class="line"># 解压之后通过命令安装</span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line"># 如遇报错提示</span><br><span class="line">configure: error:</span><br><span class="line">!!! OpenSSL is not properly installed on your system. !!!</span><br><span class="line">!!! Can not include OpenSSL headers files. !!!</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">yum install openssl-devel</span><br></pre></td></tr></table></figure>

<ul>
<li>yum 安装</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMAKE</span><br><span class="line">yum install keepalived</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>使用 <code>yum</code> 安装后的配置文件在 <code>/etc/keepalived/keepalived.conf</code></p>
<p><strong>最小配置</strong></p>
<p>主机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ANGELSCRIPT</span><br><span class="line"></span><br><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">	router_id lb101</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance vansys &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">    	192.168.44.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ANGELSCRIPT</span><br><span class="line"></span><br><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">	router_id lb100</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance vansys &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">    	192.168.44.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CRMSH</span><br><span class="line">systemctl start keepalived</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表理论知识</title>
    <url>/2022/01/11/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>当一张表的数据达到几千万时，查询一次所花的时间会变得很长，系统效率会下降。<code>Oracle</code> 官方推荐单表容量为 <strong>500w</strong> 以下为最佳状态。</p>
<p>但单表或单库达到性能瓶颈时，就需要对数据库进行拆分，数据库拆分又分为：</p>
<ul>
<li><strong>垂直拆分</strong></li>
<li><strong>水平拆分</strong></li>
</ul>
<h2 id="二、垂直拆分"><a href="#二、垂直拆分" class="headerlink" title="二、垂直拆分"></a>二、垂直拆分</h2><p>垂直拆分可以分为：<code>垂直分表</code> 和 <code>垂直分库</code>。</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p><strong>概念：</strong>把一个表的多个字段分别拆成多个表，一般按字段的访问频次拆分，经常访问的字段一个表，不经常访问的字段一个表。减少布不必要的字段查询，提高数据库性能。</p>
<p><strong>如图：</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217164518.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217164518.png" alt="image-20220217164518085"></a></p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p><strong>概念：</strong>就是根据业务耦合性，将关联度低的不同表存储在不同的数据库中。做法与大系统拆分成多个小系统类似，按业务类型进行独立划分。与 <code>微服务划分</code> 的做法类似。每个微服务使用单独的一个数据库。</p>
<p><strong>如图：</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217155607.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217155607.png" alt="image-20220217155607149"></a></p>
<p><strong>说明：</strong></p>
<p>业务数据量小的情况下，只有一个数据库，所有的表都在这个库里。</p>
<p>业务扩展，数据量增加，单体服务转变为微服务治理。要将之前的库按业务类型拆分成多个库。每个微服务对应一个库。</p>
<h3 id="垂直拆分优缺点"><a href="#垂直拆分优缺点" class="headerlink" title="垂直拆分优缺点"></a>垂直拆分优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>解决业务系统层面的耦合，业务清晰</li>
<li>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</li>
<li>高并发场景下，垂直切分能一定程度的提升 IO、数据库连接数、单机硬件资源的瓶颈</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>分库后无法 Join 查询，只能通过接口聚合方式解决，提高了开发的复杂度</li>
<li>分库后分布式事务问题处理复杂</li>
<li>依然会存在单表数据量过大的问题（需要进行水平拆分）</li>
</ul>
<h2 id="三、水平拆分"><a href="#三、水平拆分" class="headerlink" title="三、水平拆分"></a>三、水平拆分</h2><p>当一个应用难以再通过细粒度的垂直拆分或拆分之后数据量行数过大，存在单库、单表读写及存储性能瓶颈，这时就需要进行水平拆分。</p>
<p>水平拆分也可以分为：<code>水平分库</code> 和 <code>水平分表</code>。</p>
<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p><strong>原因：</strong>上面虽然已经把商品库分成 3 个库，但是随着业务的增加，系统的 QPS 过高，数据库响应速度来不及。但系统 QPS 达到瓶颈时就要考虑分库。</p>
<p><strong>如图：</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217163006.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217163006.png" alt="image-20220217163006880"></a></p>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p><strong>原因：</strong>一般我们一张表的数据不要超过 <strong>500w</strong>，如果表数据超过 <strong>500w</strong>，并且还在不断增加数据，那就可以考虑分表。</p>
<p><strong>如图：</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217164412.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217164412.png" alt="image-20220217164412132"></a></p>
<h3 id="水平拆分优缺点"><a href="#水平拆分优缺点" class="headerlink" title="水平拆分优缺点"></a>水平拆分优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>避免单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</li>
<li>应用端改造较小，不需要拆分业务模块</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>跨分片的事务一致性难以保证</li>
<li>跨库的 Join 关联查询性能较差</li>
<li>数据多次扩展难度和维护量极大</li>
</ul>
<h2 id="四、数据分片规则"><a href="#四、数据分片规则" class="headerlink" title="四、数据分片规则"></a>四、数据分片规则</h2><p>当我们考虑去水平拆分表时，需要将一张表水平拆分成多张表，这就涉及到数据分片的规则，比较常见的有：<code>Hash取模分表</code>、<code>数值Range分表</code>、<code>一致性Hash算法分表</code>。</p>
<h3 id="Hash-取模分表"><a href="#Hash-取模分表" class="headerlink" title="Hash 取模分表"></a>Hash 取模分表</h3><p><strong>概念：</strong>一般采用 Hash 取模的拆分方式，例如：假设按 <code>goods_id</code> 分 4 张表。（<code>goods_id%4</code> 取整数确定表）</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217225906.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220217225906.png" alt="image-20220217225906590"></a></p>
<p><strong>优点：</strong></p>
<ul>
<li>数据分片相对均匀，不容易出现热点和并发访问的瓶颈</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>后期分片集群扩容时，需要迁移旧的数据很难。</li>
<li>容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带 goods_id 时，将会导致无法定位数据库，从而需要同时向 4 个库发起查询， 再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</li>
</ul>
<h3 id="数值-Range-分表"><a href="#数值-Range-分表" class="headerlink" title="数值 Range 分表"></a>数值 Range 分表</h3><p><strong>概念：</strong>按照时间区间或 ID 区间来拆分。比如：将 goods_id 为 1-1000 的记录分到第一个表，1001-2000 的分到第二个表，以此类推。</p>
<p><strong>如图：</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220218104101.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220218104101.png" alt="image-20220218104054253"></a></p>
<p><strong>优点：</strong></p>
<ul>
<li>单表大小可控</li>
<li>天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片数据进行迁移</li>
<li>使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>热点数据成为性能瓶颈（例如按时间进行分片，有些分片存储醉经时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询）</li>
</ul>
<h3 id="一致性-Hash-算法"><a href="#一致性-Hash-算法" class="headerlink" title="一致性 Hash 算法"></a>一致性 Hash 算法</h3><p>一致性 Hash 算法可以很好的 <strong>解决因为 Hash 取模而产生的分片集群扩容时，需要迁移旧的数据的难题。</strong></p>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/98030096">一致性 Hash 算法详解 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="五、分库分表带来的问题"><a href="#五、分库分表带来的问题" class="headerlink" title="五、分库分表带来的问题"></a>五、分库分表带来的问题</h2><p>&#x3D;&#x3D;<strong>在非必要的情况下，能不分就不分</strong>&#x3D;&#x3D;</p>
<p>因为分库分表会引入新的问题，任何单体系统拆分成多个都会提高系统维护的复杂度，破坏整体性。</p>
<h3 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h3><p>使用分布式事务中间件解决，具体是通过最终一致性还是强一致性分布式事务，看业务需求决定。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/u014590757/article/details/80100085">分库分表导致的分布式事务及其解决方案</a></p>
</blockquote>
<h3 id="跨节点关联查询-Join-问题"><a href="#跨节点关联查询-Join-问题" class="headerlink" title="跨节点关联查询 Join 问题"></a>跨节点关联查询 Join 问题</h3><p>切分之前，我们可以通过 Join 来完成。而切分之后，数据可能分布在不同的节点上，此时 Join 带来的问题就比较麻烦了，考虑到性能，尽量避免使用 Join 查询。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><code>全局表</code></li>
</ul>
<p>全局表，也可以看做是 <code>数据字典表</code>，就是系统中所有模块都可以依赖的一些表，为了避免跨库 Join 查询，可以将这类表</p>
<ul>
<li><code>字段冗余</code></li>
</ul>
<p><strong>利用空间换时间，为了性能而避免 Join 查询。</strong>例如：订单表保存 userId 时，也将 userName 冗余保存一份，这样查询订单详情时就不需要再去查询 <code>买家user表</code>了。</p>
<ul>
<li><code>数据组装</code></li>
</ul>
<p><strong>在系统层面，分两次查询。</strong>第一次查询的结果集中找出关联数据 id，然后根据 id 发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</p>
<h3 id="跨节点分页、排序、函数问题"><a href="#跨节点分页、排序、函数问题" class="headerlink" title="跨节点分页、排序、函数问题"></a>跨节点分页、排序、函数问题</h3><p>跨节点多库进行查询时，会出现 Limit 分页、Order by 排序等问题。分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。</p>
<h3 id="全局主键避重问题"><a href="#全局主键避重问题" class="headerlink" title="全局主键避重问题"></a>全局主键避重问题</h3><p>如果都用 <code>主键自增</code> 是肯定不行的，如果用 <code>UUID</code> 又无法做到根据主键排序，所以我们可以考虑通过 <code>雪花ID</code> 来作为数据库的主键。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/374667160">什么是雪花 ID？ - 分布式 ID 生成算法</a></p>
</blockquote>
<h3 id="数据迁移问题"><a href="#数据迁移问题" class="headerlink" title="数据迁移问题"></a>数据迁移问题</h3><p>采用 <code>双写的方式</code>，修改代码，所有涉及到分库分表的表的增、删、改的代码，都要对新库进行增删改。同时，再有一个数据抽取服务，不断地从老库抽数据，往新库写，边写边按时间比较数据是不是最新的。</p>
]]></content>
      <tags>
        <tag>分库分表理论知识</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RESTful 风格</title>
    <url>/2023/03/09/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20RESTful%20%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家对 RESTful 肯定不陌生，就算不知道它到底是什么，但肯定听过这个玩意。相信大家也很想知道 RESTful 能解决什么样的问题，有什么应用场景？看完本篇文章你就能明白：</p>
<p>在互联网并没有盛行的时代， 移动端也还没有发展起来，页面请求和并发量也不高，那时候人们对接口的要求并不高，一些常规的动态页面（JSP）就能满足大部分人们的需求。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210610104619.png" alt="image-20210610104612710"></p>
<p>但是随着移动设备和互联网的发展，人们对 Web 应用的需求也逐渐增加，传统的动态页面（JSP）也因效率低下而渐渐被 HTML + JavaScript（Ajax）的前后端分离所替代，而安卓、IOS、小程序等不同的客户端层出不穷，客户端的种类出现多元化，<strong>而客户端需要接口跟服务端进行通信</strong>，但接口的 <strong>规范性</strong> 就成了一个问题：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210610105253.png" alt="image-20210610105253175"></p>
<p>所以一套 <strong>结构清晰、符合标准、易于理解、扩展方便</strong> 并且让大部分人都能理解并接收的接口风格就显得尤为重要，而 RESTful 风格的接口（RESTful API）刚好符合以上标准，就逐渐被应用从而流行起来。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210610105729.png" alt="image-20210610105729739"></p>
<p>现在，RESTful 是目前最流行的接口设计规范，在很多公司有着广泛的使用。在开发实践中我们很多人可能还是使用传统 API 进行请求交互，很多人其实并不特别了解 RESTful API，对 RESTful API 的认知可能会停留在：</p>
<ul>
<li>面向资源类型的</li>
<li>是一种风格</li>
<li>（误区）接口传递参数使用斜杆（&#x2F;）分割而用问号（?）传参</li>
</ul>
<p>而其实一个很大的误区不要认为没有查询字符串就是 RESTful API，也不要认为用了查询字符串就不是 RESTful API，更不要认为用了 JSON 传输的 API 就是 RESTful API。</p>
<h2 id="一、REST-介绍"><a href="#一、REST-介绍" class="headerlink" title="一、REST 介绍"></a>一、REST 介绍</h2><p>REST 涉及一些概念性的东西可能比较多，在实战 RESTful API 之前，要对 REST 相关的知识有个系统的认知。</p>
<h3 id="REST-的诞生"><a href="#REST-的诞生" class="headerlink" title="REST 的诞生"></a>REST 的诞生</h3><p>REST（英文：Representational State Transfer，简称 REST，直译过来表现层状态转换）是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>它首次出现在 2000 年 Roy Thomas Fielding 的博士论文中，这篇论文定义并详细介绍了表述性状态转移（Representational State Transfer，REST）的架构风格，并且描述了 如何使用 REST 来指导现代 Web 架构的设计和开发。用他自己的原话说：</p>
<blockquote>
<p>写这篇文章的目的是：在符合架构原理前提下，理解和评估基于网络的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。</p>
</blockquote>
<p>需要注意的是 <strong>REST 并没有一个明确的标准，而更像是一种设计的风格</strong> ，满足这种设计风格的程序或接口我们称之为 RESTful(从单词字面来看就是一个形容词)。所以 RESTful API 就是满足 REST 架构风格的接口。</p>
<h3 id="REST-架构特征"><a href="#REST-架构特征" class="headerlink" title="REST 架构特征"></a>REST 架构特征</h3><p>既然知道 REST 和 RESTful 的联系和区别，现在就要开始好好了解 RESTful 的一些约束条件和规则，RESTful 是一种风格而不是标准，而这个风格大致有以下几个主要 <strong>特征</strong>：</p>
<p><strong>以资源为基础</strong> ：资源可以是一个图片、音乐、一个 XML 格式、HTML 格式或者 JSON 格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以 JSON 为载体、面向用户的一组数据(通常从数据库中查询而得到)。</p>
<p><strong>统一接口</strong>: 对资源的操作包括获取、创建、修改和删除，这些操作正好对应 HTTP 协议提供的 GET、POST、PUT 和 DELETE 方法。换言而知，使用 RESTful 风格的接口但从接口上你可能只能定位其资源，但是无法知晓它具体进行了什么操作，需要具体了解其发生了什么操作动作要从其 HTTP 请求方法类型上进行判断。具体的 HTTP 方法和方法含义如下：</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<p>当然也有很多在具体使用的时候使用 PUT 表示更新。从请求的流程来看，RESTful API 和传统 API 大致架构如下：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210610133407.png" alt="image-20210610133407454"></p>
<p><strong>URI 指向资源</strong>：URI &#x3D; Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。URI 包括 URL 和 URN，在这里更多时候可能代指 URL(统一资源定位符)。RESTful 是面向资源的，每种资源可能由一个或多个 URI 对应，但一个 URI 只指向一种资源。</p>
<p><strong>无状态</strong>：服务器不能保存客户端的信息， 每一次从客户端发送的请求中，要包含所有必须的状态信息，会话信息由客户端保存， 服务器端根据这些状态信息来处理请求。当客户端可以切换到一个新状态的时候发送请求信息， 当一个或者多个请求被发送之后, 客户端就处于一个状态变迁过程中。每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁。</p>
<h3 id="REST-架构限制条件"><a href="#REST-架构限制条件" class="headerlink" title="REST 架构限制条件"></a>REST 架构限制条件</h3><p>Fielding 在论文中提出 REST 架构的 6 个<strong>限制条件</strong>，也可称为 RESTful 6 大原则， 标准的 REST 约束应满足以下 6 个原则：</p>
<p><strong>客户端-服务端（Client-Server）</strong>: 这个更专注客户端和服务端的分离，服务端独立可更好服务于前端、安卓、IOS 等客户端设备。</p>
<p><strong>无状态（Stateless）</strong>：服务端不保存客户端状态，客户端保存状态信息每次请求携带状态信息。</p>
<p><strong>可缓存性（Cacheability）</strong> ：服务端需回复是否可以缓存以让客户端甄别是否缓存提高效率。</p>
<p><strong>统一接口（Uniform Interface）</strong>：通过一定原则设计接口降低耦合，简化系统架构，这是 RESTful 设计的基本出发点。</p>
<p><strong>分层系统（Layered System）</strong>：客户端无法直接知道连接的到终端还是中间设备，分层允许你灵活的部署服务端项目。</p>
<p><strong>按需代码（Code-On-Demand，可选）</strong>：按需代码允许我们灵活的发送一些看似特殊的代码给客户端例如 JavaScript 代码。</p>
<h2 id="二、RESTful-API-设计规范"><a href="#二、RESTful-API-设计规范" class="headerlink" title="二、RESTful API 设计规范"></a>二、RESTful API 设计规范</h2><p>既然了解了 RESTful 的一些规则和特性，那么具体该怎么去设计一个 RESTful API 呢？要从 URL 路径、HTTP 请求动词、状态码和返回结果等方面详细考虑。</p>
<h3 id="URL-设计规范"><a href="#URL-设计规范" class="headerlink" title="URL 设计规范"></a>URL 设计规范</h3><p>URL 为统一资源定位器 ,接口属于服务端资源，首先要通过 URL 定位到资源才能去访问，而通常一个完整的 URL 组成由以下几个部分构成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABNF</span><br><span class="line">URI = scheme &quot;://&quot; host  &quot;:&quot;  port &quot;/&quot; path [ &quot;?&quot; query ][ &quot;#&quot; fragment ]</span><br></pre></td></tr></table></figure>

<ul>
<li>scheme: 指底层用的协议，如 http、https、ftp</li>
<li>host: 服务器的 IP 地址或者域名</li>
<li>port: 端口，http 默认为 80 端口</li>
<li>path: 访问资源的路径，就是各种 web 框架中定义的 route 路由</li>
<li>query: 查询字符串，为发送给服务器的参数，在这里更多发送数据分页、排序等参数。</li>
<li>fragment: 锚点，定位到页面的资源</li>
</ul>
<p>我们在设计 API 时 URL 的 path 是需要认真考虑的，而 RESTful 对 path 的设计做了一些规范，通常一个 RESTful API 的 path 组成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DTS</span><br><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>version：API 版本号，有些版本号放置在头信息中也可以，通过控制版本号有利于应用迭代。</li>
<li>resources：资源，RESTful API 推荐用小写英文单词的复数形式。</li>
<li>resource_id：资源的 id，访问或操作该资源。</li>
</ul>
<p>当然，有时候可能资源级别较大，其下还可细分很多子资源也可以灵活设计 URL 的 path，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DTS</span><br><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/&#123;subresources&#125;/&#123;subresource_id&#125;</span><br></pre></td></tr></table></figure>

<p>此外，有时可能增删改查无法满足业务要求，可以在 URL 末尾加上 action，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DTS</span><br><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/action</span><br></pre></td></tr></table></figure>

<p>其中 action 就是对资源的操作。</p>
<p>从大体样式了解 URL 路径组成之后，对于 RESTful API 的 URL 具体设计的规范如下：</p>
<ol>
<li>不用大写字母，所有单词使用英文且小写。</li>
<li>连字符用中杠<code>&quot;-&quot;</code>而不用下杠<code>&quot;_&quot;</code></li>
<li>正确使用 <code>&quot;/&quot;</code>表示层级关系,URL 的层级不要过深，并且越靠前的层级应该相对越稳定</li>
<li>结尾不要包含正斜杠分隔符<code>&quot;/&quot;</code></li>
<li>URL 中不出现动词，用请求方式表示动作</li>
<li>资源表示用复数不要用单数</li>
<li>不要使用文件扩展名</li>
</ol>
<h3 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h3><p>在 <code>RESTful API</code> 中，不同的 HTTP 请求方法有各自的含义，这里就展示 <code>GET,POST,PUT,DELETE</code> 几种请求 API 的设计与含义分析。针对不同操作，具体的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRADLE</span><br><span class="line">GET /collection：从服务器查询资源的列表（数组）</span><br><span class="line">GET /collection/resource：从服务器查询单个资源</span><br><span class="line">POST /collection：在服务器创建新的资源</span><br><span class="line">PUT /collection/resource：更新服务器资源</span><br><span class="line">DELETE /collection/resource：从服务器删除资源</span><br></pre></td></tr></table></figure>

<p>在非 RESTful 风格的 API 中，我们通常使用 GET 请求和 POST 请求完成增删改查以及其他操作，查询和删除一般使用 GET 方式请求，更新和插入一般使用 POST 请求。从请求方式上无法知道 API 具体是干嘛的，所有在 URL 上都会有操作的动词来表示 API 进行的动作，例如：<code>query，add，update，delete</code> 等等。</p>
<p>而 RESTful 风格的 API 则要求在 URL 上的都以名词的方式出现，从几种请求方式上就可以看出想要进行的操作，这与非 RSETful 风格的 API 形成鲜明的对比。</p>
<p>在谈及 <code>GET,POST,PUT,DELETE</code> 的时候，就必须提一下接口的 <strong>安全性和幂等性</strong>，其中安全性是指方法不会修改资源状态，即读的为安全的，写的操作为非安全的。而幂等性的意思是操作一次和操作多次的最终效果相同，客户端重复调用也只返回同一个结果。</p>
<p>上述四个 HTTP 请求方法的安全性和幂等性如下：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210610143432.png" alt="image-20210610143431940"></p>
<h3 id="状态码和返回数据"><a href="#状态码和返回数据" class="headerlink" title="状态码和返回数据"></a>状态码和返回数据</h3><p>服务端处理完成后客户端也可能不知道具体成功了还是失败了，服务器响应时，包含<strong>状态码</strong>和<strong>返回数据</strong>两个部分。</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>我们首先要正确使用各类状态码来表示该请求的处理执行结果。状态码主要分为五大类：</p>
<blockquote>
<p>1xx：相关信息<br>2xx：操作成功<br>3xx：重定向<br>4xx：客户端错误<br>5xx：服务器错误</p>
</blockquote>
<p>每一大类有若干小类，状态码的种类比较多，而主要常用状态码罗列在下面：</p>
<ul>
<li>200 <code>OK - [GET]</code>：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）</li>
<li>201 <code>CREATED - [POST/PUT/PATCH]</code>：用户新建或修改数据成功</li>
<li>202 <code>Accepted - [*]</code>：表示一个请求已经进入后台排队（异步任务）</li>
<li>204 <code>NO CONTENT - [DELETE]</code>：用户删除数据成功。</li>
<li>400 <code>INVALID REQUEST - [POST/PUT/PATCH]</code>：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的</li>
<li>401 <code>Unauthorized - [*]</code>：表示用户没有权限（令牌、用户名、密码错误）</li>
<li>403 <code>Forbidden - [*]</code> 表示用户得到授权（与 401 错误相对），但是访问是被禁止的</li>
<li>404 <code>NOT FOUND - [*]</code>：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的</li>
<li>406 <code>Not Acceptable - [GET]</code>：用户请求的格式不可得（比如用户请求 JSON 格式，但是只有 XML 格式）</li>
<li>410 <code>Gone -[GET]</code>：用户请求的资源被永久删除，且不会再得到的</li>
<li>422 <code>Unprocesable entity - [POST/PUT/PATCH]</code> 当创建一个对象时，发生一个验证错误</li>
<li>500 <code>INTERNAL SERVER ERROR - [*]</code>：服务器发生错误，用户将无法判断发出的请求是否成功</li>
</ul>
<h4 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h4><p>针对不同操作，服务器向用户返回数据，而各个团队或公司封装的返回实体类也不同，但都返回 JSON 格式数据给客户端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RESTful 风格的 API 固然很好很规范，但大多数互联网公司并没有按照或者完全按照其规则来设计，因为 REST 是一种风格，而不是一种约束或规则，过于理想的 RESTful API 会付出太多的成本。</p>
<p>比如 RESTful API 也有一些缺点：</p>
<ul>
<li>比如操作方式繁琐，<code>RESTful API</code> 通常根据 <code>GET、POST、PUT、DELETE</code> 来区分操作资源的动作，而 HTTP Method 本身不可直接见，是隐藏的，而如果将动作放到 URL 的 <code>path</code> 上反而清晰可见，更利于团队的理解和交流。</li>
<li>并且有些浏览器对 <code>GET,POST</code> 之外的请求支持不太友好，还需要特殊额外的处理。</li>
<li>过分强调资源，而实际业务 API 可能有各种需求比较复杂，单单使用资源的增删改查可能并不能有效满足使用需求，强行使用<code>RESTful</code> 风格 API 只会增加开发难度和成本。</li>
</ul>
<p>所以，当你或你们的技术团队在设计 API 的时候，如果使用场景和 REST 风格很匹配，那么你们可以采用 RESTful 风格 API。但是如果业务需求和 RESTful 风格 API 不太匹配或者很麻烦，那也可以不用 RESTful 风格 API 或者可以借鉴一下，毕竟无论那种风格的 API 都是为了方便团队开发、协商以及管理，不能墨守成规。</p>
]]></content>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>错误码及全局异常处理</title>
    <url>/2022/11/11/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E9%94%99%E8%AF%AF%E7%A0%81%E5%8F%8A%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在软件开发过程中，不可避免的是需要处理各种异常，在 Java 中，处理异常的方式一般就是采用<code>try&#123;...&#125;catch&#123;...&#125;finally&#123;...&#125;</code>代码块。在业务系统中，可能会有大量的异常处理代码块，这样不仅有大量的冗余代码，而且还影响代码的可读性。比较下面两张图：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220328132128.png" alt="image-20220328132128521"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220328132228.png" alt="image-20220328132228437"></p>
<p>可以看到，明显第二种的代码简洁，可读性高！此处的代码是在 Controller 层中的，在 Service 层中会有更多的异常处理代码块。</p>
<p>那么我们应该如何优雅的进行异常处理呢？</p>
<h2 id="什么是统一异常处理"><a href="#什么是统一异常处理" class="headerlink" title="什么是统一异常处理"></a>什么是统一异常处理</h2><p>在 Spring 里，我们可以使用@ControllerAdvice 来处理一些全局性的东西，最常见的是结合@ExceptionHandler 注解用于全局异常的处理。</p>
<p>@ControllerAdvice 是在类上声明的注解，其用法主要有三点：</p>
<ul>
<li><code>@ExceptionHandler</code>注解标注的方法：用于捕获 Controller 中抛出的不同类型的异常，从而达到异常全局处理的目的</li>
<li><code>@InitBinder</code>注解标注的方法：用于请求中注册自定义参数的解析，从而达到自定义请求参数格式的目的</li>
<li><code>@ModelAttribute</code>注解标注的方法：表示此方法会在执行目标 Controller 方法之前执行</li>
</ul>
<p>跟异常处理有关的只有<code>@ExceptionHandler</code>注解，从字面意思上理解，就是<code>异常处理器</code>的意思，其实际作用也正是如此：若在某个<code>Controller</code>类定义一个异常处理方法，并在方法上添加该注解，那么当出现指定的异常时，会执行该处理异常的方法，其可以使用<code>SpringMVC</code>提供的数据绑定，比如接受一个当前抛出的<code>Throwable</code>对象。</p>
<p>但是，这样一来，就必须在每一个<code>Controller</code>类都定义一套这样的异常处理方法，因为异常可以是各种各样。这样一来，就会造成大量的冗余代码，而且若需要新增一种异常的处理逻辑，就必须修改所有<code>Controller</code>类了，很不优雅。</p>
<p>当然你可能会说，那就定义个类似<code>BaseController</code>的基类，这样总行了吧。</p>
<p>这种做法虽然没错，但仍不尽善尽美，因为这样的代码有一定的侵入性和耦合性。简简单单的<code>Controller</code>，我为啥非得继承这样一个类呢，万一已经继承其他基类了呢。大家都知道<code>Java</code>只能继承一个类。</p>
<p>那有没有一种方案，既不需要跟<code>Controller</code>耦合，也可以将定义的 <strong>异常处理器</strong> 应用到所有控制器呢？所以注解<code>@ControllerAdvice</code>出现了，简单的说，该注解可以把异常处理器应用到所有控制器，而不是单个控制器。借助该注解，我们可以实现：在独立的某个地方，比如单独一个类，定义一套对各种异常的处理机制，然后在类的签名加上注解<code>@ControllerAdvice</code>，统一对 <code>不同阶段的</code>、<code>不同异常</code> 进行处理。这就是统一异常处理的原理。</p>
<blockquote>
<p>注意到上面对异常按阶段进行分类，大体可以分成：进入<code>Controller</code>前的异常 和 <code>Service</code> 层异常，具体可以参考下图：</p>
</blockquote>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220328135114.png" alt="image-20220328135114123"></p>
<h2 id="统一异常处理实战"><a href="#统一异常处理实战" class="headerlink" title="统一异常处理实战"></a>统一异常处理实战</h2><p>通过全局统一的异常处理将自定义的错误码以 json 的格式返回给前端。</p>
<h3 id="统一返回结果类"><a href="#统一返回结果类" class="headerlink" title="统一返回结果类"></a>统一返回结果类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KOTLIN</span><br><span class="line"></span><br><span class="line">package org.jeecg.common.api.vo;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line">import io.swagger.annotations.ApiModel;</span><br><span class="line">import io.swagger.annotations.ApiModelProperty;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.jeecg.common.constant.CommonConstant;</span><br><span class="line">import org.jeecg.common.constant.enums.ErrorCodeEnum;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description: 接口返回对象 -更新</span><br><span class="line"> * @author: luo_Jj</span><br><span class="line"> * @date: 2022/3/24 17:58</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@ApiModel(value=&quot;接口返回对象&quot;, description=&quot;接口返回对象&quot;)</span><br><span class="line">public class Result&lt;T&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 成功标志</span><br><span class="line">	 */</span><br><span class="line">	@ApiModelProperty(value = &quot;成功标志&quot;)</span><br><span class="line">	private boolean success = true;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 返回处理消息</span><br><span class="line">	 */</span><br><span class="line">	@ApiModelProperty(value = &quot;返回处理消息&quot;)</span><br><span class="line">	private String message = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 返回代码</span><br><span class="line">	 */</span><br><span class="line">	@ApiModelProperty(value = &quot;返回代码&quot;)</span><br><span class="line">	private String code = &quot;000000&quot;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 返回数据对象 data</span><br><span class="line">	 */</span><br><span class="line">	@ApiModelProperty(value = &quot;返回数据对象&quot;)</span><br><span class="line">	private T result;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 时间戳</span><br><span class="line">	 */</span><br><span class="line">	@ApiModelProperty(value = &quot;时间戳&quot;)</span><br><span class="line">	private long timestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	public Result() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Result(String code,String message) &#123;</span><br><span class="line">		this.code = code;</span><br><span class="line">		this.message = message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Result&lt;T&gt; success(String message) &#123;</span><br><span class="line">		this.message = message;</span><br><span class="line">		this.code = CommonConstant.SC_OK_200;</span><br><span class="line">		this.success = true;</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static&lt;T&gt; Result&lt;T&gt; OK() &#123;</span><br><span class="line">		Result&lt;T&gt; r = new Result&lt;T&gt;();</span><br><span class="line">		r.setSuccess(true);</span><br><span class="line">		r.setCode(CommonConstant.SC_OK_200);</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static&lt;T&gt; Result&lt;T&gt; OK(T data) &#123;</span><br><span class="line">		Result&lt;T&gt; r = new Result&lt;T&gt;();</span><br><span class="line">		r.setSuccess(true);</span><br><span class="line">		r.setCode(CommonConstant.SC_OK_200);</span><br><span class="line">		r.setResult(data);</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static&lt;T&gt; Result&lt;T&gt; OK(String msg, T data) &#123;</span><br><span class="line">		Result&lt;T&gt; r = new Result&lt;T&gt;();</span><br><span class="line">		r.setSuccess(true);</span><br><span class="line">		r.setCode(CommonConstant.SC_OK_200);</span><br><span class="line">		r.setMessage(msg);</span><br><span class="line">		r.setResult(data);</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static&lt;T&gt; Result&lt;T&gt; error(String msg, T data) &#123;</span><br><span class="line">		Result&lt;T&gt; r = new Result&lt;T&gt;();</span><br><span class="line">		r.setSuccess(false);</span><br><span class="line">		r.setCode(CommonConstant.SC_INTERNAL_SERVER_ERROR_500);</span><br><span class="line">		r.setMessage(msg);</span><br><span class="line">		r.setResult(data);</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static&lt;T&gt; Result&lt;T&gt; error(String msg) &#123;</span><br><span class="line">		return error(CommonConstant.SC_INTERNAL_SERVER_ERROR_500, msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* @description: 传递一个错误码枚举</span><br><span class="line">	* @author: luo_jj</span><br><span class="line">	* @date: 2022/3/28 14:55</span><br><span class="line">	* @param errorCodeEnum:</span><br><span class="line">	* @return: org.jeecg.common.api.vo.Result&lt;T&gt;</span><br><span class="line">	*/</span><br><span class="line">	public static&lt;T&gt; Result&lt;T&gt; error(ErrorCodeEnum errorCodeEnum) &#123;</span><br><span class="line">		return error(errorCodeEnum.getCode(), errorCodeEnum.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static&lt;T&gt; Result&lt;T&gt; error(String code, String msg) &#123;</span><br><span class="line">		Result&lt;T&gt; r = new Result&lt;T&gt;();</span><br><span class="line">		r.setCode(code);</span><br><span class="line">		r.setMessage(msg);</span><br><span class="line">		r.setSuccess(false);</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Result&lt;T&gt; error500(String message) &#123;</span><br><span class="line">		this.message = message;</span><br><span class="line">		this.code = CommonConstant.SC_INTERNAL_SERVER_ERROR_500;</span><br><span class="line">		this.success = false;</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误码枚举类"><a href="#错误码枚举类" class="headerlink" title="错误码枚举类"></a>错误码枚举类</h3><p>需要定义一个枚举类，包含所有的自定义的结果码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line"></span><br><span class="line">package org.jeecg.common.constant.enums;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description: 错误码枚举</span><br><span class="line"> * @author: luo_jj</span><br><span class="line"> * @date: 2022年03月24日 17:15</span><br><span class="line"> */</span><br><span class="line">@Getter</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public enum ResultCodeEnum &#123;</span><br><span class="line">    /*</span><br><span class="line">    * 错误产生来源分为 A/B/C</span><br><span class="line">    * A 表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付超时等问题；</span><br><span class="line">    * B 表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题；</span><br><span class="line">    * C 表示错误来源于第三方服务，比如 CDN 服务出错，消息投递超时等问题；</span><br><span class="line">    * 四位数字编号从 0001 到 9999，大类之间的步长间距预留 100</span><br><span class="line">    *</span><br><span class="line">    * 错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。</span><br><span class="line">    * 调用第三方服务出错是一级，中间件错误是二级，消息服务出错是三级。</span><br><span class="line">    * 说明：在无法更加具体确定的错误场景中，可以直接使用一级宏观错误码，分别是：A0001（用户端错误）、B0001（系统执行出错）、C0001（调用第三方服务出错）。</span><br><span class="line">    * 错误码表：http://192.168.88.211:8090/pages/viewpage.action?pageId=5473234</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    /*一切ok*/</span><br><span class="line">    SUCCESS_ERROR(&quot;000000&quot;,&quot;成功&quot;),</span><br><span class="line"></span><br><span class="line">    /*用户端错误码*/</span><br><span class="line">    CLIENT_ERROR(&quot;A0001&quot;,&quot;用户端错误&quot;),</span><br><span class="line"></span><br><span class="line">    /*服务端错误码*/</span><br><span class="line">    SYSTEM_ERROR(&quot;B0001&quot;,&quot;系统执行出错&quot;),</span><br><span class="line"></span><br><span class="line">    /*第三方服务错误码*/</span><br><span class="line">    TPA_ERROR(&quot;C0001&quot;,&quot;调用第三方服务出错&quot;);</span><br><span class="line"></span><br><span class="line">    /** 错误码 */</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line">    /** 错误描述 */</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义业务异常类"><a href="#自定义业务异常类" class="headerlink" title="自定义业务异常类"></a>自定义业务异常类</h3><p>自定义一个业务异常类，以后和业务有关的异常通通抛出这个异常类，只需将定义好的错误枚举传入即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCALA</span><br><span class="line"></span><br><span class="line">package org.jeecg.common.exception;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import org.jeecg.common.constant.enums.ResultCodeEnum;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @description: 万序自定义异常</span><br><span class="line">* @author: luo_Jj</span><br><span class="line">* @date: 2022/3/24 18:15</span><br><span class="line">*/</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class VanxSoftException extends RuntimeException &#123;</span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">	private ResultCodeEnum resultCodeEnum;</span><br><span class="line"></span><br><span class="line">	public VanxSoftException(ResultCodeEnum resultCodeEnum)&#123;</span><br><span class="line">		super(resultCodeEnum.getMessage());</span><br><span class="line">		this.resultCodeEnum = resultCodeEnum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局异常处理类"><a href="#全局异常处理类" class="headerlink" title="全局异常处理类"></a>全局异常处理类</h3><p>定义一个全局异常处理类</p>
<ol>
<li>通过 <code>@RestControllerAdvice</code> 指定该类为 <code>Controller</code> 增强类并返回 <code>json</code> 到前端</li>
<li>通过 <code>@ExceptionHandler</code> 自定义捕获的异常类型</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REASONML</span><br><span class="line"></span><br><span class="line">package org.jeecg.common.exception;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.shiro.authz.AuthorizationException;</span><br><span class="line">import org.apache.shiro.authz.UnauthorizedException;</span><br><span class="line">import org.jeecg.common.api.vo.Result;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.dao.DataIntegrityViolationException;</span><br><span class="line">import org.springframework.dao.DuplicateKeyException;</span><br><span class="line">import org.springframework.data.redis.connection.PoolException;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.web.HttpRequestMethodNotSupportedException;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line">import org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line">import org.springframework.web.multipart.MaxUploadSizeExceededException;</span><br><span class="line">import org.springframework.web.servlet.NoHandlerFoundException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异常处理器</span><br><span class="line"> *</span><br><span class="line"> * @Author scott</span><br><span class="line"> * @Date 2019</span><br><span class="line"> */</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">@Slf4j</span><br><span class="line">public class JeecgBootExceptionHandler &#123;</span><br><span class="line">    @Value(&quot;$&#123;spring.servlet.multipart.max-file-size&#125;&quot;)</span><br><span class="line">    private String maxFileSize;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理自定义异常</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(JeecgBootException.class)</span><br><span class="line">    public Result&lt;?&gt; handleJeecgBootException(JeecgBootException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理自定义异常</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(JeecgBoot401Exception.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.UNAUTHORIZED)</span><br><span class="line">    public Result&lt;?&gt; handleJeecgBoot401Exception(JeecgBoot401Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return new Result(&quot;401&quot;, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @description: 处理自定义异常-万序系统异常</span><br><span class="line">    * @author: luo_jj</span><br><span class="line">    * @date: 2022/3/25 11:33</span><br><span class="line">    * @param e:</span><br><span class="line">    * @return: org.jeecg.common.api.vo.Result&lt;?&gt;</span><br><span class="line">    */</span><br><span class="line">    @ExceptionHandler(VanxSoftException.class)</span><br><span class="line">    public Result&lt;?&gt; handleVanxSoftException(VanxSoftException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.error(e.getResultCodeEnum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(NoHandlerFoundException.class)</span><br><span class="line">    public Result&lt;?&gt; handlerNoFoundException(Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.error(&quot;404&quot;, &quot;路径不存在，请检查路径是否正确&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(DuplicateKeyException.class)</span><br><span class="line">    public Result&lt;?&gt; handleDuplicateKeyException(DuplicateKeyException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.error(&quot;数据库中已存在该记录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(&#123;UnauthorizedException.class, AuthorizationException.class&#125;)</span><br><span class="line">    public Result&lt;?&gt; handleAuthorizationException(AuthorizationException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.noauth(&quot;没有权限，请联系管理员授权&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result&lt;?&gt; handleException(Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.error(&quot;操作失败，&quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     * @Author 政辉</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)</span><br><span class="line">    public Result&lt;?&gt; handleHttpRequestMethodNotSupportedException(HttpRequestMethodNotSupportedException e) &#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line">        sb.append(&quot;不支持&quot;);</span><br><span class="line">        sb.append(e.getMethod());</span><br><span class="line">        sb.append(&quot;请求方法，&quot;);</span><br><span class="line">        sb.append(&quot;支持以下&quot;);</span><br><span class="line">        String[] methods = e.getSupportedMethods();</span><br><span class="line">        if (methods != null) &#123;</span><br><span class="line">            for (String str : methods) &#123;</span><br><span class="line">                sb.append(str);</span><br><span class="line">                sb.append(&quot;、&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(sb.toString(), e);</span><br><span class="line">        return Result.error(&quot;405&quot;, sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * spring默认上传大小100MB 超出大小捕获异常MaxUploadSizeExceededException</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(MaxUploadSizeExceededException.class)</span><br><span class="line">    public Result&lt;?&gt; handleMaxUploadSizeExceededException(MaxUploadSizeExceededException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.error(String.format(&quot;文件大小超出%s限制, 请压缩或降低文件质量! &quot;, maxFileSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(DataIntegrityViolationException.class)</span><br><span class="line">    public Result&lt;?&gt; handleDataIntegrityViolationException(DataIntegrityViolationException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.error(&quot;字段太长,超出数据库字段的长度&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(PoolException.class)</span><br><span class="line">    public Result&lt;?&gt; handlePoolException(PoolException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        return Result.error(&quot;Redis 连接异常!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="编写-TestController-测试"><a href="#编写-TestController-测试" class="headerlink" title="编写 TestController 测试"></a>编写 TestController 测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KOTLIN</span><br><span class="line"></span><br><span class="line">package org.jeecg.modules.exception.controller;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.jeecg.common.api.vo.Result;</span><br><span class="line">import org.jeecg.common.constant.enums.ResultCodeEnum;</span><br><span class="line">import org.jeecg.common.exception.VanxSoftException;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description: 全局异常处理</span><br><span class="line"> * @author: luo_jj</span><br><span class="line"> * @date: 2022年03月24日 17:45</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/exception&quot;)</span><br><span class="line">@Api(tags=&quot;全局异常处理&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class ExceptionController &#123;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;测试请求&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/test&quot;, method = RequestMethod.POST)</span><br><span class="line">    public Result&lt;JSONObject&gt; testClientError()&#123;</span><br><span class="line">        throw new VanxSoftException(ResultCodeEnum.SYSTEM_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220328151505.png" alt="image-20220328151505665"></p>
]]></content>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Dom4j 如何新增 standalone？</title>
    <url>/2022/03/16/%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/Dom4j%20%E5%A6%82%E4%BD%95%E6%96%B0%E5%A2%9E%20standalone/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作中调用一个第三方接口，需要上传 xml 文件。Java 操作 xml 文件的 api 很多，有 Dom、SAX 、JDom、Dom4j。我一般常用的是 Dom4j，但是对接此接口上传的 xml 文件需要添加 <code>standalone=&quot;no&quot;</code> 属性。查阅相关资料，发现 <code>Dom4j -1.6.1</code> 版本并没有提供相应的方法设置。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>重写 <code>XMLWriter</code> 类中的 <code>writeDeclaration</code> 方法，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line">import org.dom4j.io.OutputFormat;</span><br><span class="line">import org.dom4j.io.XMLWriter;</span><br><span class="line"></span><br><span class="line">public class StandaloneWriter extends XMLWriter &#123;</span><br><span class="line"></span><br><span class="line">    public StandaloneWriter(FileOutputStream fileOutputStream, OutputFormat format)</span><br><span class="line">    throws UnsupportedEncodingException &#123;</span><br><span class="line">        super(fileOutputStream, format);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public StandaloneWriter(FileWriter fileWriter, OutputFormat format)</span><br><span class="line">    throws UnsupportedEncodingException &#123;</span><br><span class="line">        super(fileWriter, format);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void writeDeclaration() throws IOException &#123;</span><br><span class="line">        OutputFormat format = getOutputFormat();</span><br><span class="line"></span><br><span class="line">        String encoding = format.getEncoding();</span><br><span class="line"></span><br><span class="line">        if (!format.isSuppressDeclaration()) &#123;</span><br><span class="line">            if (encoding.equals(&quot;UTF8&quot;)) &#123;</span><br><span class="line">                writer.write(&quot;&lt;?xml version=\&quot;1.0\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">                if (!format.isOmitEncoding()) &#123;</span><br><span class="line">                    writer.write(&quot; encoding=\&quot;UTF-8\&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                writer.write(&quot; standalone=\&quot;yes\&quot;&quot;);</span><br><span class="line">                writer.write(&quot;?&gt;&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                writer.write(&quot;&lt;?xml version=\&quot;1.0\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">                if (!format.isOmitEncoding()) &#123;</span><br><span class="line">                    writer.write(&quot; encoding=\&quot;&quot; + encoding + &quot;\&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                writer.write(&quot; standalone=\&quot;no\&quot;&quot;);</span><br><span class="line">                writer.write(&quot;?&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (format.isNewLineAfterDeclaration()) &#123;</span><br><span class="line">                println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用过程中，用 <code>StandaloneWriter</code> 替换掉 <code>XMLWriter</code> 即可。</p>
]]></content>
      <tags>
        <tag>Dom4j</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 缓存穿透、缓存击穿、缓存雪崩问题</title>
    <url>/2022/04/11/%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/Redis%20%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在项目中引入一个缓存系统，不得不考虑的问题就是：缓存穿透、缓存击穿和缓存雪崩问题。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<p>在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。</p>
<p>如发起为 id 为<code>-1</code>的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>接口层增加校验，如用户鉴权校验、id 基础校验（id&lt;&#x3D;0 直接拦截）</li>
<li>在数据库和缓存中都取不到的数据，可以将在缓存中存入一个空对象（<strong>key-null</strong>），设置一个短的有效时间。这样可以防止一个用户反复暴力攻击一个 id 请求</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期）</strong>，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><strong>设置热点数据永不过期</strong></li>
<li><strong>接口限流与熔断，降级</strong>。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要做好降级准备，当接口中某些服务不可用时，进行熔断，失败快速返回机制</li>
<li><strong>布隆过滤器</strong>。bloomfilter 就类似于一个 hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个 key 是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于 hash 算法和容器大小，</li>
<li><strong>加互斥锁</strong></li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
</ol>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>分析解析项目上内存泄漏、频繁GC、cpu飙升问题</title>
    <url>/2022/07/01/%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/%E5%88%86%E6%9E%90%E8%A7%A3%E6%9E%90%E9%A1%B9%E7%9B%AE%E4%B8%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E3%80%81%E9%A2%91%E7%B9%81GC%E3%80%81cpu%E9%A3%99%E5%8D%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们的 Java 服务都是封装在 Docker 容器里运行的，今天早上到公司发现有个服务内存跑满，<code>CPU 100%~500%</code> 之间跳动，第一时间想到的是 dump 快照到本地进行分析。</p>
<blockquote>
<p>这是本人首次在容器内分析线上问题，遇到几个坑，特此记录下来！</p>
</blockquote>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>通过容器监控工具发现 A 容器内存和 CPU 占用都不正常：</p>
<blockquote>
<p><a href="https://www.portainer.io/">Portainer | Docker 图形化管理工具</a></p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105726.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105726.png" alt="image-20221102113101648"></a></p>
<h3 id="安装-Arthas"><a href="#安装-Arthas" class="headerlink" title="安装 Arthas"></a>安装 Arthas</h3><p>本来选择使用 jvm 自带的分析工具进行内存分析，但是我们所有的 Java 服务镜像都是基于 <code>anapsix/alpine-java:8_server-jre_unlimited</code> 构建的，此镜像默认是没有 jvm 分析工具，故选择阿里的 Arthas 线上监控诊断产品进行分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 下载 arthas-boot 启动包</span><br><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line"># 直接启动（使用和目标进程一致的用户启动，否则可能 attach 失败）</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105737.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105737.png" alt="image-20221102155819797"></a></p>
<h4 id="坑-1：提示无法找到可用的-Java-进程"><a href="#坑-1：提示无法找到可用的-Java-进程" class="headerlink" title="坑 1：提示无法找到可用的 Java 进程"></a>坑 1：提示无法找到可用的 Java 进程</h4><p>主要是因为基础镜像是 jre，arthas 无法 attach 目标进程，只需要安装一个 openjdk8 即可解决问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 安装 openjdk</span><br><span class="line">apk add openjdk8</span><br><span class="line"># 再次尝试 attach 目标进程（注意：要进入到 openjdk8 的安装 bin 目录中，默认是 /usr/lib/jvm/java-8-openjdk 下）</span><br><span class="line">/usr/lib/jvm/java-8-openjdk/bin/java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105741.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105741.png" alt="image-20221102160738482"></a></p>
<h4 id="坑-2：提示无法获取-LinuxThreads-管理器线程"><a href="#坑-2：提示无法获取-LinuxThreads-管理器线程" class="headerlink" title="坑 2：提示无法获取 LinuxThreads 管理器线程"></a>坑 2：提示无法获取 LinuxThreads 管理器线程</h4><p>arthas 无法获取 PID 1 的线程，原因及解决方案如下：</p>
<blockquote>
<p><strong>为什么 Docker 中运行的 Java 进程 PID 为 1？</strong></p>
<p>在 Linux 上有了容器的概念之后，一旦容器建立了自己的 Pid Namespace（进程命名空间），这个 Namespace 里的进程号也是从 1 开始标记的。所以，容器的 init 进程也被称为 1 号进程。你只需要记住：1 号进程是第一个用户态的进程，由它直接或者间接创建了 Namespace 中的其他进程。</p>
<p>每个 Docker 容器都是一个 PID 命名空间，这意味着容器中的进程与主机上的其他进程是隔离的。PID 命名空间是一棵树，从 PID 1 开始，通常称为 init。</p>
<p><strong>注意：当你运行一个 Docker 容器时，镜像的 ENTRYPOINT 就是你的根进程，即 PID 1（如果你没有 ENTRYPOINT，那么 CMD 就会作为根进程）。</strong></p>
</blockquote>
<p>可以看到，启动 arthas 之后，提示没有找到可用的 java 进程 PID，这是因为容器内只有 Java 一个进程，通过 ps 查看 PID 为 1，而 PID 1 是特殊的进程号，不会处理任何信号。所以我们要让 Java 进程的 PID 不为 1。可以使用 <code>tini</code> 占用 PID 1，我们在容器中启动 init 系统有很多种，这里推荐使用 <code>tini</code>，它是专用于容器的轻量级 init 系统，用起来也很简单，只需要在原来的 Dockerfile 中添加一段 <code>ENTRYPOINT</code>，用于启动 <code>tini</code> 进程即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">FROM anapsix/alpine-java:8_server-jre_unlimited</span><br><span class="line">...</span><br><span class="line">RUN apk add --no-cache tini</span><br><span class="line">ENTRYPOINT [&quot;/sbin/tini&quot;, &quot;--&quot;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>添加之后重新启动容器，可以发现 PID 1 已经是 tini 进程了，而 Java 进程变成了 PID 7！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105746.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105746.png" alt="image-20221102153345994"></a></p>
<p>再重复之前的操作，使用 arthas 进行 attach 目标进程，成功进入到 arthas 的命令行：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105750.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105750.png" alt="image-20221102161204036"></a></p>
<h2 id="使用-Arthas-诊断问题"><a href="#使用-Arthas-诊断问题" class="headerlink" title="使用 Arthas 诊断问题"></a>使用 Arthas 诊断问题</h2><h3 id="诊断内存问题"><a href="#诊断内存问题" class="headerlink" title="诊断内存问题"></a>诊断内存问题</h3><p>使用 arthas 的 <code>dashboard</code> 命令查看当前系统的实时数据（默认 5s 刷新一次，可以通过 -n 参数设置）</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105802.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="image-20221102163552087"></a></p>
<blockquote>
<p>此处截图只是正常情况下的，今天出现问题时<strong>老年代内存占比</strong>达到 <strong>百分之 90</strong> 以上，<strong>Full GC</strong> 次数也多得恐怖，说明有大量的 GC 线程在运行，这么多次 GC 的情况下，那些垃圾还没被清理掉，说明系统已经出现了内存泄漏，接下来的工作就是找到那些还未被清理的垃圾究竟是什么对象，然后解决掉！</p>
</blockquote>
<p>要分析堆内存中有那些对象，需要使用到 arthas 的一个工具（<code>heapdump</code>），这个工具的作用类似于 jdk 的 jmap，都是转储堆内存快照，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># dump 堆内存到指定文件中，--live 表示只 dump live 对象</span><br><span class="line">[arthas@6]$ heapdump --live /opt/dump.hprof</span><br><span class="line"># 通过 docker cp 命令将容器内的 hprof 文件复制到宿主机，再从服务器上传输到本地机器上</span><br><span class="line">docker cp 容器ID:/opt/dump.hprof ./</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105807.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105807.png" alt="image-20221102164606224"></a></p>
<p>导出的 dump.hprof 是 Java 的内存快照文件（Heap Profile）,咱们可以借助一些工具分析内存快照，比如：<code>JProfiler</code>、JDK 自带的 <code>jhat</code> 和 <code>jvisualVM</code>。我这里选择使用 <code>JProfiler</code>。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103133248.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103133248.png" alt="image-20221102165919594"></a></p>
<p>由此结果可以看到，<code>Date</code> 对象一直无法回收，个数达到了 <code>2亿</code> 多，代码里可能出现了死循环，不停地创建 <code>Date</code> 对象，只增不减，导致内存泄漏！</p>
<h3 id="诊断-CPU-问题"><a href="#诊断-CPU-问题" class="headerlink" title="诊断 CPU 问题"></a>诊断 CPU 问题</h3><p>通过分析内存快照，猜测可能是死循环导致的内存泄漏，死循环导致 CPU 居高不下，通过 Arthas 分析占用 CPU 高的线程，定位到具体代码片段，结合上面内存分析结果针对性地解决问题。</p>
<p>通过 arthas 的 <code>thread</code> 命令，查看当前系统的线程（默认查看第一页，按 CPU 增量时间降序排序）</p>
<blockquote>
<p><a href="https://arthas.aliyun.com/doc/thread.html">thread | arthas (阿尔萨斯-线上监控诊断)</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 查看当前系统的线程信息</span><br><span class="line">[arthas@6]$ thread</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处截图是正常情况下的线程信息</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105811.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105811.png" alt="image-20221103104908660"></a></p>
<p>找出 CPU 占用前列的线程 ID，通过 <code>thread id</code> 命令, 显示指定线程的运行堆栈，排查堆栈上方法的代码，解决问题！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[arthas@6]$ thread 64</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105814.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103105814.png" alt="image-20221103105238315"></a></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文记录了真实工作中的一次线上问题诊断过程，代码中因 while 循坏条件设置不合理导致死循环，不停地创建 <code>Date</code> 对象，导致内存泄漏和 CPU 飙升…</p>
<p>借助 Arthas 这款线上问题诊断神器，能够快速地定位到问题，在容器中可能会踩几个坑，好在最终还是解决了问题！</p>
]]></content>
      <tags>
        <tag>BUG处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 操作 Excel 之 POI 与 EasyExcel</title>
    <url>/2022/05/02/%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/Java%20%E6%93%8D%E4%BD%9C%20Excel%20%E4%B9%8B%20POI%20%E4%B8%8E%20EasyExcel/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在工作中，使用 excel 表格处理数据是很常见的操作，作为一个 Java 开发工程师，学会使用 Java 来操作 excel 表格是必备的技能之一。</p>
<p>本文就通过市面上常用的两种方式来实现 Java 对 excel 表格的操作：</p>
<ul>
<li>Apache POI</li>
<li>Alibaba EasyExcel</li>
</ul>
<h2 id="一、Apache-POI"><a href="#一、Apache-POI" class="headerlink" title="一、Apache POI"></a>一、Apache POI</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Apache POI 官网： <a href="https://poi.apache.org/">https://poi.apache.org/</a></p>
<p>POI 是目前比较流行的 Java 处理 excel 框架，但是其缺点是 <strong>数据量大容易造成 OOM 异常</strong></p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li>HSSF － 提供读写[Microsoft Excel](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Excel)格式档案的功能（03 版本 excel）</li>
<li>XSSF － 提供读写<a href="https://baike.baidu.com/item/Microsoft">Microsoft</a> Excel <a href="https://baike.baidu.com/item/OOXML">OOXML</a>格式档案的功能（07 版本 excel）</li>
<li>HWPF － 提供读写[Microsoft Word](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Word)格式档案的功能</li>
<li>HSLF － 提供读写[Microsoft PowerPoint](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> PowerPoint)格式档案的功能</li>
<li>HDGF － 提供读写[Microsoft Visio](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Visio)格式档案的功能</li>
</ul>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>创建 一个空项目，在空项目中新建一个 module 模块：一个普通的 maven 项目即可</p>
<h4 id="1、导入-pom-依赖"><a href="#1、导入-pom-依赖" class="headerlink" title="1、导入 pom 依赖"></a>1、导入 pom 依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--xLs(03)--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;poi&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.1.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--xLsx(07)--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.1.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--日期格式化工具--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.10.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--test--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2、POI-写入-Excel"><a href="#2、POI-写入-Excel" class="headerlink" title="2、POI 写入 Excel"></a>2、POI 写入 Excel</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.lxki;</span><br><span class="line"></span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line">import org.apache.poi.ss.usermodel.Cell;</span><br><span class="line">import org.apache.poi.ss.usermodel.Row;</span><br><span class="line">import org.apache.poi.ss.usermodel.Sheet;</span><br><span class="line">import org.apache.poi.ss.usermodel.Workbook;</span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFWorkbook;</span><br><span class="line">import org.joda.time.DateTime;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * POI写入Excel测试</span><br><span class="line"> * @author IRVING QQ:2362766003</span><br><span class="line"> * @create 2021-06-22 14:20</span><br><span class="line"> */</span><br><span class="line">public class WriteExcelTest &#123;</span><br><span class="line"></span><br><span class="line">    // 生成文件路径</span><br><span class="line">    private static final String PATH = &quot;E:\\workspace\\IdeaProjects\\POI-EasyExcel\\lxki-poi\\&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 写入03版本的excel</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testWrite03() throws Exception &#123;</span><br><span class="line">        // 创建工作簿</span><br><span class="line">        Workbook workbook = new HSSFWorkbook();</span><br><span class="line"></span><br><span class="line">        // 创建工作表</span><br><span class="line">        Sheet sheet = workbook.createSheet(&quot;员工信息表03&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建第一行</span><br><span class="line">        Row row1 = sheet.createRow(0);</span><br><span class="line">        // 创建单元格</span><br><span class="line">        Cell cell11 = row1.createCell(0);</span><br><span class="line">        cell11.setCellValue(&quot;姓名&quot;);</span><br><span class="line">        Cell cell12 = row1.createCell(1);</span><br><span class="line">        cell12.setCellValue(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建第二行</span><br><span class="line">        Row row2 = sheet.createRow(1);</span><br><span class="line">        // 创建单元格</span><br><span class="line">        Cell cell21 = row2.createCell(0);</span><br><span class="line">        cell21.setCellValue(&quot;出生日期&quot;);</span><br><span class="line">        Cell cell22 = row2.createCell(1);</span><br><span class="line">        cell22.setCellValue(new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line"></span><br><span class="line">        // 生成表 io流 -- 03版本使用xls后缀名</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;员工信息表03.xls&quot;);</span><br><span class="line">        workbook.write(fileOutputStream);</span><br><span class="line"></span><br><span class="line">        // 关闭流</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        System.out.println(&quot;员工信息表03.xls ==&gt; 输出完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 写入07版本的excel</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testWrite07() throws Exception &#123;</span><br><span class="line">        // 创建工作簿</span><br><span class="line">        Workbook workbook = new XSSFWorkbook();</span><br><span class="line"></span><br><span class="line">        // 创建工作表</span><br><span class="line">        Sheet sheet = workbook.createSheet(&quot;员工信息表07&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建第一行</span><br><span class="line">        Row row1 = sheet.createRow(0);</span><br><span class="line">        // 创建单元格</span><br><span class="line">        Cell cell11 = row1.createCell(0);</span><br><span class="line">        cell11.setCellValue(&quot;姓名&quot;);</span><br><span class="line">        Cell cell12 = row1.createCell(1);</span><br><span class="line">        cell12.setCellValue(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建第二行</span><br><span class="line">        Row row2 = sheet.createRow(1);</span><br><span class="line">        // 创建单元格</span><br><span class="line">        Cell cell21 = row2.createCell(0);</span><br><span class="line">        cell21.setCellValue(&quot;出生日期&quot;);</span><br><span class="line">        Cell cell22 = row2.createCell(1);</span><br><span class="line">        cell22.setCellValue(new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line"></span><br><span class="line">        // 生成表 io流 -- 07版本使用xlsx后缀名</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;员工信息表07.xlsx&quot;);</span><br><span class="line">        workbook.write(fileOutputStream);</span><br><span class="line"></span><br><span class="line">        // 关闭流</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        System.out.println(&quot;员工信息表07.xls ==&gt; 输出完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、POI-读取-Excel"><a href="#3、POI-读取-Excel" class="headerlink" title="3、POI 读取 Excel"></a>3、POI 读取 Excel</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.lxki;</span><br><span class="line"></span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line">import org.apache.poi.ss.usermodel.Cell;</span><br><span class="line">import org.apache.poi.ss.usermodel.Row;</span><br><span class="line">import org.apache.poi.ss.usermodel.Sheet;</span><br><span class="line">import org.apache.poi.ss.usermodel.Workbook;</span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFWorkbook;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * POI读取Excel测试</span><br><span class="line"> * @author IRVING QQ:2362766003</span><br><span class="line"> * @create 2021-06-22 15:49</span><br><span class="line"> */</span><br><span class="line">public class ReadExcelTest &#123;</span><br><span class="line"></span><br><span class="line">    // 生成文件路径</span><br><span class="line">    private static final String PATH = &quot;E:\\workspace\\IdeaProjects\\POI-EasyExcel\\lxki-poi\\&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取03版本的excel</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testRead03() throws Exception&#123;</span><br><span class="line">        // 通过文件路径得到文件输入流</span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(PATH + &quot;员工信息表03.xls&quot;);</span><br><span class="line"></span><br><span class="line">        // 通过文件输入流拿到工作簿</span><br><span class="line">        Workbook workbook = new HSSFWorkbook(fileInputStream);</span><br><span class="line"></span><br><span class="line">        // 通过工作簿获取工作表</span><br><span class="line">        Sheet sheet = workbook.getSheetAt(0);</span><br><span class="line">        // 拿到行数，通过循环读取数据</span><br><span class="line">        int rowCount = sheet.getPhysicalNumberOfRows();</span><br><span class="line">        for (int rowNum = 0; rowNum &lt; rowCount; rowNum++) &#123;</span><br><span class="line">            // 通过工作表读取行，并取到对应的列数</span><br><span class="line">            Row row = sheet.getRow(rowNum);</span><br><span class="line">            int cellCount = row.getPhysicalNumberOfCells();</span><br><span class="line">            // 通过行读取单元格</span><br><span class="line">            for (int cellNum = 0; cellNum &lt; cellCount; cellNum++) &#123;</span><br><span class="line">                Cell cell = row.getCell(cellNum);</span><br><span class="line">                // 读取 excel 表格中的数据时要注意类型</span><br><span class="line">                System.out.print(cell.getStringCellValue()+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取07版本的excel</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testRead07() throws Exception&#123;</span><br><span class="line">        // 通过文件路径得到文件输入流</span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(PATH + &quot;员工信息表07.xlsx&quot;);</span><br><span class="line"></span><br><span class="line">        // 通过文件输入流拿到工作簿</span><br><span class="line">        Workbook workbook = new XSSFWorkbook(fileInputStream);</span><br><span class="line"></span><br><span class="line">        // 通过工作簿获取工作表</span><br><span class="line">        Sheet sheet = workbook.getSheetAt(0);</span><br><span class="line">        // 拿到行数，通过循环读取数据</span><br><span class="line">        int rowCount = sheet.getPhysicalNumberOfRows();</span><br><span class="line">        for (int rowNum = 0; rowNum &lt; rowCount; rowNum++) &#123;</span><br><span class="line">            // 通过工作表读取行，并取到对应的列数</span><br><span class="line">            Row row = sheet.getRow(rowNum);</span><br><span class="line">            int cellCount = row.getPhysicalNumberOfCells();</span><br><span class="line">            // 通过行读取单元格</span><br><span class="line">            for (int cellNum = 0; cellNum &lt; cellCount; cellNum++) &#123;</span><br><span class="line">                Cell cell = row.getCell(cellNum);</span><br><span class="line">                // 读取 excel 表格中的数据时要注意类型</span><br><span class="line">                System.out.print(cell.getStringCellValue()+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li><pre><code>03
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
07
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">版本的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
excel
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">表格对应的 POI 操作 API 是不同的（</span><br><span class="line"></span><br></pre></td></tr></table></figure>
HSSF
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">与</span><br><span class="line"></span><br></pre></td></tr></table></figure>
XSSF
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ）</span><br><span class="line"></span><br><span class="line">  - `03` 版本最多支持 `65536` 行数据，而 `07` 则没有限制</span><br><span class="line">  - `HSSF` 操作响应速度快于 `XSSF`， `XSSF`可以使用 `SXSSF` 替换来提升响应数据</span><br><span class="line"></span><br><span class="line">- ==读取 `excel` 表格中的数据时要注意判断不同的数据类型，使用对应的读取方法==</span><br><span class="line"></span><br><span class="line">最终的项目目录结构：</span><br><span class="line"></span><br><span class="line">[![image-20210622175133621](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210622175140.png)</span><br><span class="line"></span><br><span class="line">## 二、EasyExcel</span><br><span class="line"></span><br><span class="line">### 简介</span><br><span class="line"></span><br><span class="line">EasyExcel 官网地址：https://github.com/alibaba/easyexcel</span><br><span class="line"></span><br><span class="line">EasyExcel 是 Alibaba 开源的一个 excel 处理框架，特点是 **使用简单、节约内存**。</span><br><span class="line"></span><br><span class="line">### 快速开始</span><br><span class="line"></span><br><span class="line">在空项目中新建一个新的 module 模块，类型为普通的 maven 项目</span><br><span class="line"></span><br><span class="line">#### 1、导入 pom 依赖</span><br><span class="line"></span><br></pre></td></tr></table></figure>
XML
</code></pre>
</li>
</ul>
<dependencies>
    <!-- 导入easyexcel依赖 -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>easyexcel</artifactId>
        <version>2.2.10</version>
    </dependency>
    <!-- lombok依赖 -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.16</version>
    </dependency>
    <!-- junit单元测试 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>RELEASE</version>
        <scope>compile</scope>
    </dependency>
    <!-- json工具 -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
        <version>1.2.72</version>
    </dependency>
</dependencies>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 2、数据实体对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA

<p>package com.lxki;</p>
<p>import com.alibaba.excel.annotation.ExcelIgnore;<br>import com.alibaba.excel.annotation.ExcelProperty;<br>import lombok.Data;</p>
<p>import java.util.Date;</p>
<p>@Data<br>public class DemoData {<br>    @ExcelProperty(“字符串标题”)<br>    private String string;<br>    @ExcelProperty(“日期标题”)<br>    private Date date;<br>    @ExcelProperty(“数字标题”)<br>    private Double doubleData;<br>    &#x2F;**<br>     * 忽略这个字段<br>     *&#x2F;<br>    @ExcelIgnore<br>    private String ignore;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3、EasyExcel 写入 Excel</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>package com.lxki;</p>
<p>import com.alibaba.excel.EasyExcel;<br>import org.junit.jupiter.api.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.Date;<br>import java.util.List;</p>
<p>&#x2F;**</p>
<ul>
<li><p>@author IRVING QQ:2362766003</p>
</li>
<li><p>@create 2021-06-22 16:41<br> *&#x2F;<br>public class EasyExcelWrite {</p>
<p> &#x2F;&#x2F; 生成文件路径<br> private static final String PATH &#x3D; “E:\workspace\IdeaProjects\POI-EasyExcel\lxki-easyexcel\“;</p>
<p> &#x2F;**</p>
<ul>
<li>生成示例数据</li>
<li>@return 示例数据<br>  *&#x2F;<br> private List<DemoData> data() {<br> List<DemoData> list &#x3D; new ArrayList<DemoData>();<br> for (int i &#x3D; 0; i &lt; 10; i++) {<br> DemoData data &#x3D; new DemoData();<br> data.setString(“字符串” + i);<br> data.setDate(new Date());<br> data.setDoubleData(0.56);<br> list.add(data);<br> }<br> return list;<br> }</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>最简单的写</li>
<li><p>1. 创建excel对应的实体对象 参照{@link DemoData}</li>
<li><p>2. 直接写即可
  */
 @Test
 public void simpleWrite() {

 String fileName &#x3D; PATH + “easyexcel07.xlsx”;<br> &#x2F;&#x2F; 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭<br> &#x2F;&#x2F; 如果这里想使用 03版本 则 传入excelType参数即可<br> EasyExcel.write(fileName, DemoData.class).sheet(“模板”).doWrite(data());</li>
</ul>
<p> }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 4、EasyExcel 读取 Excel</span><br><span class="line"></span><br><span class="line">数据持久层：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA<br>package com.lxki;</p>
<p>import java.util.List;</p>
<p>&#x2F;**</p>
<ul>
<li>假设这个是你的DAO存储。当然还要这个类让spring管理，当然你不用需要存储，也不需要这个类。<br> **&#x2F;<br>public class DemoDAO {<br> public void save(List<DemoData> list) {<br> &#x2F;&#x2F; 如果是mybatis,尽量别直接调用多次insert,自己写一个mapper里面新增一个方法batchInsert,所有数据一次性插入<br> }<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">读取监听器：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA</li>
</ul>
<p>package com.lxki;</p>
<p>import com.alibaba.excel.context.AnalysisContext;<br>import com.alibaba.excel.event.AnalysisEventListener;<br>import com.alibaba.fastjson.JSON;<br>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>&#x2F;&#x2F; 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去<br>public class DemoDataListener extends AnalysisEventListener<DemoData> {<br>    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(DemoDataListener.class);<br>    &#x2F;**<br>     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收<br>     <em>&#x2F;<br>    private static final int BATCH_COUNT &#x3D; 5;<br>    List<DemoData> list &#x3D; new ArrayList<DemoData>();<br>    &#x2F;</em>*<br>     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。<br>     <em>&#x2F;<br>    private DemoDAO demoDAO;<br>    public DemoDataListener() {<br>        &#x2F;&#x2F; 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数<br>        demoDAO &#x3D; new DemoDAO();<br>    }<br>    public DemoDataListener(DemoDAO demoDAO) {<br>        this.demoDAO &#x3D; demoDAO;<br>    }<br>    &#x2F;</em>*<br>     * 这个每一条数据解析都会来调用<br>     *<br>     * @param data<br>     *            one row value. Is is same as {@link AnalysisContext#readRowHolder()}<br>     * @param context<br>     <em>&#x2F;<br>    @Override<br>    public void invoke(DemoData data, AnalysisContext context) {<br>        LOGGER.info(“解析到一条数据:{}”, JSON.toJSONString(data));<br>        System.out.println(JSON.toJSONString(data));<br>        list.add(data);<br>        &#x2F;&#x2F; 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM<br>        if (list.size() &gt;&#x3D; BATCH_COUNT) {<br>            saveData();<br>            &#x2F;&#x2F; 存储完成清理 list<br>            list.clear();<br>        }<br>    }<br>    &#x2F;</em>*<br>     * 所有数据解析完成了 都会来调用<br>     *<br>     * @param context<br>     <em>&#x2F;<br>    @Override<br>    public void doAfterAllAnalysed(AnalysisContext context) {<br>        &#x2F;&#x2F; 这里也要保存数据，确保最后遗留的数据也存储到数据库<br>        saveData();<br>        LOGGER.info(“所有数据解析完成！”);<br>    }<br>    &#x2F;</em>*<br>     * 加上存储数据库<br>     *&#x2F;<br>    private void saveData() {<br>        LOGGER.info(“{}条数据，开始存储数据库！”, list.size());<br>        demoDAO.save(list);<br>        LOGGER.info(“存储数据库成功！”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">读取测试：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>package com.lxki;</p>
<p>import com.alibaba.excel.EasyExcel;<br>import com.alibaba.excel.ExcelReader;<br>import com.alibaba.excel.read.metadata.ReadSheet;<br>import org.junit.jupiter.api.Test;</p>
<p>import java.io.File;</p>
<p>&#x2F;**</p>
<ul>
<li><p>@author IRVING QQ:2362766003</p>
</li>
<li><p>@create 2021-06-22 16:57<br> *&#x2F;<br>public class EasyExcelRead {</p>
<p> &#x2F;&#x2F; 生成文件路径<br> private static final String PATH &#x3D; “E:\workspace\IdeaProjects\POI-EasyExcel\lxki-easyexcel\“;</p>
<p> &#x2F;**</p>
<ul>
<li>最简单的读</li>
<li><p>1. 创建excel对应的实体对象 参照{@link DemoData}</li>
<li><p>2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照{@link DemoDataListener}</li>
<li><p>3. 直接读即可
  */
 @Test
 public void simpleRead() {
 // 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去
 String fileName = PATH + "easyexcel07.xlsx";
 // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
 EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet().doRead();
 }</li>
</ul>
</li>
</ul>
<p>}</p>
<pre><code>
#### 注意：

- 如果需要操作 `03` 版本的 `excel`，需要在读写操作时传入 `excelType` 参数

最终的项目结构：

[![image-20210622175227995](https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210622175228.png)](https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210622175228.png)
</code></pre>
]]></content>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 的概述和使用</title>
    <url>/2022/01/02/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/ElasticSearch%20%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="ElasticSearch-概述"><a href="#ElasticSearch-概述" class="headerlink" title="ElasticSearch 概述"></a>ElasticSearch 概述</h2><p>Elaticsearch，简称为 es， es 是一个开源的<strong>高扩展</strong>的<strong>分布式全文检索引擎</strong>，它可以近乎<strong>实时的存储、检索数据</strong>；本身扩展性很好，可以扩展到上百台服务器，处理 PB 级别（大数据时代）的数据。es 也使用 Java 开发并使用 Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<strong>RESTful API</strong>来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。</p>
<p>据国际权威的数据库产品评测机构 DB Engines 的统计，在 2016 年 1 月，ElasticSearch 已超过 Solr 等，<strong>成为排名第一的搜索引擎类应用。</strong></p>
<h2 id="ES-和-solr-的差别"><a href="#ES-和-solr-的差别" class="headerlink" title="ES 和 solr 的差别"></a>ES 和 solr 的差别</h2><h3 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h3><p>Elasticsearch 是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。</p>
<p>它用于<strong>全文搜索、结构化搜索、分析</strong>以及将这三者混合使用：</p>
<p>维基百科使用 Elasticsearch 提供全文搜索并高亮关键字，以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。</p>
<p>英国卫报使用 Elasticsearch 结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。</p>
<p>StackOverflow 结合全文搜索与地理位置查询，以及 more-like-this 功能来找到相关的问题和答案。</p>
<p>Github 使用 Elasticsearch 检索 1300 亿行的代码。</p>
<p>但是 Elasticsearch 不仅用于大型企业，它还让像 DataDog 以及 Klout 这样的创业公司将最初的想法变成可扩展的解决方案。</p>
<p>Elasticsearch 可以在你的笔记本上运行，也可以在数以百计的服务器上处理 PB 级别的数据 。</p>
<p>Elasticsearch 是一个基于 Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene 可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p>
<p>但是，Lucene 只是一个库。想要使用它，你必须使用 Java 来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene 非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p>
<p>Elasticsearch 也使用 Java 开发并使用 Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<strong>RESTful API</strong>来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。</p>
<h3 id="Solr-简介"><a href="#Solr-简介" class="headerlink" title="Solr 简介"></a>Solr 简介</h3><p>Solr 是 Apache 下的一个顶级开源项目，采用 Java 开发，它是基于 Lucene 的全文搜索服务器。Solr 提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化</p>
<p>Solr 可以独立运行，运行在 Jetty、Tomcat 等这些 Servlet 容器中，Solr 索引的实现方法很简单，<strong>用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr 根据 xml 文档添加、删除、更新索引</strong>。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回 Xml、json 等格式的查询结果进行解析，组织页面布局。Solr 不提供构建 UI 的功能，Solr 提供了一个管理界面，通过管理界面可以查询 Solr 的配置和运行情况。</p>
<p>solr 是基于 lucene 开发企业级搜索服务器，实际上就是封装了 lucene。</p>
<p>Solr 是一个独立的企业级搜索应用服务器，它对外提供类似于&#x3D;&#x3D;Web-service 的 API 接口&#x3D;&#x3D;。用户可以通过 http 请求，向搜索引擎服务器提交一定格式的文件，生成索引；也可以通过提出查找请求，并得到返回结果。</p>
<h3 id="Lucene-简介"><a href="#Lucene-简介" class="headerlink" title="Lucene 简介"></a>Lucene 简介</h3><p>Lucene 是 apache 软件基金会 4 jakarta 项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene 的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene 是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。<strong>在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库</strong>。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。</p>
<p>Lucene 是一个全文检索引擎的架构。那什么是全文搜索引擎？</p>
<p>全文搜索引擎是名副其实的搜索引擎，国外具代表性的有 Google、Fast&#x2F;AllTheWeb、AltaVista、Inktomi、Teoma、WiseNut 等，国内著名的有百度（Baidu）。它们都是通过从互联网上提取的各个网站的信息（以网页文字为主）而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的排列顺序将结果返回给用户，因此他们是真正的搜索引擎。</p>
<p>从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序（Indexer），俗称“蜘蛛”（Spider）程序或“机器人”（Robot）程序，并自建网页数据库，搜索结果直接从自身的数据库中调用，如上面提到的 7 家引擎；另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如 Lycos 引擎。</p>
<h3 id="Elasticsearch-和-Solr-比较"><a href="#Elasticsearch-和-Solr-比较" class="headerlink" title="Elasticsearch 和 Solr 比较"></a>Elasticsearch 和 Solr 比较</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503223554.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503223554.png" alt="image-20210503223554497"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503223607.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503223607.png" alt="image-20210503223607286"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503223616.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503223616.png" alt="image-20210503223616904"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503223627.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503223627.png" alt="image-20210503223627835"></a></p>
<h3 id="ElasticSearch-vs-Solr-总结"><a href="#ElasticSearch-vs-Solr-总结" class="headerlink" title="ElasticSearch vs Solr 总结"></a>ElasticSearch vs Solr 总结</h3><ol>
<li>es 基本是开箱即用（解压就可以用 ! ），非常简单。Solr 安装略微复杂一丢丢！</li>
<li>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。</li>
<li>Solr 支持更多格式的数据，比如 JSON、XML、CSV，而 Elasticsearch 仅支持 json 文件格式。</li>
<li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要 kibana 友好支撑~!</li>
<li>Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用；<ul>
<li>ES 建立索引快（即查询慢），<strong>即实时性查询快</strong>，用于 facebook 新浪等搜索。</li>
<li>Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用</li>
</ul>
</li>
<li>Solr 比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而 Elasticsearch 相对开发维护者较少，更新太快，学习使用成本较高。（趋势！）</li>
</ol>
<h2 id="ElasticSearch-安装"><a href="#ElasticSearch-安装" class="headerlink" title="ElasticSearch 安装"></a>ElasticSearch 安装</h2><p>声明：JDK1.8 ，最低要求！ ElasticSearch 客户端，界面工具！<br>Java 开发，ElasticSearch 的版本和我们之后对应的 Java 的核心 jar 包！ 版本对应！JDK 环境是正常！</p>
<blockquote>
<p>下载</p>
</blockquote>
<p>官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a></p>
<p>下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<blockquote>
<p>window 下安装！</p>
</blockquote>
<h3 id="解压就可以使用了！"><a href="#解压就可以使用了！" class="headerlink" title="解压就可以使用了！"></a>解压就可以使用了！</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503224753.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503224753.png" alt="image-20210503224753729"></a></p>
<h3 id="熟悉目录！"><a href="#熟悉目录！" class="headerlink" title="熟悉目录！"></a>熟悉目录！</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">bin 启动文件</span><br><span class="line">config 配置文件</span><br><span class="line">    log4j2 日志配置文件</span><br><span class="line">    jvm.options java 虚拟机相关的配置</span><br><span class="line">    elasticsearch.yml  elasticsearch 的配置文件！ 默认 9200 端口！ 跨域！</span><br><span class="line">lib   相关jar包</span><br><span class="line">logs   日志！</span><br><span class="line">modules 功能模块</span><br><span class="line">plugins 插件！</span><br></pre></td></tr></table></figure>

<h3 id="启动，访问-9200"><a href="#启动，访问-9200" class="headerlink" title="启动，访问 9200"></a>启动，访问 9200</h3><p>运行<code>bin/elasticsearch.bat</code>，启动！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503225150.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503225150.png" alt="image-20210503225150680"></a></p>
<h3 id="访问测试！"><a href="#访问测试！" class="headerlink" title="访问测试！"></a>访问测试！</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503225236.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503225236.png" alt="image-20210503225235923"></a></p>
<blockquote>
<p>安装可视化界面插件 es head 的插件</p>
</blockquote>
<p>需要 node.js 环境</p>
<ol>
<li><p>下载地址：<a href="https://links.jianshu.com/go?to=https://github.com/mobz/elasticsearch-head/">https://github.com/mobz/elasticsearch-head/</a></p>
</li>
<li><p>启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接测试发现，存在跨域问题：配置 es</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 es 服务器，然后再次连接</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503230107.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503230107.png" alt="image-20210503230107069"></a></p>
</li>
</ol>
<p>初学，就把 es 当做一个数据库！ （可以建立索引（库），文档（库中的数据！））</p>
<p><strong>这个 head 我们就把它当做数据展示工具！我们后面所有的查询，去 Kibana 进行！</strong></p>
<blockquote>
<p>了解 ELK</p>
</blockquote>
<p>ELK 是 Elasticsearch、Logstash、Kibana 三大开源框架首字母大写简称。市面上也被成为 ElasticStack。其中 Elasticsearch 是一个基于 Lucene、分布式、通过 Restful 方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用 Elasticsearch 作为底层支持框架，可见 Elasticsearch 提供的搜索能力确实强大,市面上很多时候我们简称 Elasticsearch 为 es。Logstash 是 ELK 的中央数据流引擎，用于从不同目标（文件&#x2F;数据存储&#x2F;MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件&#x2F;MQ&#x2F;redis&#x2F;elasticsearch&#x2F;kafka 等）。Kibana 可以将 elasticsearch 的数据通过友好<br>的页面展示出来，提供实时分析的功能。</p>
<p>市面上很多开发只要提到 ELK 能够一致说出它是一个日志分析架构技术栈总称，但实际上 ELK 不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503230537.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503230537.webp" alt="img"></a></p>
<blockquote>
<p>安装 Kibana</p>
</blockquote>
<p>Kibana 是一个针对 Elasticsearch 的开源分析及可视化平台，用来搜索、查看交互存储在 Elasticsearch 索引中的数据。使用 Kibana，可以通过各种图表进行高级数据分析及展示。Kibana 让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示 Elasticsearch 查询动态。设置 Kibana 非常简单。无需编码或者额外的基础架构，几分钟内就可以完成 Kibana 安装并启动 Elasticsearch 索引监测。</p>
<p>官网：<a href="https://www.elastic.co/cn/kibana">https://www.elastic.co/cn/kibana</a></p>
<p>Kibana 版本要和 Es 一致！</p>
<blockquote>
<p>启动测试！</p>
</blockquote>
<p>1、解压后的目录</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503233229.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503233229.png" alt="image-20210503233229181"></a></p>
<p>2、启动<code>kibana.bat</code></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503233731.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503233731.png" alt="image-20210503233731775"></a></p>
<p>3、访问测试</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503233752.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503233752.png" alt="image-20210503233752142"></a></p>
<p>4、开发工具！ （Post、curl、head、谷歌浏览器插件测试！）</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503233835.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503233835.png" alt="image-20210503233835622"></a></p>
<p>5、汉化！自己修改 kibana 配置即可！ zh-CN！</p>
<p>kibaba.yml 文件末尾添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line">i18n.locale: &quot;zn-CH&quot;</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503234155.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503234155.png" alt="image-20210503234155128"></a></p>
<h2 id="ES-核心概念"><a href="#ES-核心概念" class="headerlink" title="ES 核心概念"></a>ES 核心概念</h2><ol>
<li>索引</li>
<li>字段类型（mapping）</li>
<li>文档（documents）</li>
</ol>
<blockquote>
<p>概述</p>
</blockquote>
<p>在前面的学习中，我们已经掌握了 es 是什么，同时也把 es 的服务已经安装启动，那么 es 是如何去存储数据，数据结构是什么，又是如何实现搜索的呢？我们先来聊聊 ElasticSearch 的相关概念吧！</p>
<p><strong>集群，节点，索引，类型，文档，分片，映射是什么？</strong></p>
<blockquote>
<p>elasticsearch 是面向文档，关系行数据库 和 elasticsearch 客观的对比！一切都是 JSON！</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>Relational DB</strong></th>
<th><strong>Elasticsearch</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据库(database)</td>
<td>索引(indices)</td>
</tr>
<tr>
<td>表(tables)</td>
<td>types</td>
</tr>
<tr>
<td>行(rows)</td>
<td>documents</td>
</tr>
<tr>
<td>字段(columns)</td>
<td>fields</td>
</tr>
</tbody></table>
<p>elasticsearch(集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包含多 个文档(行)，每个文档中又包含多个字段(列)。</p>
<p><strong>物理设计：</strong></p>
<p>elasticsearch 在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器间迁移</p>
<p>一个人就是一个集群！默认的集群名称就是 elaticsearh</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503234530.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503234530.webp" alt="img"></a></p>
<p><strong>逻辑设计：</strong></p>
<p>一个索引类型中，包含多个文档，比如说文档 1，文档 2。 当我们索引一篇文档时，可以通过这样的一各顺序找到 它: 索引 ▷ 类型 ▷ 文档 ID ，通过这个组合我们就能索引到某个具体的文档。 注意:ID 不必是整数，实际上它是个字符串。</p>
<blockquote>
<p>文档</p>
</blockquote>
<p>就是我们的一条条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">user</span><br><span class="line">1  zhangsan  18</span><br><span class="line">2  ouwen  3</span><br></pre></td></tr></table></figure>

<p>之前说 elasticsearch 是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch 中，文档有几个 重要属性 :</p>
<ul>
<li>自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key:value！</li>
<li>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！ {就是一个 json 对象！fastjson 进行自动转换！}</li>
<li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在 elasticsearch 中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。</li>
</ul>
<p>尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符 串也可以是整形。因为 elasticsearch 会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在 elasticsearch 中，类型有时候也称为映射类型。</p>
<blockquote>
<p>类型</p>
</blockquote>
<p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射，比如 name 映 射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么 elasticsearch 是怎么做的呢?elasticsearch 会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch 就开始猜，如果这个值是 18，那么 elasticsearch 会认为它是整形。 但是 elasticsearch 也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别 整什么幺蛾子。</p>
<blockquote>
<p>索引</p>
</blockquote>
<p>就是数据库！</p>
<p>索引是映射类型的容器，elasticsearch 中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。 我们来研究下分片是如何工作的。</p>
<p>物理设计 ：节点和分片 如何工作</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235339.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235339.webp" alt="img"></a></p>
<p>一个集群至少有一个节点，而一个节点就是一个 elasricsearch 进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个 5 个分片 ( primary shard ,又称主分片 ) 构成的，每一个主分片会有一个副本 ( replica shard ,又称复制分片 )</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235352.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235352.webp" alt="img"></a></p>
<p>上图是一个有 3 个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉 了，数据也不至于丢失。 实际上，一个分片是一个 Lucene 索引，一个包含倒排索引的文件目录，<strong>倒排索引</strong>的结构使 得 elasticsearch 在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。 不过，等等，倒排索引是什 么鬼?</p>
<blockquote>
<p>倒排索引</p>
</blockquote>
<p>elasticsearch 使用的是一种称为倒排索引的结构，采用 Lucene 倒排索作为底层。这种结构适用于快速的全文搜索， 一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例如，现在有两个文档， 每个文档包含如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">Study every day, good good up to forever  # 文档1包含的内容</span><br><span class="line">To forever, study every day, good good up # 文档2包含的内容</span><br></pre></td></tr></table></figure>

<p>为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者 tokens)，然后创建一个包含所有不重 复的词条的排序列表，然后列出每个词条出现在哪个文档 :</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235436.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235436.png" alt="image-20210503235436309"></a></p>
<p>现在，我们试图搜索 to forever，只需要查看包含每个词条的文档 score</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235452.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235452.png" alt="image-20210503235452613"></a></p>
<p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。</p>
<p>再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构 :</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235510.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235510.webp" alt="img"></a></p>
<p>如果要搜索含有 python 标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要 查看标签这一栏，然后获取相关的文章 ID 即可。完全过滤掉无关的所有数据，提高效率！</p>
<p>elasticsearch 的索引和 Lucene 的索引对比</p>
<p>在 elasticsearch 中， 索引 （库）这个词被频繁使用，这就是术语的使用。 在 elasticsearch 中，索引被分为多个分片，每份 分片是一个 Lucene 的索引。所以一个 elasticsearch 索引是由多个 Lucene 索引组成的。别问为什么，谁让 elasticsearch 使用 Lucene 作为底层呢! 如无特指，说起索引都是指 elasticsearch 的索引。</p>
<h2 id="IK-分词器插件"><a href="#IK-分词器插件" class="headerlink" title="IK 分词器插件"></a>IK 分词器插件</h2><blockquote>
<p>什么是 IK 分词器？</p>
</blockquote>
<p>分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如 “我爱狂神” 会被分为”我”,”爱”,”狂”,”神”，这显然是不符合要求的，所以我们需要安装中文分词器 ik 来解决这个问题。</p>
<p>如果要使用中文，建议使用 ik 分词器！</p>
<p>IK 提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word 为最细粒度划分！</p>
<blockquote>
<p>安装</p>
</blockquote>
<p>1、<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>2、下载完毕后，放入到我们的 elasticsearch 插件即可</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235943.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503235943.png" alt="image-20210503235943039"></a></p>
<p>3、重启观察 ES，可以看到 ik 分词器被加载了！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504000047.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504000047.png" alt="image-20210504000047514"></a></p>
<p>4、elasticsearch-plugin 可以通过这个命令来查看加载进来的插件</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504000351.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504000351.png" alt="image-20210504000146656"></a></p>
<p>5、使用 kibana 进行测试</p>
<blockquote>
<p>查看不同的分词效果</p>
</blockquote>
<p>ik_smart 为最少切分</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504000943.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504000943.png" alt="image-20210504000856743"></a></p>
<p>ik_max_word 为最细粒度划分，穷尽词库的可能！字典！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001030.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001030.png" alt="image-20210504001030482"></a></p>
<blockquote>
<p>我们输入 超级喜欢狂神说 Java</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001209.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001209.webp" alt="img"></a></p>
<p>发现问题：狂神说被拆开了！</p>
<p>这种自己需要的词，需要自己加到我们的分词器的字典中！</p>
<blockquote>
<p>ik 分词器增加自己的配置！</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001411.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001411.png" alt="image-20210504001411652"></a></p>
<p>重启 es，看细节！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001513.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001513.png" alt="image-20210504001513405"></a></p>
<p>再次测试一下狂神说，看下效果！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001619.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504001619.png" alt="image-20210504001619667"></a></p>
<h2 id="Rest-风格说明"><a href="#Rest-风格说明" class="headerlink" title="Rest 风格说明"></a>Rest 风格说明</h2><p>一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>基本 Rest 命令说明：</p>
<table>
<thead>
<tr>
<th>method</th>
<th>url 地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PUT</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档 id</td>
<td>创建文档（指定文档 id）</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称</td>
<td>创建文档（随机文档 id）</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档 id&#x2F;_update</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档 id</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档 id</td>
<td>查询文档通过文档 id</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;_search</td>
<td>查询所有数据</td>
</tr>
</tbody></table>
<h2 id="关于索引的基本操作"><a href="#关于索引的基本操作" class="headerlink" title="关于索引的基本操作"></a>关于索引的基本操作</h2><h3 id="创建一个索引！"><a href="#创建一个索引！" class="headerlink" title="创建一个索引！"></a>创建一个索引！</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">PUT /索引名/~类型名~/文档id</span><br><span class="line">&#123;请求体&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504002138.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504002138.png" alt="image-20210504002137968"></a></p>
<p>完成了自动增加了索引！数据也成功的添加了，这就是我说大家在初期可以把它当做数据库学习的原因！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504002239.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504002239.png" alt="image-20210504002239404"></a></p>
<p>那么 name 这个字段用不用指定类型呢。毕竟我们关系型数据库 是需要指定类型的啊 !</p>
<ul>
<li>字符串类型<br>text 、 keyword</li>
<li>数值类型<br>long, integer, short, byte, double, float, half_float, scaled_float</li>
<li>日期类型<br>date</li>
<li>布尔值类型<br>boolean</li>
<li>二进制类型<br>binary</li>
<li>等等…..</li>
</ul>
<h3 id="指定字段的类型"><a href="#指定字段的类型" class="headerlink" title="指定字段的类型"></a>指定字段的类型</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504002816.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504002816.png" alt="image-20210504002816478"></a></p>
<p>获得这个规则！ 可以通过 GET 请求获取具体的信息！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504002902.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504002902.png" alt="image-20210504002902783"></a></p>
<h3 id="查看默认的信息"><a href="#查看默认的信息" class="headerlink" title="查看默认的信息"></a>查看默认的信息</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003207.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003207.png" alt="image-20210504003207460"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003219.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003219.png" alt="image-20210504003219494"></a></p>
<p>如果自己的文档字段没有指定，那么 es 就会给我们默认配置字段类型！</p>
<p><strong>扩展</strong>： 通过命令 elasticsearch 索引情况！ 通过<code>GET _cat/</code> 可以获得 es 的当前的很多信息！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003418.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003418.png" alt="image-20210504003418475"></a></p>
<blockquote>
<p>修改 提交还是使用 PUT 即可！ 然后覆盖！最新办法！</p>
</blockquote>
<p>曾经！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003608.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003608.png" alt="image-20210504003608862"></a></p>
<p>现在的方法！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003757.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003757.png" alt="image-20210504003757886"></a></p>
<blockquote>
<p>删除索引！</p>
</blockquote>
<p>通过 DELETE 命令实现删除、 根据你的请求来判断是删除索引还是删除文档记录！</p>
<p>使用 RESTFUL 风格是我们 ES 推荐大家使用的！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003924.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504003924.png" alt="image-20210504003924263"></a></p>
<h2 id="关于文档的基本操作（重点）"><a href="#关于文档的基本操作（重点）" class="headerlink" title="关于文档的基本操作（重点）"></a>关于文档的基本操作（重点）</h2><blockquote>
<p>基本操作</p>
</blockquote>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">PUT /ouwen/user/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;小红&quot;,</span><br><span class="line">  &quot;age&quot;: 22,</span><br><span class="line">  &quot;desc&quot;: &quot;我是一个美女&quot;,</span><br><span class="line">  &quot;tags&quot;: [&quot;睡觉&quot;,&quot;靓女&quot;,&quot;吃饭&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504004712.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504004712.png" alt="image-20210504004712396"></a></p>
<h3 id="获取数据-GET"><a href="#获取数据-GET" class="headerlink" title="获取数据 GET"></a>获取数据 GET</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504004741.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504004741.png" alt="image-20210504004741798"></a></p>
<h3 id="更新数据-PUT"><a href="#更新数据-PUT" class="headerlink" title="更新数据 PUT"></a>更新数据 PUT</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504004901.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504004901.png" alt="image-20210504004901746"></a></p>
<h3 id="Post-update-推荐使用这种更新方式！"><a href="#Post-update-推荐使用这种更新方式！" class="headerlink" title="Post _update , 推荐使用这种更新方式！"></a>Post _update , 推荐使用这种更新方式！</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504005345.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504005345.png" alt="img"></a></p>
<h3 id="简单地搜索！"><a href="#简单地搜索！" class="headerlink" title="简单地搜索！"></a>简单地搜索！</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">GET ouwen/user/1</span><br></pre></td></tr></table></figure>

<p>简答的条件查询，可以根据默认的映射规则，产生基本的查询！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504005803.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504005803.png" alt="image-20210504005803020"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504005944.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504005944.png" alt="image-20210504005944771"></a></p>
<h3 id="复杂操作搜索-select-排序，分页，高亮，模糊查询，精准查询！"><a href="#复杂操作搜索-select-排序，分页，高亮，模糊查询，精准查询！" class="headerlink" title="复杂操作搜索 select ( 排序，分页，高亮，模糊查询，精准查询！)"></a>复杂操作搜索 select ( 排序，分页，高亮，模糊查询，精准查询！)</h3><p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504010155.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504010155.png" alt="image-20210504010146616"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504010602.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504010602.png" alt="image-20210504010602133"></a></p>
<p>输出结果，不想要那么多！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504010722.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504010722.png" alt="image-20210504010722580"></a>我们之后使用 Java 操作 es ，所有的方法和对象就是这里面的 key！</p>
<blockquote>
<p>排序！</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011018.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011018.png" alt="image-20210504011018343"></a></p>
<blockquote>
<p>分页查询！</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011149.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011149.png" alt="image-20210504011149220"></a></p>
<p>数据下标还是从 0 开始的，和学的所有数据结构是一样的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/search/&#123;current&#125;/&#123;pagesize&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>布尔值查询</p>
</blockquote>
<p><strong>must （and）</strong>，所有的条件都要符合 where id &#x3D; 1 and name &#x3D; xxx</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011607.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011607.png" alt="image-20210504011607517"></a></p>
<p><strong>should（or）</strong>，所有的条件都要符合 where id &#x3D; 1 or name &#x3D; xxx</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011736.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011736.png" alt="image-20210504011736768"></a></p>
<p><strong>must_not （not）</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011831.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504011831.png" alt="image-20210504011831232"></a></p>
<p><strong>过滤器 filter</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012021.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012021.png" alt="image-20210504012021112"></a></p>
<ul>
<li>gt 大于</li>
<li>gte 大于等于</li>
<li>lt 小于</li>
<li>lte 小于等于！</li>
</ul>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012126.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012126.png" alt="image-20210504012126745"></a></p>
<blockquote>
<p>匹配多个条件！</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012405.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012405.png" alt="image-20210504012405631"></a></p>
<blockquote>
<p>精确查询！</p>
</blockquote>
<p>term 查询是直接通过倒排索引指定的词条进程精确查找的！</p>
<p><strong>关于分词：</strong></p>
<ul>
<li>term ，直接查询精确的</li>
<li>match，会使用分词器解析！（先分析文档，然后在通过分析的文档进行查询！）</li>
</ul>
<p><strong>两个类型 <code>text</code> <code>keyword</code></strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012855.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012855.webp" alt="img"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012909.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504012909.webp" alt="img"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504013020.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504013020.webp" alt="img"></a></p>
<blockquote>
<p>多个值匹配精确查询</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504014024.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504014024.webp" alt="img"></a></p>
<blockquote>
<p>高亮查询！</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504014306.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504014306.png" alt="image-20210504014305845"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504014541.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504014541.png" alt="image-20210504014541346"></a></p>
<h2 id="集成-SpringBoot"><a href="#集成-SpringBoot" class="headerlink" title="集成 SpringBoot"></a>集成 SpringBoot</h2><blockquote>
<p>找官方文档！</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504131313.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504131313.webp" alt="img"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504131324.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504131324.webp" alt="img"></a></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504131333.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504131333.webp" alt="img"></a></p>
<p>1、找到原生的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;7.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、找对象</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504131416.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504131416.webp" alt="img"></a></p>
<p>3、分析这个类中的方法即可！</p>
<blockquote>
<p>配置基本的项目</p>
</blockquote>
<p>源码中提供对象！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504133033.webp"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210504133033.webp" alt="img"></a></p>
<p>虽然这里导入 3 个类，静态内部类，核心类就一个！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Elasticsearch rest client infrastructure configurations.</span><br><span class="line">*</span><br><span class="line">* @author Brian Clozel</span><br><span class="line">* @author Stephane Nicoll</span><br><span class="line">*/</span><br><span class="line">class RestClientConfigurations &#123;</span><br><span class="line">    @Configuration(proxyBeanMethods = false)</span><br><span class="line">    static class RestClientBuilderConfiguration &#123;</span><br><span class="line">        // RestClientBuilder</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        RestClientBuilder elasticsearchRestClientBuilder(RestClientProperties</span><br><span class="line">                                                         properties,</span><br><span class="line">                                                         ObjectProvider&lt;RestClientBuilderCustomizer&gt; builderCustomizers) &#123;</span><br><span class="line">            HttpHost[] hosts =</span><br><span class="line">                properties.getUris().stream().map(HttpHost::create).toArray(HttpHost[]::new);</span><br><span class="line">            RestClientBuilder builder = RestClient.builder(hosts);</span><br><span class="line">            PropertyMapper map = PropertyMapper.get();</span><br><span class="line">            map.from(properties::getUsername).whenHasText().to((username) -&gt; &#123;</span><br><span class="line">                CredentialsProvider credentialsProvider = new</span><br><span class="line">                    BasicCredentialsProvider();</span><br><span class="line">                Credentials credentials = new</span><br><span class="line">                    UsernamePasswordCredentials(properties.getUsername(),</span><br><span class="line">                                                properties.getPassword());</span><br><span class="line">                credentialsProvider.setCredentials(AuthScope.ANY, credentials);</span><br><span class="line">                builder.setHttpClientConfigCallback(</span><br><span class="line">                    (httpClientBuilder) -&gt;</span><br><span class="line">                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider));</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.setRequestConfigCallback((requestConfigBuilder) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                map.from(properties::getConnectionTimeout).whenNonNull().asInt(Duration::toMill</span><br><span class="line">                                                                               is)</span><br><span class="line">                    .to(requestConfigBuilder::setConnectTimeout);</span><br><span class="line"></span><br><span class="line">                map.from(properties::getReadTimeout).whenNonNull().asInt(Duration::toMillis)</span><br><span class="line">                    .to(requestConfigBuilder::setSocketTimeout);</span><br><span class="line">                return requestConfigBuilder;</span><br><span class="line">            &#125;);</span><br><span class="line">            builderCustomizers.orderedStream().forEach((customizer) -&gt;</span><br><span class="line">                                                       customizer.customize(builder));</span><br><span class="line">            return builder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Configuration(proxyBeanMethods = false)</span><br><span class="line">    @ConditionalOnClass(RestHighLevelClient.class)</span><br><span class="line">    static class RestHighLevelClientConfiguration &#123;</span><br><span class="line">        // RestHighLevelClient 高级客户端，也是我们这里要讲，后面项目会用到的客户端</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        RestHighLevelClient elasticsearchRestHighLevelClient(RestClientBuilder</span><br><span class="line">                                                             restClientBuilder) &#123;</span><br><span class="line">            return new RestHighLevelClient(restClientBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        RestClient elasticsearchRestClient(RestClientBuilder builder,</span><br><span class="line">                                           ObjectProvider&lt;RestHighLevelClient&gt; restHighLevelClient) &#123;</span><br><span class="line">            RestHighLevelClient client = restHighLevelClient.getIfUnique();</span><br><span class="line">            if (client != null) &#123;</span><br><span class="line">                return client.getLowLevelClient();</span><br><span class="line">            &#125;</span><br><span class="line">            return builder.build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Configuration(proxyBeanMethods = false)</span><br><span class="line">    static class RestClientFallbackConfiguration &#123;</span><br><span class="line">        // RestClient 普通的客户端！</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        RestClient elasticsearchRestClient(RestClientBuilder builder) &#123;</span><br><span class="line">            return builder.build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体的 API 测试！</p>
</blockquote>
<ol>
<li>创建索引</li>
<li>判断索引是否存在</li>
<li>删除索引</li>
<li>创建文档</li>
<li>crud 文档！</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.luojunjie;</span><br><span class="line"></span><br><span class="line">import cn.hutool.json.JSON;</span><br><span class="line">import cn.hutool.json.JSONString;</span><br><span class="line">import cn.hutool.json.JSONUtil;</span><br><span class="line">import com.luojunjie.pojo.User;</span><br><span class="line">import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;</span><br><span class="line">import org.elasticsearch.action.bulk.BulkRequest;</span><br><span class="line">import org.elasticsearch.action.bulk.BulkResponse;</span><br><span class="line">import org.elasticsearch.action.delete.DeleteRequest;</span><br><span class="line">import org.elasticsearch.action.delete.DeleteResponse;</span><br><span class="line">import org.elasticsearch.action.get.GetRequest;</span><br><span class="line">import org.elasticsearch.action.get.GetResponse;</span><br><span class="line">import org.elasticsearch.action.index.IndexRequest;</span><br><span class="line">import org.elasticsearch.action.index.IndexResponse;</span><br><span class="line">import org.elasticsearch.action.search.SearchRequest;</span><br><span class="line">import org.elasticsearch.action.search.SearchResponse;</span><br><span class="line">import org.elasticsearch.action.support.master.AcknowledgedResponse;</span><br><span class="line">import org.elasticsearch.action.update.UpdateRequest;</span><br><span class="line">import org.elasticsearch.action.update.UpdateResponse;</span><br><span class="line">import org.elasticsearch.client.RequestOptions;</span><br><span class="line">import org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line">import org.elasticsearch.client.indices.CreateIndexRequest;</span><br><span class="line">import org.elasticsearch.client.indices.CreateIndexResponse;</span><br><span class="line">import org.elasticsearch.client.indices.GetIndexRequest;</span><br><span class="line">import org.elasticsearch.common.unit.TimeValue;</span><br><span class="line">import org.elasticsearch.common.xcontent.XContentType;</span><br><span class="line">import org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line">import org.elasticsearch.index.query.TermQueryBuilder;</span><br><span class="line">import org.elasticsearch.search.SearchHit;</span><br><span class="line">import org.elasticsearch.search.builder.SearchSourceBuilder;</span><br><span class="line">import org.elasticsearch.search.fetch.subphase.FetchSourceContext;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class JunjieEsApiApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;restHighLevelClient&quot;)</span><br><span class="line">    private RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    //测试索引的创建 Request</span><br><span class="line">    @Test</span><br><span class="line">    void testCreateIndex() throws IOException &#123;</span><br><span class="line">        // 1、创建索引对象</span><br><span class="line">        CreateIndexRequest request = new CreateIndexRequest(&quot;ouwen_index&quot;);</span><br><span class="line">        // 2、客户端执行请求 IndicesClient 请求后获得响应结果</span><br><span class="line">        CreateIndexResponse createIndexResponse =</span><br><span class="line">                client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(createIndexResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试获取索引 判断其是否存在</span><br><span class="line">    @Test</span><br><span class="line">    void testExistIndex() throws IOException &#123;</span><br><span class="line">        GetIndexRequest request = new GetIndexRequest(&quot;ouwen_index&quot;);</span><br><span class="line">        boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(exists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试删除索引</span><br><span class="line">    @Test</span><br><span class="line">    void testDeleteIndex() throws IOException &#123;</span><br><span class="line">        DeleteIndexRequest request = new DeleteIndexRequest(&quot;ouwen_index&quot;);</span><br><span class="line">        AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(delete.isAcknowledged());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试添加文档</span><br><span class="line">    @Test</span><br><span class="line">    void testAddDocument() throws IOException &#123;</span><br><span class="line">        //创建对象</span><br><span class="line">        User user = new User(&quot;欧文&quot;, 18);</span><br><span class="line">        //创建请求</span><br><span class="line">        IndexRequest request = new IndexRequest(&quot;ouwen_index&quot;);</span><br><span class="line"></span><br><span class="line">        //规则 PUT /ouwen_index/_doc/1</span><br><span class="line">        request.id(&quot;1&quot;);</span><br><span class="line">        request.timeout(TimeValue.timeValueSeconds(1));</span><br><span class="line"></span><br><span class="line">        //将我们的数据放入请求 json</span><br><span class="line">        request.source(JSONUtil.toJsonStr(user), XContentType.JSON);</span><br><span class="line"></span><br><span class="line">        //客户端发送请求</span><br><span class="line">        IndexResponse index = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(index.toString());</span><br><span class="line">        System.out.println(index.status()); //对应命令返回的状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取文档，判断是否存在</span><br><span class="line">    @Test</span><br><span class="line">    void testIsExists() throws IOException &#123;</span><br><span class="line">        GetRequest getRequest = new GetRequest(&quot;ouwen_index&quot;, &quot;1&quot;);</span><br><span class="line">        //不获取返回的 _source 的上下文 效率更高</span><br><span class="line">        getRequest.fetchSourceContext(new FetchSourceContext(false));</span><br><span class="line"></span><br><span class="line">        boolean exists = client.exists(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(exists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获得文档的内容</span><br><span class="line">    @Test</span><br><span class="line">    void testGetDocument() throws IOException &#123;</span><br><span class="line">        GetRequest getRequest = new GetRequest(&quot;ouwen_index&quot;, &quot;1&quot;);</span><br><span class="line">        GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        //打印文档的内容</span><br><span class="line">        System.out.println(getResponse.getSourceAsString());</span><br><span class="line">        //返回的全部内容跟命令是一样的</span><br><span class="line">        System.out.println(getResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //更新文档的内容</span><br><span class="line">    @Test</span><br><span class="line">    void testUpdateDocument() throws IOException &#123;</span><br><span class="line">        UpdateRequest updateRequest = new UpdateRequest(&quot;ouwen_index&quot;, &quot;1&quot;);</span><br><span class="line">        updateRequest.timeout(&quot;1s&quot;);</span><br><span class="line"></span><br><span class="line">        User user = new User(&quot;ouwen666&quot;, 22);</span><br><span class="line">        updateRequest.doc(JSONUtil.toJsonStr(user), XContentType.JSON);</span><br><span class="line"></span><br><span class="line">        UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(updateResponse.status());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除文档的内容</span><br><span class="line">    @Test</span><br><span class="line">    void testDeleteDocument() throws IOException &#123;</span><br><span class="line">        DeleteRequest deleteRequest = new DeleteRequest(&quot;ouwen_index&quot;, &quot;1&quot;);</span><br><span class="line">        deleteRequest.timeout(&quot;1s&quot;);</span><br><span class="line"></span><br><span class="line">        DeleteResponse response = client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(response.status());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //批量添加数据</span><br><span class="line">    @Test</span><br><span class="line">    void testBulkRequest() throws IOException &#123;</span><br><span class="line">        BulkRequest bulkRequest = new BulkRequest();</span><br><span class="line">        bulkRequest.timeout(&quot;60s&quot;);</span><br><span class="line">        List&lt;User&gt; users = new ArrayList&lt;User&gt;();</span><br><span class="line">        users.add(new User(&quot;ouwen1&quot;, 63));</span><br><span class="line">        users.add(new User(&quot;ouwen2&quot;, 53));</span><br><span class="line">        users.add(new User(&quot;ouwen3&quot;, 43));</span><br><span class="line">        users.add(new User(&quot;junjie1&quot;, 33));</span><br><span class="line">        users.add(new User(&quot;junjie2&quot;, 23));</span><br><span class="line">        users.add(new User(&quot;junjie3&quot;, 13));</span><br><span class="line">        //处理批量请求</span><br><span class="line">        for (int i = 0; i &lt; users.size(); i++) &#123;</span><br><span class="line">            bulkRequest.add(new IndexRequest(&quot;ouwen_index&quot;)</span><br><span class="line">                    .id(&quot;&quot; + (i + 1))</span><br><span class="line">                    .source(JSONUtil.toJsonStr(users.get(i)), XContentType.JSON));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BulkResponse responses = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(responses.hasFailures()); //是否失败 false代表成功</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查询</span><br><span class="line">    // SearchRequest 搜索请求</span><br><span class="line">    // SearchSourceBuilder 条件构造</span><br><span class="line">    // HighlightBuilder 构建高亮</span><br><span class="line">    // TermQueryBuilder 精确查询</span><br><span class="line">    // MatchAllQueryBuilder</span><br><span class="line">    // xxx QueryBuilder 对应我们刚才看到的命令！</span><br><span class="line">    @Test</span><br><span class="line">    void testSearch() throws IOException &#123;</span><br><span class="line">        SearchRequest searchRequest = new SearchRequest(&quot;ouwen_index&quot;);</span><br><span class="line">        //构建搜索条件</span><br><span class="line">        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        // 查询条件，我们可以使用 QueryBuilders 工具来实现</span><br><span class="line">        // QueryBuilders.termQuery 精确</span><br><span class="line">        // QueryBuilders.matchAllQuery() 匹配所有</span><br><span class="line">        TermQueryBuilder termQuery = QueryBuilders.termQuery(&quot;name&quot;, &quot;ouwen1&quot;);</span><br><span class="line"></span><br><span class="line">        sourceBuilder.query(termQuery);</span><br><span class="line">        sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS));</span><br><span class="line">        searchRequest.source(sourceBuilder);</span><br><span class="line">        SearchResponse search = client.search(searchRequest,RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(JSONUtil.toJsonStr(search.getHits()));</span><br><span class="line">        System.out.println(&quot;==========================================&quot;);</span><br><span class="line">        for (SearchHit hit : search.getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器基础篇</title>
    <url>/2023/05/01/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Doker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Docker-概述"><a href="#Docker-概述" class="headerlink" title="Docker 概述"></a>Docker 概述</h2><h3 id="Docker-为什么会出现？"><a href="#Docker-为什么会出现？" class="headerlink" title="Docker 为什么会出现？"></a>Docker 为什么会出现？</h3><blockquote>
<p>环境切换&#x2F;配置麻烦</p>
</blockquote>
<p>一般一个产品的生命周期中，可能会存在多个环境：</p>
<ul>
<li>开发环境</li>
<li>测试环境</li>
<li>生产环境</li>
</ul>
<p>其实我们在编程的过程中，很大一部分时间都花在 <code>环境</code> 上：</p>
<ul>
<li>比如重装系统之后，想要运行 <code>Jar/War</code> 包，就必须在系统里装上 <code>JDK</code> . <code>Tomcat</code>. <code>MySQL</code> 等环境 ，并配置好相应的环境变量</li>
<li>以前生产环境和测试环境完全是两套不同的环境，可能会出现：&#x3D;&#x3D;代码在测试环境跑没问题，到生产环境就出各种错！&#x3D;&#x3D;</li>
<li>在学习 <code>分布式/集群</code> 项目时，需要搭建多个环境，以前使用 <code>Vmware</code> 搭建费时费力，且对电脑的配置要求较高</li>
</ul>
<blockquote>
<p>应用之间需要隔离</p>
</blockquote>
<ul>
<li>假设，我只有一台服务器，我写了两个应用（网站），都部署在一台服务器里，倘若其中一个应用出现了问题，导致 CPU 跑满到 100%，那么另一个应用也会受影响！</li>
<li>同一个服务器下端口冲突. JRE 版本冲突…</li>
</ul>
<p>Docker 的出现就为以上问题带来了解决方案：</p>
<p>Docerk 的思想就来自于集装箱！</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211212012101.png" alt="img"></p>
<h3 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h3><h4 id="Docker-基本介绍"><a href="#Docker-基本介绍" class="headerlink" title="Docker 基本介绍"></a>Docker 基本介绍</h4><p><code>Docker</code> 是一个开源的应用容器引擎，基于 <code>Go 语言</code> 并遵从 <code>Apache2.0</code> 协议开源。</p>
<p><code>Docker</code> 可以让开发者打包他们的应用以及依赖包到一个轻量级. 可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app），更重要的是容器性能开销极低。</p>
<p><code>Docker</code> 从 <code>17.03</code> 版本之后分为 <code>CE（Community Edition: 社区版）</code> 和 <code>EE（Enterprise Edition: 企业版）</code>，我们用社区版就可以了。</p>
<p>官方文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成. 发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 <code>OpenShift</code> 或 <code>Cloud Foundry</code> 平台来搭建自己的 <code>PaaS</code> 环境。</li>
</ul>
<h4 id="Docker-的优势"><a href="#Docker-的优势" class="headerlink" title="Docker 的优势"></a>Docker 的优势</h4><ul>
<li>更快速地进行应用的交付和部署</li>
<li>更便携的升级和扩容</li>
<li>更简单的系统运维</li>
<li>更高效的计算机资源利用</li>
</ul>
<blockquote>
<p>总结：解决了&#x3D;&#x3D;运行环境和配置问题&#x3D;&#x3D;的&#x3D;&#x3D;软件容器&#x3D;&#x3D;，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>
</blockquote>
<h3 id="虚拟化技术和容器化技术的区别"><a href="#虚拟化技术和容器化技术的区别" class="headerlink" title="虚拟化技术和容器化技术的区别"></a>虚拟化技术和容器化技术的区别</h3><ul>
<li><p>虚拟化技术：</p>
<ol>
<li>资源占用多</li>
<li>冗余步骤多</li>
<li>启动很慢</li>
</ol>
</li>
<li><p>容器化技术：容器化技术不是模拟的一个完整的操作系统</p>
</li>
</ul>
<p>比较 Docker 和虚拟机的不同：</p>
<ol>
<li>传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。</li>
<li>Docker 容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟硬件。</li>
<li>每个容器都是相互隔离的，每个容器都有属于自己的文件系统，互不影响。</li>
</ol>
<h3 id="Docker-的基本组成"><a href="#Docker-的基本组成" class="headerlink" title="Docker 的基本组成"></a>Docker 的基本组成</h3><p>Docker 的基本组成图如下：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211212134734.png" alt="image-20211212134734666"></p>
<ul>
<li><p><strong>镜像（image）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATHEMATICA</span><br><span class="line">Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。就好似 Java 中的类和对象，类就是镜像，容器就是对象！</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>容器（container）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFORM7</span><br><span class="line">Docker 利用容器（Container）独立运行的一个或一组应用。容器就用镜像创建的运行实例。</span><br><span class="line"></span><br><span class="line">它可以被启动. 开始. 停止. 删除。每个容器都是相互隔离的，保证安全的平台。</span><br><span class="line"></span><br><span class="line">可以把容器看作是一个简易版的 Linux 环境（包括root用户权限. 进程空间. 用户空间和网络空间）和运行在其中的应用程序。</span><br><span class="line"></span><br><span class="line">容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那层是可读可写的。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>仓库（repository）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LASSO</span><br><span class="line">仓库（Repository）是集中存放镜像文件的场所。</span><br><span class="line"></span><br><span class="line">仓库（Repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</span><br><span class="line"></span><br><span class="line">仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</span><br><span class="line"></span><br><span class="line">最大的公开仓库是 Docker Hub（https://hub.docker.com/），存放了数量庞大的镜像供用户下载。</span><br><span class="line">国内最大的公开仓库包括阿里云. 网易云等。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><h3 id="Docker-的安装与卸载"><a href="#Docker-的安装与卸载" class="headerlink" title="Docker 的安装与卸载"></a>Docker 的安装与卸载</h3><blockquote>
<p>环境准备</p>
</blockquote>
<ol>
<li>需要会一点点的 Linux 的基础</li>
<li>CentOS 7</li>
<li>使用 Xshell 连接远程服务器进行操作！</li>
</ol>
<blockquote>
<p>环境查看</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 系统内核是 3.10 以上的</span><br><span class="line">[root@ouwen666 ~]# uname -r</span><br><span class="line">3.10.0-1062.18.1.el7.x86_64</span><br><span class="line"># 系统版本 centOS7</span><br><span class="line">[root@ouwen666 ~]# cat /etc/os-release</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装</p>
</blockquote>
<p>帮助文档：<a href="https://docs.docker.com/engine/install/centos/">Docker 官方帮助文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 1. 卸载旧的版本</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"># 2. 安装yum-utils包（提供 yum-config-manager 程序）</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"># 3. 设置镜像的仓库</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的，十分慢！</span><br><span class="line"># 建议使用阿里云的镜像地址</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 更新yum软件包索引</span><br><span class="line">sudo yum makecache fast</span><br><span class="line"></span><br><span class="line"># 4. 安装docker相关的 docker-ce docker-compose （默认为最新版）</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"># 安装指定版本</span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span><br><span class="line">sudo yum install docker-ce-20.10.13 docker-ce-cli-20.10.13 containerd.io docker-compose-plugin</span><br><span class="line"># 5. 启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 6. 使用docker version查看是否安装成功</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211212144008.png" alt="image-20211212144007872"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 7. 启动docker-hello-world</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211212144259.png" alt="image-20211212144259750"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 8. 查看下载的这个hello-world镜像</span><br><span class="line">[root@ouwen666 /]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   2 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>卸载 Docker</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 1. 卸载依赖</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"># 2. 删除资源 docker的默认工作路径</span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line">rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><ul>
<li><p>登录阿里云，找到容器镜像服务</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218143348.png" alt="image-20211218143146762"></p>
</li>
<li><p>找到镜像加速地址</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218143621.png" alt="image-20211218143621304"></p>
</li>
<li><p>配置使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://alq7pwwu.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="回顾-HelloWorld-流程"><a href="#回顾-HelloWorld-流程" class="headerlink" title="回顾 HelloWorld 流程"></a>回顾 HelloWorld 流程</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218144212.png" alt="image-20211218144212215"></p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="Docker-是怎么工作的？"><a href="#Docker-是怎么工作的？" class="headerlink" title="Docker 是怎么工作的？"></a>Docker 是怎么工作的？</h4><p>Docker 是一个 Client - Server 结构的系统，Docker 的守护进程运行在主机上。通过 Socket 从客户端访问！</p>
<p>DockerServer 接收到 Docker - Client 的指令，就会执行这个命令！</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218144701.png" alt="image-20211218144701740"></p>
<h4 id="Docker-为什么比-VM-快？"><a href="#Docker-为什么比-VM-快？" class="headerlink" title="Docker 为什么比 VM 快？"></a>Docker 为什么比 VM 快？</h4><ol>
<li><p>Docker 有着比虚拟机更少的抽象层</p>
</li>
<li><p>Docker 利用的是宿主机的内核，VM 需要的是 Guest OS（操作系统）</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218144918.png" alt="image-20211218144918851"></p>
<p>新建一个容器的时候，Docker 不需要像虚拟机一样重新加载一个操作系统内核，避免不必要的消耗。</p>
</li>
</ol>
<h2 id="Docker-的常用命令"><a href="#Docker-的常用命令" class="headerlink" title="Docker 的常用命令"></a>Docker 的常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 显示docker的版本信息</span><br><span class="line">docker version</span><br><span class="line"># 显示docker的系统信息，包括镜像和容器</span><br><span class="line">docker info</span><br><span class="line"># 帮助命令</span><br><span class="line">docker 命令 --help</span><br></pre></td></tr></table></figure>

<p>帮助文档地址：<a href="https://docs.docker.com/engine/reference/commandline/cli/">Docker 官方帮助文档</a></p>
<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="列出本机所有镜像"><a href="#列出本机所有镜像" class="headerlink" title="列出本机所有镜像"></a>列出本机所有镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line">[root@ouwen666 ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   2 months ago   13.3kB</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">REPOSITORY  镜像的仓库源</span><br><span class="line">TAG         镜像的标签</span><br><span class="line">IMAGE ID    镜像的ID</span><br><span class="line">CREATED     镜像的创建时间</span><br><span class="line">SIZE        镜像的大小</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">  -a， --all             # 列出所有镜像</span><br><span class="line">  -q， --quiet           # 只显示镜像的ID</span><br></pre></td></tr></table></figure>

<h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">[root@ouwen666 ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used， open-source relation…   11833     [OK]</span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   4505      [OK]</span><br><span class="line"></span><br><span class="line"># 可选项，通过收藏来过滤</span><br><span class="line">--filter=STARS=3000</span><br><span class="line">[root@ouwen666 ~]# docker search mysql --filter=STARS=3000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used， open-source relation…   11833     [OK]</span><br><span class="line">mariadb   MariaDB Server is a high performing open sou…   4505      [OK]</span><br></pre></td></tr></table></figure>

<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 下载镜像 docker pull 镜像名[:tag]</span><br><span class="line">[root@ouwen666 ~]# docker pull mysql</span><br><span class="line">Using default tag: latest   # 如果写 tag，默认就是 latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">ffbb094f4f9e: Pull complete # 分层下载，docker image 的核心 联合文件系统</span><br><span class="line">df186527fc46: Pull complete</span><br><span class="line">fa362a6aa7bd: Pull complete</span><br><span class="line">5af7cb1a200e: Pull complete</span><br><span class="line">949da226cc6d: Pull complete</span><br><span class="line">bce007079ee9: Pull complete</span><br><span class="line">eab9f076e5a3: Pull complete</span><br><span class="line">8a57a7529e8d: Pull complete</span><br><span class="line">b1ccc6ed6fc7: Pull complete</span><br><span class="line">b4af75e64169: Pull complete</span><br><span class="line">3aed6a9cd681: Pull complete</span><br><span class="line">23390142f76f: Pull complete</span><br><span class="line">Digest: sha256:ff9a288d1ecf4397967989b5d1ec269f7d9042a46fc8bc2c3ae35458c1a26727  # 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest  # 真实地址</span><br><span class="line"></span><br><span class="line"># 等价与它</span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br><span class="line"></span><br><span class="line"># 指定版本下载</span><br><span class="line">[root@ouwen666 ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">ffbb094f4f9e: Already exists</span><br><span class="line">df186527fc46: Already exists</span><br><span class="line">fa362a6aa7bd: Already exists</span><br><span class="line">5af7cb1a200e: Already exists</span><br><span class="line">949da226cc6d: Already exists</span><br><span class="line">bce007079ee9: Already exists</span><br><span class="line">eab9f076e5a3: Already exists</span><br><span class="line">c7b24c3f27af: Pull complete</span><br><span class="line">6fc26ff6705a: Pull complete</span><br><span class="line">bec5cdb5e7f7: Pull complete</span><br><span class="line">6c1cb25f7525: Pull complete</span><br><span class="line">Digest: sha256:d1cc87a3bd5dc07defc837bc9084f748a130606ff41923f46dec1986e0dc828d</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218170934.png" alt="image-20211218170934412"></p>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">[root@ouwen666 ~]# docker rmi -f 镜像ID  # 删除指定的镜像</span><br><span class="line">[root@ouwen666 ~]# docker rmi -f 镜像ID 镜像ID 镜像ID 镜像ID  # 删除多个镜像</span><br><span class="line">[root@ouwen666 ~]# docker rmi -f $(docker images -aq)   # 删除全部的镜像</span><br></pre></td></tr></table></figure>

<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>有了镜像才可以创建容器：linux，下载一个 centos 镜像来学习</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>

<h4 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">--name=&quot;Name&quot;  # 容器名字 为容器指定一个名称</span><br><span class="line">-d             # 后台方式运行</span><br><span class="line">-it            # 使用交互方式运行，并分配一个伪终端，等待交互</span><br><span class="line">-p             # 指定容器的端口  -p 8080:8080</span><br><span class="line">  -p ip:主机端口:容器端口 (常用)</span><br><span class="line">  -p 主机端口:容器端口 (常用)</span><br><span class="line">  -p 容器端口</span><br><span class="line">-P             # 随机指定端口</span><br><span class="line"></span><br><span class="line"># 测试一下 启动并进入容器</span><br><span class="line">[root@ouwen666 ~]# docker run -it centos /bin/bash</span><br><span class="line"># 查看容器内的centos，官方镜像是一个基础版本，很多命令都是不完善的！</span><br><span class="line">[root@0226b99be9ff /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"># 从容器中退出主机</span><br><span class="line">[root@0226b99be9ff /]# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h4 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># docker ps 命令</span><br><span class="line">-a    # 列出当前正在运行的容器+带出历史运行过的容器</span><br><span class="line">-l    # 显示最近创建的容器</span><br><span class="line">-n=?  # 显示最近创建n个容器</span><br><span class="line">-q    # 只显示容器的编号</span><br><span class="line">[root@ouwen666 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@ouwen666 ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                             NAMES</span><br><span class="line">0226b99be9ff   centos         &quot;/bin/bash&quot;   3 minutes ago   Exited (0) About a minute ago</span><br><span class="line">55a3ece5f682   feb5d9fea6a5   &quot;/hello&quot;      6 days ago      Exited (0) 6 days ago</span><br></pre></td></tr></table></figure>

<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">exit    # 直接停止容器并退出</span><br><span class="line">Ctrl + P + Q  # 容器不停止并退出</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker rm 容器ID  # 删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)  # 删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm  #删除所有的容器</span><br></pre></td></tr></table></figure>

<h4 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker start 容器ID       # 启动容器</span><br><span class="line">docker restart 容器ID     # 重启容器</span><br><span class="line">docker stop 容器ID        # 停止容器</span><br><span class="line">docker kill 容器ID        # 强制停止当前容器</span><br></pre></td></tr></table></figure>

<h3 id="常用其他命令【重要】"><a href="#常用其他命令【重要】" class="headerlink" title="常用其他命令【重要】"></a>常用其他命令【重要】</h3><h4 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 命令 docker run -d 镜像名！</span><br><span class="line">[root@ouwen666 /]# docker run -d centos</span><br><span class="line"></span><br><span class="line"># 问题 docker ps，发现 centos 停止了</span><br><span class="line"></span><br><span class="line"># 常见的坑：docker容器使用后台运行，就必须要有要给前台进程，docker发现没有应用，就会自动停止</span><br></pre></td></tr></table></figure>

<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line">docker logs -f -t --tail 10 容器ID</span><br><span class="line"></span><br><span class="line"># 写一段shell脚本，不停的打印输出</span><br><span class="line">[root@ouwen666 /]# docker run -d centos /bin/sh -c &quot;while true;do echo helloworld;sleep 1;done&quot;</span><br><span class="line">5fff272a8948f573264a09ac17d437b6d7424a5b03604b4191666f252993a6f3</span><br><span class="line"></span><br><span class="line">[root@ouwen666 /]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS</span><br><span class="line">5fff272a8948   centos    &quot;/bin/sh -c &#x27;while t…&quot;   5 seconds ago   Up 5 seconds</span><br><span class="line"></span><br><span class="line"># 显示日志</span><br><span class="line">-tf             # 显示所有的日志</span><br><span class="line">--tail number   # 显示指定行数的日志</span><br><span class="line">[root@ouwen666 /]# docker logs -tf --tail 10 5fff272a8948</span><br></pre></td></tr></table></figure>

<h4 id="查看容器中的进程信息"><a href="#查看容器中的进程信息" class="headerlink" title="查看容器中的进程信息"></a>查看容器中的进程信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 命令 docker top 容器ID</span><br><span class="line">[root@ouwen666 /]# docker top 5fff272a8948</span><br><span class="line">UID                 PID                 PPID                C                   STIME</span><br><span class="line">root                326                 32457               0                   17:46</span><br><span class="line">root                32457               32438               0                   17:42</span><br></pre></td></tr></table></figure>

<h4 id="查看镜像-x2F-容器的详细信息"><a href="#查看镜像-x2F-容器的详细信息" class="headerlink" title="查看镜像&#x2F;容器的详细信息"></a>查看镜像&#x2F;容器的详细信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 命令 docker inspect 镜像/容器ID</span><br><span class="line">[root@ouwen666 /]# docker inspect 5fff272a8948</span><br></pre></td></tr></table></figure>

<h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span><br><span class="line"></span><br><span class="line"># 命令</span><br><span class="line">docker exec -it 容器ID bashShell</span><br><span class="line"># 测试</span><br><span class="line">[root@ouwen666 /]# docker exec -it 5fff272a8948 /bin/bash</span><br><span class="line">[root@5fff272a8948 /]#</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">docker attach 容器ID</span><br><span class="line"># 测试</span><br><span class="line">[root@ouwen666 /]# docker attach 5fff272a8948</span><br><span class="line">正在执行的代码...</span><br><span class="line"></span><br><span class="line"># docker exec     # 进入容器后，开启一个新的终端，exit后不会停止容器（常用）</span><br><span class="line"># docker attach   # 进入容器正在执行的终端，不会启动新的进程，exit后会停止容器！</span><br></pre></td></tr></table></figure>

<h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br><span class="line"># 测试</span><br><span class="line">[root@ouwen666 home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS</span><br><span class="line">7938b1a7dece   centos    &quot;/bin/bash&quot;   About a minute ago   Up About a minute</span><br><span class="line"># 进入容器内部</span><br><span class="line">[root@ouwen666 home]# docker attach 7938b1a7dece</span><br><span class="line">[root@7938b1a7dece /]# cd /home/</span><br><span class="line"># 创建一个文件</span><br><span class="line">[root@7938b1a7dece home]# touch helloworld.java</span><br><span class="line">[root@7938b1a7dece home]# ls</span><br><span class="line">helloworld.java</span><br><span class="line"># 退出容器</span><br><span class="line">[root@7938b1a7dece home]# exit</span><br><span class="line">exit</span><br><span class="line"># 将容器中的文件拷贝到主机中</span><br><span class="line">[root@ouwen666 home]# docker cp 7938b1a7dece:/home/helloworld.java /home/</span><br><span class="line">[root@ouwen666 home]# ls</span><br><span class="line">git  helloworld.java</span><br></pre></td></tr></table></figure>

<h4 id="导入-x2F-导出容器"><a href="#导入-x2F-导出容器" class="headerlink" title="导入&#x2F;导出容器"></a>导入&#x2F;导出容器</h4><ul>
<li>export 导出容器的内容留作为一个 tar 归档文件[对应 import 命令]</li>
<li>import 从 tar 包中的内容创建一个新的文件系统再导入为镜像[对应 export]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AUTOIT</span><br><span class="line"># 导出</span><br><span class="line">[root@88233 ~]# docker export 71720f3a8f51 &gt; myubuntu.tar</span><br><span class="line"></span><br><span class="line"># 导入</span><br><span class="line">[root@88233 ~]# cat myubuntu.tar | docker import - vansys/ubuntu:1.0</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218192225.png" alt="image-20211218192225807"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GAUSS</span><br><span class="line"></span><br><span class="line">attach       # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line">build        # 通过 Dockerfile 定制镜像</span><br><span class="line">commit       # 提交当前容器为新的镜像</span><br><span class="line">cp           #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">create       # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line">diff         # 查看 docker 容器变化</span><br><span class="line">events       # 从 docker 服务获取容器实时事件</span><br><span class="line">exec         # 在已存在的容器上运行命令</span><br><span class="line">export       # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line">history      # 展示一个镜像形成历史</span><br><span class="line">images       # 列出系统当前镜像</span><br><span class="line">import       # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line">info         # 显示系统相关信息</span><br><span class="line">inspect      # 查看容器详细信息</span><br><span class="line">kill         # kill 指定 docker 容器</span><br><span class="line">load         # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line">login        # 注册或者登陆一个 docker 源服务器</span><br><span class="line">logout       # 从当前 Docker registry 退出</span><br><span class="line">logs         # 输出当前容器日志信息</span><br><span class="line">port         # 查看映射端口对应的容器内部源端口</span><br><span class="line">pause        # 暂停容器</span><br><span class="line">ps           # 列出容器列表</span><br><span class="line">pull         # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">push         # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">restart      # 重启运行的容器</span><br><span class="line">rm           # 移除一个或者多个容器</span><br><span class="line">rmi          # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line">run          # 创建一个新的容器并运行一个命令</span><br><span class="line">save         # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line">search       # 在 docker hub 中搜索镜像</span><br><span class="line">start        # 启动容器</span><br><span class="line">stop         # 停止容器</span><br><span class="line">tag          # 给源中镜像打标签</span><br><span class="line">top          # 查看容器中运行的进程信息</span><br><span class="line">unpause      # 取消暂停容器</span><br><span class="line">version      # 查看 docker 版本号</span><br><span class="line">wait         # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="Docker-安装-Nginx"><a href="#Docker-安装-Nginx" class="headerlink" title="Docker 安装 Nginx"></a>Docker 安装 Nginx</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 1. 搜索镜像 或者去 dockerHub 上搜索 https://hub.docker.com/search?q=nginx&amp;type=image</span><br><span class="line">[root@ouwen666 home]# docker search nginx</span><br><span class="line"># 2. 下载镜像</span><br><span class="line">[root@ouwen666 home]# docker pull nginx</span><br><span class="line"># 3. 运行测试</span><br><span class="line">[root@ouwen666 home]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">nginx        latest    f652ca386ed1   2 weeks ago    141MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 months ago   231MB</span><br><span class="line"># -d 后台运行</span><br><span class="line"># --name 给容器命名</span><br><span class="line"># -p 宿主机端口:容器内部端口 映射端口</span><br><span class="line">[root@ouwen666 home]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">639cb4f9a9e60d96d698f0c1200f216176a3735b40b3276b25af5e8fb502e337</span><br><span class="line">[root@ouwen666 home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS         PORTS                  NAMES</span><br><span class="line">639cb4f9a9e6   nginx     &quot;/docker-entrypoint.…&quot;   10 seconds ago   Up 9 seconds   0.0.0.0:3344-&gt;80/tcp   nginx01</span><br><span class="line">[root@ouwen666 home]# curl localhost:3344</span><br><span class="line"></span><br><span class="line"># 进入容器</span><br><span class="line">[root@ouwen666 home]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@639cb4f9a9e6:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@639cb4f9a9e6:/# cd /etc/nginx/</span><br><span class="line">root@639cb4f9a9e6:/etc/nginx# ls</span><br><span class="line">conf.d	fastcgi_params	mime.types  modules  nginx.conf  scgi_params  uwsgi_params</span><br><span class="line">root@639cb4f9a9e6:/etc/nginx#</span><br></pre></td></tr></table></figure>

<blockquote>
<p>端口暴露：</p>
</blockquote>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218194409.png" alt="image-20211218194409553"></p>
<h4 id="Docker-安装-Tomcat"><a href="#Docker-安装-Tomcat" class="headerlink" title="Docker 安装 Tomcat"></a>Docker 安装 Tomcat</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 官方的使用</span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"># 这种方式停止了容器之后，会直接删除容器</span><br><span class="line"></span><br><span class="line"># 下载再启动</span><br><span class="line">docker pull tomcat:9.0</span><br><span class="line"></span><br><span class="line"># 启动运行</span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0</span><br><span class="line"></span><br><span class="line"># 测试访问没有问题</span><br><span class="line"></span><br><span class="line"># 进入容器内部</span><br><span class="line">[root@ouwen666 home]# docker exec -it tomcat01 /bin/bash</span><br><span class="line">root@b59126dcef8d:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist</span><br><span class="line">CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work</span><br></pre></td></tr></table></figure>

<h4 id="Docker-安装-ElasticSearch-Kibana"><a href="#Docker-安装-ElasticSearch-Kibana" class="headerlink" title="Docker 安装 ElasticSearch + Kibana"></a>Docker 安装 ElasticSearch + Kibana</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 官方的使用</span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line"># es 是十分耗内存的 1.xG 服务器 2核2G</span><br><span class="line"></span><br><span class="line"># 查看 docker stats</span><br><span class="line">[root@ouwen666 home]# docker stats</span><br><span class="line">CONTAINER ID   NAME            CPU %     MEM USAGE / LIMIT     MEM %     NET I/O   BLOCK I/O</span><br><span class="line">b496914b7726   elasticsearch   0.00%     1.237GiB / 1.694GiB   73.00%    0B / 0B   197MB / 729kB</span><br><span class="line"></span><br><span class="line"># 测试一下es是否安装成功</span><br><span class="line">[root@ouwen666 home]# curl localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;b496914b7726&quot;，</span><br><span class="line">  &quot;cluster_name&quot; : &quot;docker-cluster&quot;，</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;v5CISdg4Sw-d8-Jui-XXTw&quot;，</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.6.2&quot;，</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;，</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;，</span><br><span class="line">    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;，</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;，</span><br><span class="line">    &quot;build_snapshot&quot; : false，</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.4.0&quot;，</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;，</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;，</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know， for Search&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 增加对内存的限制 修改配置文件 -e 环境配置的修改</span><br><span class="line">docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line"># 查看 docker stats 内存明显变小</span><br><span class="line">[root@ouwen666 home]# docker stats</span><br><span class="line">CONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT     MEM %    NET I/O      BLOCK I/O</span><br><span class="line">c0d59f8ca889   elasticsearch01   0.00%     375.2MiB / 1.694GiB   21.63%   524B / 942B  107MB/733kB</span><br><span class="line"># 测试是否启动成功</span><br><span class="line">[root@ouwen666 home]# curl localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;c0d59f8ca889&quot;，</span><br><span class="line">  &quot;cluster_name&quot; : &quot;docker-cluster&quot;，</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;ECE4OHoqQ5Sk-fhT-ALuPg&quot;，</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.6.2&quot;，</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;，</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;，</span><br><span class="line">    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;，</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;，</span><br><span class="line">    &quot;build_snapshot&quot; : false，</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.4.0&quot;，</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;，</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;，</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know， for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用 Kibana 连接 ES？</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218201949.png" alt="image-20211218201949070"></p>
<h2 id="Docker-镜像详解"><a href="#Docker-镜像详解" class="headerlink" title="Docker 镜像详解"></a>Docker 镜像详解</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是 image 镜像文件。</p>
<p>只有通过这个镜像文件才能生成 Docker 容器实例(类似 Java 中 new 出来一个对象)。</p>
<p>如何得到镜像：</p>
<ul>
<li>从远程仓库下载</li>
<li>自己制作一个镜像 DockerFile</li>
</ul>
<h3 id="Docker-镜像加载原理"><a href="#Docker-镜像加载原理" class="headerlink" title="Docker 镜像加载原理"></a>Docker 镜像加载原理</h3><blockquote>
<p>UnionFS(联合文件系统)</p>
</blockquote>
<p>Union 文件系统(UnionFS) 是一种分层. 轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union 文件系统是 Docker 镜像的基础。&#x3D;&#x3D;镜像可以通过分层来进行继承&#x3D;&#x3D;，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层文件和目录。</p>
<blockquote>
<p>Docker 镜像加载原理</p>
</blockquote>
<p>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</p>
<p>bootfs(boot file system) 主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel，Linux 刚启动时会加载 bootfs 文件系统，&#x3D;&#x3D;在 Docker 镜像的最底层是 bootfs&#x3D;&#x3D;。这一层与我们典型的 Linux&#x2F;Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就存在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p>
<p>roorfs （root file system），在 bootfs 之上。包含的就是典型 Linux 系统中的 &#x2F;dev ，&#x2F;proc，&#x2F;bin ，&#x2F;etx 等标准的目录和文件。rootfs 就是各种不同的操作系统发行版。比如 Ubuntu，Centos 等等。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218204700.png" alt="image-20211218204700594"></p>
<p>平时安装进虚拟机的 CentOS 镜像都是好几个 G，为什么 Docker 这里才 200M？</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218204834.png" alt="image-20211218204834885"><br>对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令. 工具和程序库就可以了，因为底层直接用 Host（宿主机）的 kernel，自己只需要提供 rootfs 就行了，由此可见对于不同的 Linux 发行版，bootfs 基本是一致的，rootfs 会有差别，因此不同的发行版可以公用 bootfs。</p>
<h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p>下载一个镜像，观察下载的日志，可以发现是一层一层往下下载的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">[root@ouwen666 home]# docker pull redis</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">e5ae68f74026: Already exists</span><br><span class="line">37c4354629da: Pull complete</span><br><span class="line">b065b1b1fa0f: Pull complete</span><br><span class="line">6954d19bb2e5: Pull complete</span><br><span class="line">6333f8baaf7c: Pull complete</span><br><span class="line">f9772c8a44e7: Pull complete</span><br><span class="line">Digest: sha256:2f502d27c3e9b54295f1c591b3970340d02f8a5824402c8179dcd20d4076b796</span><br><span class="line">Status: Downloaded newer image for redis:latest</span><br><span class="line">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么 Docker 镜像要采用这种分层的结构？</p>
</blockquote>
<p>&#x3D;&#x3D;最大的好处，就是是资源共享了！&#x3D;&#x3D;</p>
<p>如有多个镜像都从相同的基本镜像构建而来，那么宿主机只需在磁盘上保留一份基本镜像，同时内存中也只需要加载一份基本镜像 ，这样就可以为所有的容器服务了，且镜像的每一层都可以被共享。</p>
<p>查看镜像分层的方式可以通过<code>docker image inspect</code> 命令！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line">[root@ouwen666 home]# docker image inspect redis</span><br><span class="line">[</span><br><span class="line">...</span><br><span class="line">        &quot;RootFS&quot;: &#123;</span><br><span class="line">            &quot;Type&quot;: &quot;layers&quot;，</span><br><span class="line">            &quot;Layers&quot;: [</span><br><span class="line">                &quot;sha256:9321ff862abbe8e1532076e5fdc932371eff562334ac86984a836d77dfb717f5&quot;，</span><br><span class="line">                &quot;sha256:aa2858ea5edc9c0981901a1b63b49a8f4a6e7099b4304b49e680ffdcc6b71b3e&quot;，</span><br><span class="line">                &quot;sha256:93079bf13a6d5fe7c4bd9f00cb96183f9d1db9968c4bd15b395df2f3867bf8e5&quot;，</span><br><span class="line">                &quot;sha256:9ca504b88e256aa6f6c04ec65aeeed6b926661ea30a0b97f829fbe230155241a&quot;，</span><br><span class="line">                &quot;sha256:9468a3f0498bd5cc298ce25ea6ce9c6adf14aa2ce152856b5f389510a9bb9e01&quot;，</span><br><span class="line">                &quot;sha256:b7851a62867d82784052d7662862adc0b47b2bddcddc89ae78307f75ba1b29ae&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>理解</p>
</blockquote>
<p>所有的 Docker 镜像都起始于一个基础镜像层 ，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像 ，这就是新镜像的第一层。如果在该镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<p>该镜像当前已经包含 3 个镜像层，如下图所示(这只是一个用于演示的很简单的例子 )。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218210259.png" alt="image-20211218210258974"></p>
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。</p>
<p>下图中举 了一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218210445.png" alt="image-20211218210445762"></p>
<p>上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。</p>
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件 7 是文件 5 的一一个更新版本。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218210534.png" alt="image-20211218210534319"></p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p>
<p>Docker 通过存储引擎(新版本采用快照机制)的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<p>Linux 上可用的存储引擎有 AUFS. Overlay2. Device Mapper. Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker 在 Windows 上仅支持 windowsfilter -种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 CoW[1]。</p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218210605.png" alt="image-20211218210605289"></p>
<blockquote>
<p>特点</p>
</blockquote>
<p>Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下都叫镜像层！</p>
<h3 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker commit 提交容器成为一个新的镜像副本</span><br><span class="line"></span><br><span class="line"># 命令和git原理类似</span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<p><strong>实战测试</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 启动一个默认的tomcat</span><br><span class="line"></span><br><span class="line"># 发现默认的tomcat的webapps目录下是没用部署应用的。原因是官方的镜像都是默认webapps下是没有应用的</span><br><span class="line"></span><br><span class="line"># 将webapps.dist目录下的应用拷贝到webapps下</span><br><span class="line"></span><br><span class="line"># 将更改过的镜像提交到仓库，以后就能使用修改过的镜像进行启动！</span><br><span class="line">[root@ouwen666 ~]# docker commit -a=&quot;Irving&quot; -m=&quot;add webapps app&quot; 9bffc8b128c7 mytomcat:1.0</span><br><span class="line">sha256:ef1ba8ee4bba1a39202b89a9bfecc4cb4dfbf20263b6e1b913a4cecf80ff8381</span><br><span class="line">[root@ouwen666 ~]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">mytomcat              1.0       ef1ba8ee4bba   10 seconds ago   685MB</span><br><span class="line">tomcat                9.0       3f3cadde9a68   10 days ago      680MB</span><br><span class="line">redis                 latest    aea9b698d7d1   2 weeks ago      113MB</span><br><span class="line">nginx                 latest    f652ca386ed1   2 weeks ago      141MB</span><br><span class="line">centos                latest    5d0da3dc9764   3 months ago     231MB</span><br><span class="line">portainer/portainer   latest    580c0e4e98b0   9 months ago     79.1MB</span><br><span class="line">elasticsearch         7.6.2     f29a1ee41030   21 months ago    791MB</span><br></pre></td></tr></table></figure>

<h3 id="提交镜像到阿里云"><a href="#提交镜像到阿里云" class="headerlink" title="提交镜像到阿里云"></a>提交镜像到阿里云</h3><p>本地镜像发布到阿里云流程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220612132649.png" alt="image-20220604164136425"></p>
<ol>
<li>登录阿里云控制台，选择容器镜像服务</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220604211156.png" alt="image-20220604211107790"></p>
<ol>
<li>选择个人实例</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220604211320.png" alt="image-20220604211320410"></p>
<ol>
<li>创建命名空间</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220604211651.png" alt="image-20220604211650899"></p>
<ol>
<li>创建镜像仓库</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220604212038.png" alt="image-20220604212038508"></p>
<ol>
<li>继续</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220604212554.png" alt="image-20220604212532015"></p>
<ol>
<li>继续</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220604212648.png" alt="image-20220604212648063"></p>
<ol>
<li>进入管理界面获取脚本</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220604212843.png" alt="image-20220604212843596"></p>
<ol>
<li>将镜像推送到阿里云</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220604213052.png" alt="image-20220604213052191"></p>
<h3 id="提交镜像到私有库"><a href="#提交镜像到私有库" class="headerlink" title="提交镜像到私有库"></a>提交镜像到私有库</h3><p>Docker Registry 是官方提供的工具，可以用于构建私有镜像仓库。</p>
<ol>
<li><strong>下载镜像 Docker Registry</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@88231 ~]# docker pull registry</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">79e9f2f55bf5: Pull complete</span><br><span class="line">0d96da54f60b: Pull complete</span><br><span class="line">5b27040df4a2: Pull complete</span><br><span class="line">e2ead8259a04: Pull complete</span><br><span class="line">3790aef225b9: Pull complete</span><br><span class="line">Digest: sha256:169211e20e2f2d5d115674681eb79d21a217b296b43374b8e39f97fcf866b375</span><br><span class="line">Status: Downloaded newer image for registry:latest</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>运行私有库 Registry，相当于自己搭建一个 Docker Hub</strong></li>
</ol>
<p>默认情况，仓库被创建在容器内的 &#x2F;var&#x2F;lib&#x2F;registry 目录下，建议自行用容器卷映射，方便于宿主机联调</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@88231 hd]# docker run -d -p 5000:5000  -v /hd/docker-registry/:/var/lib/registry --privileged=true registry</span><br><span class="line">96579e94a32238269d25239394f62a7d38492d27834ebb4863fe8d3baea55b77</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>curl 验证私服库上有什么镜像</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XGET http://192.168.88.231:5000/v2/_catalog</span><br></pre></td></tr></table></figure>

<p>可以看到，目前私服库没有任何镜像上传过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@88231 docker-registry]# curl -XGET http://192.168.88.231:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[]&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>提交一个新镜像到私有的 Registry 库</strong></li>
</ol>
<ul>
<li>修改符合私服规范的 Tag</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag 镜像ID Host:Port/Repository:Tag</span><br><span class="line">AUTOIT</span><br><span class="line">[root@88231 docker-registry]# docker tag ba6acccedd29 192.168.88.231:5000/myubuntu:1.0</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件，使之支持 http 上传</li>
</ul>
<p>这里的地址是 registry 私服所在主机的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@88231 docker-registry]# vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://alq7pwwu.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.88.231:5000&quot;]</span><br><span class="line">&#125;</span><br><span class="line"># 重启 docker 生效</span><br><span class="line">[root@88231 docker-registry]# service docker restart</span><br><span class="line">Stopping docker:                                       [  OK  ]</span><br><span class="line">Starting docker:	                                   [  OK  ]</span><br></pre></td></tr></table></figure>

<ul>
<li>push 推送到私服库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AUTOIT</span><br><span class="line"># 使用 docker push 命令推送私服库</span><br><span class="line">[root@88231 docker-registry]# docker push 192.168.88.231:5000/myubuntu:1.0</span><br><span class="line">The push refers to a repository [192.168.88.231:5000/myubuntu]</span><br><span class="line">9f54eef41275: Pushed</span><br><span class="line">1.0: digest: sha256:870c68e5f7e5cac7cb9a747e18865524dbc0952575dcc498621c79b94a78a846 size: 529</span><br><span class="line"></span><br><span class="line"># 使用 curl 查看私服库上的镜像</span><br><span class="line">[root@88231 docker-registry]# curl -XGET http://192.168.88.231:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;myubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>将私服库上的镜像 pull 到本地运行</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVRASM</span><br><span class="line"># 使用 docker pull 命令将私服库上的镜像下载到本地</span><br><span class="line">[root@88231 /]# docker pull 192.168.88.231:5000/myubuntu:1.0</span><br><span class="line">1.0: Pulling from myubuntu</span><br><span class="line">f9945daba3cc: Pull complete</span><br><span class="line">Digest: sha256:870c68e5f7e5cac7cb9a747e18865524dbc0952575dcc498621c79b94a78a846</span><br><span class="line">Status: Downloaded newer image for 192.168.88.231:5000/myubuntu:1.0</span><br></pre></td></tr></table></figure>

<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="什么是容器数据卷？"><a href="#什么是容器数据卷？" class="headerlink" title="什么是容器数据卷？"></a>什么是容器数据卷？</h3><blockquote>
<p>docker 的理念回顾</p>
</blockquote>
<p>将应用和环境打包成一个镜像！</p>
<p>数据都在容器中，如果删除容器，数据就会丢失！&#x3D;&#x3D;数据如何持久化？数据需要存储在本地！&#x3D;&#x3D;</p>
<p>容器之间可以有一个数据共享的技术！Docker 容器中产生的数据，可以同步到本地！</p>
<p>这就是卷技术！其本质就是目录的挂载，将容器内的目录，挂载到 Linux 上！</p>
<h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><blockquote>
<p>&#x3D;&#x3D;坑！使用容器数据卷时记得加入：–privileged&#x3D;true&#x3D;&#x3D;</p>
<p>Docker 挂载主机目录访问如果出现 cannot open directory: Permission denied<br>解决办法：在挂载目录后多加一个–privileged&#x3D;true 参数即可</p>
<p>如果是 CentOS7 安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，<br>在 SELinux 里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged&#x3D;true 命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container 内的 root 拥有真正的 root 权限，否则，container 内的 root 只是外部的一个普通用户权限。</p>
</blockquote>
<blockquote>
<p>方式一：直接使用命令来挂载 -v</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker run -it -v 主机目录:容器内目录</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">[root@ouwen666 ~]# docker run -it -v /home/ceshi:/home --privileged=true centos /bin/bash</span><br><span class="line"></span><br><span class="line"># 启动成功后查看详细信息</span><br><span class="line">[root@ouwen666 ceshi]# docker inspect 015ee9a39cf1</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219162714.png" alt="image-20211219162714621"></p>
<p>测试文件的同步</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219163426.png" alt="image-20211219163426342"><br>继续测试！</p>
<ol>
<li>停止容器</li>
<li>宿主机上修改文件</li>
<li>启动并进入容器</li>
<li>发现容器内的数据跟宿主机是同步的！</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219163920.png" alt="image-20211219163920495"></p>
<blockquote>
<p>好处：修改只需要在本地修改即可，容器内会自动同步！</p>
</blockquote>
<h3 id="实战：安装-MySQL"><a href="#实战：安装-MySQL" class="headerlink" title="实战：安装 MySQL"></a>实战：安装 MySQL</h3><p>思考：MySQL 的数据持久化问题！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 获取镜像</span><br><span class="line">[root@ouwen666 ~]# docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"># 运行容器，需要做数据挂载！ # 安装启动mysql，需要配置密码的</span><br><span class="line"># 官方命令: docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line"></span><br><span class="line"># 启动mysql</span><br><span class="line">docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"># 命令解释</span><br><span class="line">-d  后台运行</span><br><span class="line">-p  端口映射</span><br><span class="line">-v  卷挂载</span><br><span class="line">-e  环境配置</span><br><span class="line">--name 容器名字</span><br><span class="line"></span><br><span class="line"># 启动成功，通过Navicat连接测试！</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219171950.png" alt="image-20211219171950528"><br>用 Navicat 建一个数据库</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219193046.png" alt="image-20211219193046702"></p>
<p>服务器上映射的路径下，出现了同名文件</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219193150.png" alt="image-20211219193150622"></p>
<p>将容器删除，发现 <code>/home/mysql/data</code> 目录下的文件还是存在的。这就实现了容器数据持久化！</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219193417.png" alt="image-20211219193417029"></p>
<h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 匿名挂载</span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"></span><br><span class="line"># 查看所有 volume 的情况</span><br><span class="line">[root@ouwen666 data]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     5370f027b4d5a86a9718f66c9bc9c39138aa92ad2b6368a74f930c09f94c52bb</span><br><span class="line"></span><br><span class="line"># 这里发现 volume name 是一串乱码，是因为我们挂载时没有指定名字。这就是匿名挂载。我们在 -v 时只写了容器内路径，没有写容器外路径！</span><br><span class="line"></span><br><span class="line"># 具名挂载</span><br><span class="line">[root@ouwen666 data]# docker run -d -P --name nginx02 -v nginxvolumename:/etc/nginx nginx</span><br><span class="line">11ba9ffded8187484386ff37103c91a6a2bd2e103420b9376c45c61f604dab57</span><br><span class="line">[root@ouwen666 data]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     nginxvolumename</span><br><span class="line"></span><br><span class="line"># 通过 -v 卷名:容器内路径 完成具名挂载</span><br><span class="line"># 查看这个卷的具体信息 inspect</span><br><span class="line">[root@ouwen666 data]# docker volume inspect nginxvolumename</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2021-12-19T19:44:11+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/nginxvolumename/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;nginxvolumename&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有的 docker 容器内的卷，没有指定目录的情况下都是在 <code>/var/lib/docker/volumes/xxx/_data</code> 下！</p>
<p>通过具名挂载可以方便地找到卷所在的位置，大多数请况下使用 <code>具名挂载</code> ！</p>
</blockquote>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219194814.png" alt="image-20211219194814407"></p>
<p><strong>如何确定是具名挂载. 匿名挂载还是指定路径挂载？</strong></p>
<ul>
<li><code>-v 容器内路径</code> 匿名挂载</li>
<li><code>-v 卷名:容器内路径</code> 具名挂载</li>
<li><code>-v /宿主机路径:容器内路径</code> 指定路径挂载</li>
</ul>
<p>拓展：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 通过 -v 容器内路径:ro/rw  改变读写权限</span><br><span class="line">ro   readonly  # 只读</span><br><span class="line">rw   readwrite # 可读可写</span><br><span class="line"></span><br><span class="line"># 例如</span><br><span class="line">docker run -d -P --name nginx02 -v nginxvolumename:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx02 -v nginxvolumename:/etc/nginx:rw nginx</span><br><span class="line"></span><br><span class="line"># 一旦设置了ro，就说这个路径只能通过映射后宿主机的来操作，容器内部是无法操作的！</span><br></pre></td></tr></table></figure>

<h3 id="初识-DockerFile"><a href="#初识-DockerFile" class="headerlink" title="初识 DockerFile"></a>初识 DockerFile</h3><p>DockerFile 就是用来构建 docker 镜像的构建文件！其实就是一段命令脚本！</p>
<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 创建一个dockerfile文件，名字可以随意 建议 Dockerfile</span><br><span class="line">[root@ouwen666 docker-test]# vim Dockerfile</span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;-----end-----&quot;</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"># 通过Dockerfile构建一个属于自己的镜像 注意末尾有一个 . 代表当前路径</span><br><span class="line">[root@ouwen666 docker-test]# docker build -f /home/docker-test/Dockerfile -t irving/centos:1.0 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM centos</span><br><span class="line"> ---&gt; 5d0da3dc9764</span><br><span class="line">Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"> ---&gt; Running in e121337bcbbe</span><br><span class="line">Removing intermediate container e121337bcbbe</span><br><span class="line"> ---&gt; 2e6cad23ca38</span><br><span class="line">Step 3/4 : CMD echo &quot;-----end-----&quot;</span><br><span class="line"> ---&gt; Running in 7025e750f7ac</span><br><span class="line">Removing intermediate container 7025e750f7ac</span><br><span class="line"> ---&gt; cf376f17795b</span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"> ---&gt; Running in 60e0bccacc5d</span><br><span class="line">Removing intermediate container 60e0bccacc5d</span><br><span class="line"> ---&gt; 2aee0e7445ac</span><br><span class="line">Successfully built 2aee0e7445ac</span><br><span class="line">Successfully tagged irving/centos:1.0</span><br><span class="line"></span><br><span class="line"># 查看生成的镜像</span><br><span class="line">[root@ouwen666 docker-test]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">irving/centos         1.0       2aee0e7445ac   2 minutes ago   231MB</span><br><span class="line">mytomcat              1.0       ef1ba8ee4bba   4 hours ago     685MB</span><br><span class="line">tomcat                9.0       3f3cadde9a68   10 days ago     680MB</span><br><span class="line">redis                 latest    aea9b698d7d1   2 weeks ago     113MB</span><br><span class="line">mysql                 5.7       738e7101490b   2 weeks ago     448MB</span><br><span class="line">nginx                 latest    f652ca386ed1   2 weeks ago     141MB</span><br><span class="line">centos                latest    5d0da3dc9764   3 months ago    231MB</span><br><span class="line">portainer/portainer   latest    580c0e4e98b0   9 months ago    79.1MB</span><br><span class="line">elasticsearch         7.6.2     f29a1ee41030   21 months ago   791MB</span><br><span class="line"></span><br><span class="line"># 使用刚刚生成的镜像启动一个容器</span><br><span class="line">[root@ouwen666 docker-test]# docker run -it 2aee0e7445ac /bin/bash</span><br><span class="line">[root@b2707d29bda4 /]#</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219203120.png" alt="image-20211219203120341"></p>
<p>这个挂载的卷目录一定和外部有一个同步的目录！</p>
<p>通过 <code>docker inspect 容器ID</code> 查看具体信息</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219203438.png" alt="image-20211219203438140"></p>
<p>发现确实是在 <code>/var/lib/docker/volumes/</code> 目录下的一个随机目录下！</p>
<h3 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h3><blockquote>
<p>图解</p>
</blockquote>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211219203754.png" alt="image-20211219203754331"></p>
<blockquote>
<p>测试！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 启动三个容器！通过刚刚自己制作的镜像启动</span><br><span class="line"></span><br><span class="line"># 第一个容器 docker01</span><br><span class="line">[root@ouwen666 ~]# docker run -it --name docker01 irving/centos:1.0</span><br><span class="line">[root@9e033da9de3e /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01	volume02</span><br><span class="line"></span><br><span class="line"># 第二个容器 docker02 通过 --volumes-from 挂载 docker01 容器</span><br><span class="line">[root@ouwen666 ~]# docker run -it --name docker02 --volumes-from docker01 irving/centos:1.0</span><br><span class="line">[root@75fb856af436 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01	volume02</span><br><span class="line"></span><br><span class="line"># docker01 创建的文件同步到 docker02 容器上了</span><br><span class="line">[root@ouwen666 ~]# docker attach docker01</span><br><span class="line">[root@9e033da9de3e /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01	volume02</span><br><span class="line">[root@9e033da9de3e /]# cd volume01</span><br><span class="line">[root@9e033da9de3e volume01]# ls</span><br><span class="line">[root@9e033da9de3e volume01]# touch docker01</span><br><span class="line">[root@9e033da9de3e volume01]# ls</span><br><span class="line">docker01</span><br><span class="line"></span><br><span class="line">[root@ouwen666 /]# docker attach docker02</span><br><span class="line">[root@75fb856af436 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01	volume02</span><br><span class="line">[root@75fb856af436 /]# cd volume01</span><br><span class="line">[root@75fb856af436 volume01]# ls</span><br><span class="line">docker01</span><br><span class="line"></span><br><span class="line"># 第三个容器 docker03 也通过 --volumes-from 挂载 docker01</span><br><span class="line">[root@ouwen666 ~]# docker run -it --name docker03 --volumes-from docker01 irving/centos:1.0</span><br><span class="line">[root@eda4d0cad3f0 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01	volume02</span><br><span class="line">[root@eda4d0cad3f0 /]# cd volume01</span><br><span class="line">[root@eda4d0cad3f0 volume01]# ls</span><br><span class="line">docker01</span><br><span class="line"></span><br><span class="line"># 发现文件还是同步过来，在 docker03 中新建一个文件</span><br><span class="line">[root@eda4d0cad3f0 volume01]# touch docker03</span><br><span class="line">[root@eda4d0cad3f0 volume01]# ls</span><br><span class="line">docker01  docker03</span><br><span class="line"></span><br><span class="line"># 进入 docker01 容器，发现 docker03 中创建的文件也同步过来了！</span><br><span class="line">[root@ouwen666 /]# docker attach docker01</span><br><span class="line">[root@9e033da9de3e /]# cd volume01</span><br><span class="line">[root@9e033da9de3e volume01]# ls</span><br><span class="line">docker01  docker03</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论</p>
</blockquote>
<p>只要通过 <code>--volumes-from</code> 就可以做到容器间的数据共享！</p>
<p>思考：删除 docker01，查看 docker02. docker03 是否还能访问这些文件</p>
<p>依旧可以访问！本质上是一种数据拷贝，而不是单纯的数据共享！</p>
<p>容器之间配置信息的传递，数据卷容器的生命周期可以一直持续到没有人使用为止！</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统基础</title>
    <url>/2022/04/11/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux%20%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h2><blockquote>
<p>我们为什么要学习 Linux？</p>
</blockquote>
<p>linux 诞生了这么多年，以前还喊着如何能取代 windows 系统，现在这个口号已经小多了，任何事物发展都有其局限性都有其天花板。就如同在国内再搞一个社交软件取代腾讯一样，想想而已基本不可能，因为用户已经习惯于使用微信交流，不是说技术上实现不了解而是老百姓已经习惯了，想让他们不用，即使他们自己不用亲戚朋友还是要用，没有办法的事情。</p>
<p>用习惯了 windows 操作系统，再让大家切换到别的操作系统基本上是不可能的事情，改变一个人已经养成的习惯太难。没有办法深入到普通老百姓的生活中，并不意味着 linux 就没有用武之地了。在服务器端，在开发领域 linux 倒是越来越受欢迎，很多程序员都觉得不懂点 linux 都觉得不好意思，linux 在开源社区的地位依然岿然不动。</p>
<p>尤其是作为一个后端程序员，是必须要掌握 Linux 的，因为这都成为了你找工作的基础门槛了，所以不得不学习！</p>
<blockquote>
<p>Linux 简介</p>
</blockquote>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p>
<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<blockquote>
<p>Linux 发行版</p>
</blockquote>
<p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421091705.jpeg"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421091705.jpeg" alt="img"></a></p>
<p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421091730.jpeg"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421091730.jpeg" alt="img"></a></p>
<blockquote>
<p>Linux 应用领域</p>
</blockquote>
<p>今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p>
<p>目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。</p>
<ul>
<li>巴西联邦政府由于支持 Linux 而世界闻名。</li>
<li>有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。</li>
<li>印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。</li>
<li>中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。</li>
<li>在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。</li>
<li>葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。</li>
<li>法国和德国同样开始逐步采用 Linux。</li>
</ul>
<blockquote>
<p>Linux VS Windows</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421092008.jpeg"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421092008.jpeg" alt="img"></a></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>省略…</p>
<h2 id="走进-Linux-系统"><a href="#走进-Linux-系统" class="headerlink" title="走进 Linux 系统"></a>走进 Linux 系统</h2><blockquote>
<p>开机登录</p>
</blockquote>
<p>开机会启动许多程序。它们在 Windows 叫做”服务”（service），在 Linux 就叫做”守护进程”（daemon）。</p>
<p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给 login 程序来验证用户的身份，密码是不显示的，输完回车即可！</p>
<p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>命令行登录</li>
<li>ssh 登录</li>
<li>图形界面登录</li>
</ul>
<p>最高权限账户为 root，可以操作一切！</p>
<blockquote>
<p>关机</p>
</blockquote>
<p>在 linux 领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p>
<p>关机指令为：shutdown：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">sync # 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –h now # 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 # 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 # 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now # 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 # 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot # 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt # 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure>

<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p>
<blockquote>
<p>系统目录结构</p>
</blockquote>
<p>登录系统后，在当前命令窗口下输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">ls /</span><br></pre></td></tr></table></figure>

<p>你会看到如下图所示：</p>
<p>本地虚拟机：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421095447.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421095447.png" alt="image-20210421095447557"></a></p>
<p>云服务器：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421095548.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421095548.png" alt="img"></a></p>
<p>树状目录结构：（Linux 的一切资源都挂载在这个 &#x2F; 根节点下）</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421095524.jpeg"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421095524.jpeg" alt="img"></a></p>
<p><strong>以下是对这些目录的解释：</strong></p>
<ul>
<li><code>/bin</code>：bin 是 Binary 的缩写, 这个目录存放着最经常使用的命令。</li>
<li><code>/boot</code>： 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><code>/dev</code> ： dev 是 Device(设备)的缩写, 存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</li>
<li>&#x3D;&#x3D;<code>/etc</code>： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<code>/home</code>：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。&#x3D;&#x3D;</li>
<li><code>/lib</code>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。</li>
<li><code>/lost+found</code>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li><code>/media</code>：linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。</li>
<li><code>/mnt</code>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</li>
<li>&#x3D;&#x3D;<code>/opt</code>：这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。&#x3D;&#x3D;</li>
<li><code>/proc</code>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
<li>&#x3D;&#x3D;<code>/root</code>：该目录为系统管理员，也称作超级权限者的用户主目录。&#x3D;&#x3D;</li>
<li><code>/sbin</code>：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><code>/srv</code>：该目录存放一些服务启动之后需要提取的数据。</li>
<li><code>/sys</code>：这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</li>
<li>&#x3D;&#x3D;<code>/tmp</code>：这个目录是用来存放一些临时文件的。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<code>/usr</code>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。&#x3D;&#x3D;</li>
<li><code>/usr/bin</code>： 系统用户使用的应用程序。</li>
<li><code>/usr/sbin</code>： 超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><code>/usr/src</code>： 内核源代码默认的放置目录。</li>
<li>&#x3D;&#x3D;<code>/var</code>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。&#x3D;&#x3D;</li>
<li><code>/run</code>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li>
<li><code>/www</code>：存放服务器网站相关的资源，环境，网站的项目</li>
</ul>
<h2 id="常用的基本命令"><a href="#常用的基本命令" class="headerlink" title="常用的基本命令"></a>常用的基本命令</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><blockquote>
<p>绝对路径、相对路径</p>
</blockquote>
<p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p>
<p>常用的：</p>
<ul>
<li><code>cd</code>：切换目录命令</li>
<li><code>./</code>：当前目录</li>
<li><code>cd ..</code>：返回上一级目录</li>
</ul>
<p><strong>绝对路径：</strong></p>
<p>路径的写法，由根目录 &#x2F; 写起，例如：&#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p>
<p><strong>相对路径：</strong></p>
<p>路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成：cd ..&#x2F;man 这就是相对路径的写法啦！</p>
<blockquote>
<p>处理目录的常用命令</p>
</blockquote>
<p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li><code>ls</code>: 列出目录</li>
<li><code>cd</code>：切换目录</li>
<li><code>pwd</code>：显示目前的目录</li>
<li><code>mkdir</code>：创建一个新的目录</li>
<li><code>rmdir</code>：删除一个空的目录</li>
<li><code>cp</code>: 复制文件或目录</li>
<li><code>rm</code>: 移除文件或目录</li>
<li><code>mv</code>: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<blockquote>
<p>ls - 列出目录</p>
</blockquote>
<p>在 Linux 系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-a</strong> ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li><strong>-l</strong> ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<p>将目录下的所有文件列出来(含属性与隐藏档)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cd - 切换目录</p>
</blockquote>
<p>cd 是 Change Directory 的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pwd - 显示当前所在的目录</p>
</blockquote>
<p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@kuangshen kuangstudy]#pwd [-P]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mkdir - 创建新目录</p>
</blockquote>
<p>如果想要创建新的目录的话，那么就使用 mkdir (make directory)吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-m</strong> ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li><strong>-p</strong> ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<blockquote>
<p>rmdir - 删除空目录</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p>
<p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会学到！</p>
<blockquote>
<p>cp - 复制文件或目录</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-a</strong>：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-p</strong>：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-d</strong>：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li><strong>-r</strong>：递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-f</strong>：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i</strong>：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l</strong>：进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li>
<li><strong>-s</strong>：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u</strong>：若 destination 比 source 旧才升级 destination ！</li>
</ul>
<blockquote>
<p>rm - 移除文件&#x2F;目录</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-f</strong> ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li><strong>-i</strong> ：互动模式，在删除前会询问使用者是否动作</li>
<li><strong>-r</strong> ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<blockquote>
<p>mv - 移动文件或目录&#x2F;修改名称</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-f</strong> ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li><strong>-i</strong> ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li><strong>-u</strong> ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><blockquote>
<p>看懂文件属性</p>
</blockquote>
<p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在 Linux 中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421201636.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421201636.png" alt="image-20210421201636835"></a></p>
<p>实例中，boot 文件的第一个属性用”d”表示。”d”在 Linux 中代表该文件是一个目录文件。</p>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li><strong>当为[ d ]则是目录</strong></li>
<li><strong>当为[ - ]则是文件</strong></li>
<li><strong>若是[ l ]则表示为链接文档 ( link file )</strong></li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p>
<p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p>
<p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p>
<p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421224446.jpeg"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210421224446.jpeg" alt="img"></a></p>
<p>从左至右用 0-9 这些数字来表示。</p>
<p>第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限，第 7-9 位确定其他用户拥有该文件的权限。</p>
<p>其中：</p>
<p>第 1、4、7 位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p>
<p>第 2、5、8 位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p>
<p>第 3、6、9 位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在 Linux 系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux 系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p>
<blockquote>
<p>修改文件属性</p>
</blockquote>
<p><strong>1、chgrp：更改文件属组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R 的参数，那么该目录下的所有文件的属组都会更改。</p>
<p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;<strong>3、chmod：更改文件 9 个属性</strong>&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<p>Linux 文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux 文件的基本权限就有九个，分别是 owner&#x2F;group&#x2F;others 三种身份各有自己的 read&#x2F;write&#x2F;execute 权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">r:4      w:2         x:1</span><br></pre></td></tr></table></figure>

<p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p>
<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">chmod 770 filename</span><br></pre></td></tr></table></figure>

<h3 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h3><p>Linux 系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>&#x3D;&#x3D;<code>cat</code> 由第一行开始显示文件内容&#x3D;&#x3D;</li>
<li><code>tac</code>从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>&#x3D;&#x3D;<code>nl</code>显示的时候，顺道输出行号！&#x3D;&#x3D;</li>
<li><code>more</code>一页一页的显示文件内容（空格代表翻页，enter 代表向下看一行，:f 行号）</li>
<li>&#x3D;&#x3D;<code>less</code>与<code>more</code> 类似，但是比 <code>more</code>更好的是，他可以往前翻页！（空格翻页，上下键翻页，退出是 q 命令，查询字符串 &#x2F; 要查询的字符串向下查询，向上查询使用 ? 要查询的字符串，n 向下寻找，N 向上寻找 ）&#x3D;&#x3D;</li>
<li><code>head</code>只看头几行 通过-n 参数来控制显示几行</li>
<li><code>tail</code>只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：<code>man cp</code>。</p>
<blockquote>
<p>cat - 由第一行开始显示文件内容</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<blockquote>
<p>tac - 由最后一行开始显示文件内容</p>
</blockquote>
<p>tac 与 cat 命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">[root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nl - 显示行号</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<blockquote>
<p>more - 一页一页翻动</p>
</blockquote>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter ：代表向下翻『一行』；</li>
<li>&#x2F;字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f ：立刻显示出档名以及目前显示的行数；</li>
<li>q ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<blockquote>
<p>less - 一页一页翻动</p>
</blockquote>
<p>less 运行时可以输入的命令有：</p>
<ul>
<li>空白键 ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>&#x2F;字串 ：向下搜寻『字串』的功能；</li>
<li>?字串 ：向上搜寻『字串』的功能；</li>
<li>n ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>N ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>q ：离开 less 这个程序；</li>
</ul>
<blockquote>
<p>head - 取出文件前面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">head [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p>
<blockquote>
<p>tail - 取出文件后面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">tail [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p>
<blockquote>
<p>拓展：Linux 链接的概念（了解即可）</p>
</blockquote>
<p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p>
<p>情况下，ln 命令产生硬链接。</p>
<p><strong>硬连接</strong></p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p><strong>软连接</strong></p>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<h3 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h3><blockquote>
<p>什么是 Vim 编辑器</p>
</blockquote>
<p>Vim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p>
<p>vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>vim 键盘图：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210422001208.jpeg"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210422001208.jpeg" alt="img"></a></p>
<blockquote>
<p>三种使用模式</p>
</blockquote>
<p>基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是：</p>
<p><strong>命令模式：</strong></p>
<p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。（如果是编辑模式，需要先退出编辑模式<code>esc</code>）</li>
</ul>
<p>若想要编辑文本：启动 Vim，进入了命令模式，按下 i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<p><strong>输入模式：</strong></p>
<p>在命令模式下按下 i 就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li>字符按键以及 Shift 组合，输入字符</li>
<li>ENTER，回车键，换行</li>
<li>BACK SPACE，退格键，删除光标前一个字符</li>
<li>DEL，删除键，删除光标后一个字符</li>
<li>方向键，在文本中移动光标</li>
<li>HOME&#x2F;END，移动光标到行首&#x2F;行尾</li>
<li>Page Up&#x2F;Page Down，上&#x2F;下翻页</li>
<li>Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>
<li>ESC，退出输入模式，切换到命令模式</li>
</ul>
<p><strong>底线命令模式</strong></p>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li><strong>q</strong> 退出程序</li>
<li><strong>w</strong> 保存文件</li>
</ul>
<p>按 ESC 键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210422001803.jpeg"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210422001803.jpeg" alt="img"></a></p>
<blockquote>
<p>Vim 按键说明</p>
</blockquote>
<p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<h3 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h3><blockquote>
<p>简介</p>
</blockquote>
<p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<blockquote>
<p>用户账号的管理</p>
</blockquote>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录 Shell 等资源。</p>
<blockquote>
<p>添加账号 - useradd</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>选项 :<ul>
<li>-c comment 指定一段注释性描述</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录</li>
<li>-g 用户组 指定用户所属的用户组</li>
<li>-G 用户组，用户组 指定用户所属的附加组</li>
<li>-m 　使用者目录如不存在则自动建立</li>
<li>-s Shell 文件 指定用户的登录 Shell</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号</li>
</ul>
</li>
<li>用户名 :<ul>
<li>指定新账号的登录名</li>
</ul>
</li>
</ul>
<blockquote>
<p>切换用户</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">su username #username:需要切换的用户名</span><br><span class="line">sudo su #普通用户切换到root用户</span><br></pre></td></tr></table></figure>

<ol>
<li>切换用户的命令为：su username 【username 是你的用户名哦】</li>
<li>从普通用户切换到 root 用户，还可以使用命令：sudo su</li>
<li>在终端输入 exit 或 logout 或使用快捷方式 ctrl+d，可以退回到原来用户，其实 ctrl+d 也是执行的 exit 命令</li>
<li>在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在 su 和 username 之间加-，例如：【su - root】</li>
</ol>
<p>&#x3D;&#x3D;$ 表示普通用户&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;#表示超级用户，也就是 root 用户&#x3D;&#x3D;</p>
<blockquote>
<p>删除用户 - userdel</p>
</blockquote>
<p>如果一个用户的账号不再使用，可以从系统中删除。</p>
<p>删除用户账号就是要将&#x2F;etc&#x2F;passwd 等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用 userdel 命令，其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARDUINO</span><br><span class="line">[root@kuangshen home]# userdel -r 用户名</span><br></pre></td></tr></table></figure>

<p>此命令删除用户 kuangshen 在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group 等）的记录，同时删除用户的主目录。</p>
<blockquote>
<p>修改用户 - usermod</p>
</blockquote>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录 Shell 等。</p>
<p>修改已有用户的信息使用 usermod 命令，其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u 以及-o 等，这些选项的意义与 useradd 命令中的选项一样，可以为用户指定新的资源值。</p>
<blockquote>
<p>用户密码的管理</p>
</blockquote>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的 Shell 命令是 passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p>
<p>命令的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>命令修改该用户自己的口令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">$ passwd</span><br><span class="line">Old password:******</span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># passwd kuangshen</span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>普通用户修改自己的口令时，passwd 命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用 8 位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># passwd -d kuangshen</span><br></pre></td></tr></table></figure>

<p>此命令将用户 kuangshen 的口令删除，这样用户 kuangshen 下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># passwd -l kuangshen</span><br></pre></td></tr></table></figure>

<h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。&#x3D;&#x3D;组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group 文件的更新。&#x3D;&#x3D;</p>
<blockquote>
<p>添加用户组 - groupadd</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">groupadd 选项 用户组</span><br><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID 相同。</li>
</ul>
<blockquote>
<p>删除用户组 - groupdel</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改用户组 - groupmod</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。</li>
<li>-n 新用户组 将用户组的名字改为新名字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 此命令将组group2的组标识号修改为102。</span><br><span class="line">groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line"># 将组group2的标识号改为10000，组名修改为group3。</span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>切换组</p>
</blockquote>
<p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p>
<p>用户可以在登录后，使用命令 newgrp 切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到 root 用户组，前提条件是 root 用户组确实是该用户的主组或附加组。</p>
<blockquote>
<p>&#x2F;etc&#x2F;passwd</p>
</blockquote>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group 等。</p>
<p>下面分别介绍这些文件的内容。</p>
<p>&#x2F;etc&#x2F;passwd 文件是用户管理工作涉及的最重要的一个文件。</p>
<p>Linux 系统中的每个用户都在&#x2F;etc&#x2F;passwd 文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DTS</span><br><span class="line">＃ cat /etc/passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:/:</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，&#x2F;etc&#x2F;passwd 中一行记录对应着一个用户，每行记录又被冒号(:)分隔为 7 个字段，其格式和具体含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOCKERFILE</span><br><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>

<p>1）”用户名”是代表用户账号的字符串。</p>
<p>通常长度不超过 8 个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<p>2）“口令”一些系统中，存放着加密后的用户口令字。</p>
<p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd 文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多 Linux 系统（如 SVR4）都使用了 shadow 技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow 文件中，而在&#x2F;etc&#x2F;passwd 文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录 Shell 等。</p>
<p>通常用户标识号的取值范围是 0 ～ 65 535。0 是超级用户 root 的标识号，1 ～ 99 由系统保留，作为管理账号，普通用户的标识号从 100 开始。在 Linux 系统中，这个界限是 500。</p>
<p>4）“组标识号”字段记录的是用户所属的用户组。</p>
<p>它对应着&#x2F;etc&#x2F;group 文件中的一条记录。</p>
<p>5)“注释性描述”字段记录着用户的一些个人情况。</p>
<p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的 Linux 系统中，这个字段的格式并没有统一。在许多 Linux 系统中，这个字段存放的是一段任意的注释性描述文字，用作 finger 命令的输出。</p>
<p>6)“主目录”，也就是用户的起始工作目录。</p>
<p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即 Shell。</p>
<p>Shell 是用户与 Linux 系统之间的接口。Linux 的 Shell 有许多种，每种都有不同的特点。常用的有 sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个 Shell。如果不指定 Shell，那么系统使用 sh 为默认的登录 Shell，即这个字段的值为&#x2F;bin&#x2F;sh。</p>
<p>用户的登录 Shell 也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些 Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<p>8)系统中有一类用户称为伪用户（pseudo users）。</p>
<p>这些用户在&#x2F;etc&#x2F;passwd 文件中也占有一条记录，但是不能登录，因为它们的登录 Shell 为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POWERSHELL</span><br><span class="line">伪 用 户 含 义</span><br><span class="line">bin 拥有可执行的用户命令文件</span><br><span class="line">sys 拥有系统文件</span><br><span class="line">adm 拥有帐户文件</span><br><span class="line">uucp UUCP使用</span><br><span class="line">lp lp或lpd子系统使用</span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;etc&#x2F;shadow</p>
</blockquote>
<p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet 等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于&#x2F;etc&#x2F;passwd 文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的 Linux 系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是&#x2F;etc&#x2F;shadow 文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、&#x2F;etc&#x2F;shadow 中的记录行与&#x2F;etc&#x2F;passwd 中的一一对应，它由 pwconv 命令根据&#x2F;etc&#x2F;passwd 中的数据自动产生</strong></p>
<p>它的文件格式与&#x2F;etc&#x2F;passwd 类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAKEFILE</span><br><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>

<ol>
<li>“登录名”是与&#x2F;etc&#x2F;passwd 文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，长度为 13 个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在 SCO Linux 中，这个时间起点是 1970 年 1 月 1 日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<blockquote>
<p>&#x2F;etc&#x2F;group</p>
</blockquote>
<p>用户组的所有信息都存放在&#x2F;etc&#x2F;group 文件中。</p>
<p>将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在&#x2F;etc&#x2F;passwd 文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用 newgrp 命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在&#x2F;etc&#x2F;group 文件中。此文件的格式也类似于&#x2F;etc&#x2F;passwd 文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAKEFILE</span><br><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>

<ol>
<li>“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd 中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般 Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表&#x2F;b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><blockquote>
<p>概述</p>
</blockquote>
<p>Linux 磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux 磁盘管理常用命令为 df、du。</p>
<ul>
<li>df ：列出文件系统的整体磁盘使用量</li>
<li>du：检查磁盘空间使用量</li>
</ul>
<blockquote>
<p>df</p>
</blockquote>
<p>df 命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">df [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<blockquote>
<p>du</p>
</blockquote>
<p>Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和 df 命令有一些区别的，这里介绍 Linux du 命令。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">du [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
<blockquote>
<p>磁盘挂载与卸除</p>
</blockquote>
<p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”</p>
<p>Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令。</p>
<p>磁盘挂载语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure>

<p>磁盘卸载命令 umount 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li>
<li>-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。</li>
</ul>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><blockquote>
<p>什么是进程</p>
</blockquote>
<ol>
<li>在 Linux 中，每一个程序都是有自己的一个进程，每一个进程都有一个 id 号！</li>
<li>每一个进程都会有一个父进程！</li>
<li>进程可以有两种存在方式：前台！后台运行！</li>
<li>一般的话服务都是后台运行，基本的程序都是前台进行的！</li>
</ol>
<blockquote>
<p>命令</p>
</blockquote>
<p><code>ps</code> 查看当前系统中正在执行的各种进程信息</p>
<p>参数选项：</p>
<ul>
<li>-A 显示当前终端运行的所有的进程信息</li>
<li>-u 以用户的信息显示进程</li>
<li>-x 显示后台运行的参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># ps -aux 查看所有的进程</span><br><span class="line">ps -aux|</span><br><span class="line"></span><br><span class="line"># | 在Linux中叫做管道符 A|B</span><br><span class="line"># grep 查找文件中符合条件的字符串</span><br></pre></td></tr></table></figure>

<p><strong>ps -ef</strong> ：可以查到父进程的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">ps -ef|grep mysql #看父进程我们一般通过目录树结构来查看！</span><br><span class="line"></span><br><span class="line">#进程树</span><br><span class="line">pstree -pu</span><br><span class="line">     -p 显示父id</span><br><span class="line">     -u 显示用户组</span><br></pre></td></tr></table></figure>

<p>结束进程：杀掉进程，等价于 window 结束任务</p>
<p><strong>kill -9</strong> 进程的 id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MapStruct 对象转换</title>
    <url>/2022/07/02/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/MapStruct%20%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着微服务和分布式应用程序迅速占领开发领域，数据完整性和安全性比以往任何时候都更加重要。在这些松散耦合的系统之间，安全的通信渠道和有限的数据传输是最重要的。大多数时候，终端用户或服务不需要访问模型中的全部数据，而只需要访问某些特定的部分。</p>
<p>数据传输对象(Data Transfer Objects, DTO)经常被用于这些应用中。DTO 只是持有另一个对象中被请求的信息的对象。通常情况下，这些信息是有限的一部分。例如，在持久化层定义的实体和发往客户端的 DTO 之间经常会出现相互之间的转换。由于 DTO 是原始对象的反映，因此这些类之间的映射器在转换过程中扮演着关键角色。</p>
<p>这就是 MapStruct 解决的问题：手动创建 bean 映射器非常耗时。 但是该库可以自动生成 Bean 映射器类。</p>
<h2 id="简介-MapStruct"><a href="#简介-MapStruct" class="headerlink" title="简介 MapStruct"></a>简介 MapStruct</h2><p>MapStruct 是一个开源的基于 Java 的代码生成器，用于创建实现 Java Bean 之间转换的扩展映射器。使用 MapStruct，我们只需要创建接口，而该库会通过注解在编译过程中自动创建具体的映射实现，大大减少了通常需要手工编写的样板代码的数量。</p>
<h2 id="MapStruct-依赖"><a href="#MapStruct-依赖" class="headerlink" title="MapStruct 依赖"></a><strong>MapStruct 依赖</strong></h2><p><strong>如果你使用</strong><code>**Maven**</code><strong>的话，可以通过引入依赖安装</strong><code>**MapStruct**</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>这个依赖项会导入<code>MapStruct</code>的核心注释。由于<code>MapStruct</code>在编译时工作，并且会集成到像<code>Maven</code>和<code>Gradle</code>这样的构建工具上，我们还必须在标签中添加一个插件<code>maven-compiler-plugin</code>，并在其配置中添加<code>annotationProcessorPaths</code>，该插件会在构建时生成对应的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                &lt;annotationProcessorPaths&gt;</span><br><span class="line">                    &lt;path&gt;</span><br><span class="line">                        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt;</span><br><span class="line">                    &lt;/path&gt;</span><br><span class="line">                &lt;/annotationProcessorPaths&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>**[MapStruct](<a href="https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A%22org.mapstruct">https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct</a>“ AND a%3A”mapstruct”)<strong>及其</strong>[处理器](<a href="https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A%22org.mapstruct">https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct</a>“ AND a%3A”mapstruct-processor”)<strong>的最新稳定版本都可以从</strong><a href="https://link.zhihu.com/?target=https://search.maven.org/search?q=g:org.mapstruct">Maven 中央仓库</a>**中获得。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a><strong>映射</strong></h2><h3 id="基本映射"><a href="#基本映射" class="headerlink" title="基本映射"></a><strong>基本映射</strong></h3><p>我们先从一些基本的映射开始。我们会创建一个<code>Doctor</code>对象和一个<code>DoctorDto</code>。为了方便起见，它们的属性字段都使用相同的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Doctor &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DoctorDto &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，为了在这两者之间进行映射，我们要创建一个<code>DoctorMapper</code>接口。对该接口使用<code>@Mapper</code>注解，<code>MapStruct</code>就会知道这是两个类之间的映射器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Mapper</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class="line">    DoctorDto toDto(Doctor doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中创建了一个<code>DoctorMapper</code>类型的实例<code>INSTANCE</code>，在生成对应的实现代码后，这就是我们调用的“入口”。</p>
<p>我们在接口中定义了<code>toDto()</code>方法，该方法接收一个<code>Doctor</code>实例为参数，并返回一个<code>DoctorDto</code>实例。这足以让 MapStruct 知道我们想把一个<code>Doctor</code>实例映射到一个<code>DoctorDto</code>实例。</p>
<p>当我们构建&#x2F;编译应用程序时，<code>MapStruct</code>注解处理器插件会识别出<code>DoctorMapper</code>接口并为其生成一个实现类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public DoctorDto toDto(Doctor doctor) &#123;</span><br><span class="line">        if ( doctor == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        DoctorDtoBuilder doctorDto = DoctorDto.builder();</span><br><span class="line"></span><br><span class="line">        doctorDto.id(doctor.getId());</span><br><span class="line">        doctorDto.name(doctor.getName());</span><br><span class="line"></span><br><span class="line">        return doctorDto.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DoctorMapperImpl</code>类中包含一个<code>toDto()</code>方法，将我们的<code>Doctor</code>属性值映射到<code>DoctorDto</code>的属性字段中。如果要将<code>Doctor</code>实例映射到一个<code>DoctorDto</code>实例，可以这样写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line">DoctorDto doctorDto = DoctorMapper.INSTANCE.toDto(doctor);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：你可能也注意到了上面实现代码中的<code>DoctorDtoBuilder</code>。因为 builder 代码往往比较长，为了简洁起见，这里省略了 builder 模式的实现代码。如果你的类中包含 Builder，MapStruct 会尝试使用它来创建实例；如果没有的话，MapStruct 将通过<code>new</code>关键字进行实例化。</p>
<ul>
<li><h5 id="不同字段间映射"><a href="#不同字段间映射" class="headerlink" title="不同字段间映射"></a><strong>不同字段间映射</strong></h5></li>
</ul>
<p>通常，模型和<code>DTO</code>的字段名不会完全相同。由于团队成员各自指定命名，以及针对不同的调用服务，开发者对返回信息的打包方式选择不同，名称可能会有轻微的变化。</p>
<p><code>MapStruct</code>通过<code>@Mapping</code>注解对这类情况提供了支持。</p>
<p>我们先更新<code>Doctor</code>类，添加一个属性<code>specialty</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">public class Doctor &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String specialty;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>DoctorDto</code>类中添加一个<code>specialization</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">public class DoctorDto &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String specialization;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们需要让 <code>DoctorMapper</code> 知道这里的不一致。我们可以使用 <code>@Mapping</code> 注解，并设置其内部的 <code>source</code> 和 <code>target</code> 标记分别指向不一致的两个字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KOTLIN</span><br><span class="line">@Mapper</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class="line">    DoctorDto toDto(Doctor doctor);</span><br><span class="line">&#125;</span><br><span class="line">@Mapping`这个注解代码的含义是：`Doctor`中的`specialty`字段对应于`DoctorDto`类的 `specialization</span><br></pre></td></tr></table></figure>

<p>编译之后，会生成如下实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class="line">@Override</span><br><span class="line">    public DoctorDto toDto(Doctor doctor) &#123;</span><br><span class="line">        if (doctor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoctorDtoBuilder doctorDto = DoctorDto.builder();</span><br><span class="line"></span><br><span class="line">        doctorDto.specialization(doctor.getSpecialty());</span><br><span class="line">        doctorDto.id(doctor.getId());</span><br><span class="line">        doctorDto.name(doctor.getName());</span><br><span class="line"></span><br><span class="line">        return doctorDto.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="多个源类"><a href="#多个源类" class="headerlink" title="多个源类"></a><strong>多个源类</strong></h5></li>
</ul>
<p>有时，单个类不足以构建<code>DTO</code>，我们可能希望将多个类中的值聚合为一个<code>DTO</code>，供终端用户使用。这也可以通过在<code>@Mapping</code>注解中设置适当的标志来完成。</p>
<p>我们先新建另一个对象 <code>Education</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">public class Education &#123;</span><br><span class="line">    private String degreeName;</span><br><span class="line">    private String institute;</span><br><span class="line">    private Integer yearOfPassing;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后向 <code>DoctorDto</code>中添加一个新的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">public class DoctorDto &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String degree;</span><br><span class="line">    private String specialization;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，将 <code>DoctorMapper</code> 接口更新为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KOTLIN</span><br><span class="line">@Mapper</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class="line">    @Mapping(source = &quot;education.degreeName&quot;, target = &quot;degree&quot;)</span><br><span class="line">    DoctorDto toDto(Doctor doctor, Education education);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加了另一个<code>@Mapping</code>注解，并将其<code>source</code>设置为<code>Education</code>类的<code>degreeName</code>，将<code>target</code>设置为<code>DoctorDto</code>类的<code>degree</code>字段。</p>
<p>如果 <code>Education</code> 类和 <code>Doctor</code> 类包含同名的字段，我们必须让映射器知道使用哪一个，否则它会抛出一个异常。举例来说，如果两个模型都包含一个<code>id</code>字段，我们就要选择将哪个类中的<code>id</code>映射到 DTO 属性中。</p>
<ul>
<li><h5 id="子对象映射"><a href="#子对象映射" class="headerlink" title="子对象映射"></a><strong>子对象映射</strong></h5></li>
</ul>
<p>多数情况下，POJO 中不会<em>只</em>包含基本数据类型，其中往往会包含其它类。比如说，一个<code>Doctor</code>类中会有多个患者类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Patient &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Doctor 中添加一个患者列表<code>List</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">public class Doctor &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String specialty;</span><br><span class="line">    private List&lt;Patient&gt; patientList;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>Patient</code>需要转换，为其创建一个对应的 DTO</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class PatientDto &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在 <code>DoctorDto</code> 中新增一个存储 <code>PatientDto</code>的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">public class DoctorDto &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String degree;</span><br><span class="line">    private String specialization;</span><br><span class="line">    private List&lt;PatientDto&gt; patientDtoList;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改 <code>DoctorMapper</code>之前，我们先创建一个支持 <code>Patient</code> 和 <code>PatientDto</code> 转换的映射器接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Mapper</span><br><span class="line">public interface PatientMapper &#123;</span><br><span class="line">    PatientMapper INSTANCE = Mappers.getMapper(PatientMapper.class);</span><br><span class="line">    PatientDto toDto(Patient patient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个基本映射器，只会处理几个基本数据类型。</p>
<p>然后，我们再来修改 <code>DoctorMapper</code> 处理一下患者列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KOTLIN</span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class&#125;)</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class="line">    DoctorDto toDto(Doctor doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们要处理另一个需要映射的类，所以这里设置了<code>@Mapper</code>注解的<code>uses</code>标志，这样现在的 <code>@Mapper</code> 就可以使用另一个 <code>@Mapper</code>映射器。我们这里只加了一个，但你想在这里添加多少 class&#x2F;mapper 都可以。</p>
<p>我们已经添加了<code>uses</code>标志，所以在为<code>DoctorMapper</code>接口生成映射器实现时，MapStruct 也会把 <code>Patient</code> 模型转换成 <code>PatientDto</code> ——因为我们已经为这个任务注册了 <code>PatientMapper</code>。</p>
<p>编译查看最新想实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPESCRIPT</span><br><span class="line"></span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class="line">    private final PatientMapper patientMapper = Mappers.getMapper( PatientMapper.class );</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DoctorDto toDto(Doctor doctor) &#123;</span><br><span class="line">        if ( doctor == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoctorDtoBuilder doctorDto = DoctorDto.builder();</span><br><span class="line"></span><br><span class="line">        doctorDto.patientDtoList( patientListToPatientDtoList(doctor.getPatientList()));</span><br><span class="line">        doctorDto.specialization( doctor.getSpecialty() );</span><br><span class="line">        doctorDto.id( doctor.getId() );</span><br><span class="line">        doctorDto.name( doctor.getName() );</span><br><span class="line"></span><br><span class="line">        return doctorDto.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected List&lt;PatientDto&gt; patientListToPatientDtoList(List&lt;Patient&gt; list) &#123;</span><br><span class="line">        if ( list == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;PatientDto&gt; list1 = new ArrayList&lt;PatientDto&gt;( list.size() );</span><br><span class="line">        for ( Patient patient : list ) &#123;</span><br><span class="line">            list1.add( patientMapper.toDto( patient ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，除了<code>toDto()</code>映射方法外，最终实现中还添加了一个新的映射方法——&gt;<code>patientListToPatientDtoList()</code>。这个方法是在没有显式定义的情况下添加的，只是因为我们把<code>PatientMapper</code>添加到了<code>DoctorMapper</code>中。</p>
<p>该方法会遍历一个<code>Patient</code>列表，将每个元素转换为<code>PatientDto</code>，并将转换后的对象添加到<code>DoctorDto</code>对象内中的列表中。</p>
<h3 id="更新现有实例"><a href="#更新现有实例" class="headerlink" title="更新现有实例"></a><strong>更新现有实例</strong></h3><p>有时，我们希望用 DTO 的最新值更新一个模型中的属性，对目标对象(我们的例子中是<code>DoctorDto</code>)使用<code>@MappingTarget</code>注解，就可以更新现有的实例.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class&#125;)</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class="line">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新生成实现代码，就可以得到<code>updateModel()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateModel(DoctorDto doctorDto, Doctor doctor) &#123;</span><br><span class="line">        if (doctorDto == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (doctor.getPatientList() != null) &#123;</span><br><span class="line">            List&lt;Patient&gt; list = patientDtoListToPatientList(doctorDto.getPatientDtoList());</span><br><span class="line">            if (list != null) &#123;</span><br><span class="line">                doctor.getPatientList().clear();</span><br><span class="line">                doctor.getPatientList().addAll(list);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                doctor.setPatientList(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            List&lt;Patient&gt; list = patientDtoListToPatientList(doctorDto.getPatientDtoList());</span><br><span class="line">            if (list != null) &#123;</span><br><span class="line">                doctor.setPatientList(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doctor.setSpecialty(doctorDto.getSpecialization());</span><br><span class="line">        doctor.setId(doctorDto.getId());</span><br><span class="line">        doctor.setName(doctorDto.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，由于患者列表是该模型中的子实体，因此患者列表也会进行更新。</p>
<h3 id="数据类型映射"><a href="#数据类型映射" class="headerlink" title="数据类型映射"></a><strong>数据类型映射</strong></h3><p>MapStruct 支持<code>source</code>和<code>target</code>属性之间的数据类型转换。它还提供了基本类型及其相应的包装类之间的自动转换。</p>
<p>自动类型转换适用于：</p>
<ul>
<li>基本类型及其对应的包装类之间。比如， <code>int</code> 和 <code>Integer</code>， <code>float</code> 和 <code>Float</code>， <code>long</code> 和 <code>Long</code>，<code>boolean</code> 和 <code>Boolean</code> 等。</li>
<li>任意基本类型与任意包装类之间。如 <code>int</code> 和 <code>long</code>， <code>byte</code> 和 <code>Integer</code> 等。</li>
<li>所有基本类型及包装类与<code>String</code>之间。如 <code>boolean</code> 和 <code>String</code>， <code>Integer</code> 和 <code>String</code>， <code>float</code> 和 <code>String</code> 等。</li>
<li>枚举和<code>String</code>之间。</li>
<li>Java 大数类型(<code>java.math.BigInteger</code>， <code>java.math.BigDecimal</code>) 和 Java 基本类型(包括其包装类)与<code>String</code>之间。</li>
<li>其它情况详见 **<a href="https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#implicit-type-conversions">MapStruct 官方文档</a>**。</li>
</ul>
<p>因此，在生成映射器代码的过程中，如果源字段和目标字段之间属于上述任何一种情况，则 MapStrcut 会自行处理类型转换。</p>
<p>我们修改 <code>PatientDto</code> ，新增一个 <code>dateofBirth</code>字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class PatientDto &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private LocalDate dateOfBirth;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面，加入 <code>Patient</code> 对象中有一个<code>String</code> 类型的 <code>dateOfBirth</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class Patient &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String dateOfBirth;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在两者之间创建一个映射器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper</span><br><span class="line">public interface PatientMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class="line">    Patient toModel(PatientDto patientDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对日期进行转换时，我们也可以使用 <code>dateFormat</code> 设置格式声明。生成的实现代码形式大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class PatientMapperImpl implements PatientMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Patient toModel(PatientDto patientDto) &#123;</span><br><span class="line">        if (patientDto == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PatientBuilder patient = Patient.builder();</span><br><span class="line"></span><br><span class="line">        if (patientDto.getDateOfBirth() != null) &#123;</span><br><span class="line">            patient.dateOfBirth(DateTimeFormatter.ofPattern(&quot;dd/MMM/yyyy&quot;)</span><br><span class="line">                                .format(patientDto.getDateOfBirth()));</span><br><span class="line">        &#125;</span><br><span class="line">        patient.id(patientDto.getId());</span><br><span class="line">        patient.name(patientDto.getName());</span><br><span class="line"></span><br><span class="line">        return patient.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用了 <code>dateFormat</code> 声明的日期格式。如果我们没有声明格式的话，MapStruct 会使用 <code>LocalDate</code>的默认格式，大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">if (patientDto.getDateOfBirth() != null) &#123;</span><br><span class="line">    patient.dateOfBirth(DateTimeFormatter.ISO_LOCAL_DATE</span><br><span class="line">                        .format(patientDto.getDateOfBirth()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="数字格式转换"><a href="#数字格式转换" class="headerlink" title="数字格式转换"></a><strong>数字格式转换</strong></h5></li>
</ul>
<p>上面的例子中可以看到，在进行日期转换的时候，可以通过<code>dateFormat</code>标志指定日期的格式。</p>
<p>除此之外，对于数字的转换，也可以使用<code>numberFormat</code>指定显示格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">// 数字格式转换示例</span><br><span class="line">   @Mapping(source = &quot;price&quot;, target = &quot;price&quot;, numberFormat = &quot;$#.00&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="枚举映射"><a href="#枚举映射" class="headerlink" title="枚举映射"></a><strong>枚举映射</strong></h3><p>枚举映射的工作方式与字段映射相同。MapStruct 会对具有相同名称的枚举进行映射，这一点没有问题。但是，对于具有不同名称的枚举项，我们需要使用<code>@ValueMapping</code>注解。同样，这与普通类型的<code>@Mapping</code>注解也相似。</p>
<p>我们先创建两个枚举。第一个是 <code>PaymentType</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public enum PaymentType &#123;</span><br><span class="line">    CASH,</span><br><span class="line">    CHEQUE,</span><br><span class="line">    CARD_VISA,</span><br><span class="line">    CARD_MASTER,</span><br><span class="line">    CARD_CREDIT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说，这是一个应用内可用的支付方式，现在我们要根据这些选项创建一个更一般、有限的识图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public enum PaymentTypeView &#123;</span><br><span class="line">    CASH,</span><br><span class="line">    CHEQUE,</span><br><span class="line">    CARD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们创建这两个<code>enum</code>之间的映射器接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper</span><br><span class="line">public interface PaymentTypeMapper &#123;</span><br><span class="line"></span><br><span class="line">    PaymentTypeMapper INSTANCE = Mappers.getMapper(PaymentTypeMapper.class);</span><br><span class="line"></span><br><span class="line">    @ValueMappings(&#123;</span><br><span class="line">            @ValueMapping(source = &quot;CARD_VISA&quot;, target = &quot;CARD&quot;),</span><br><span class="line">            @ValueMapping(source = &quot;CARD_MASTER&quot;, target = &quot;CARD&quot;),</span><br><span class="line">            @ValueMapping(source = &quot;CARD_CREDIT&quot;, target = &quot;CARD&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们设置了一般性的<code>CARD</code>值，和更具体的 <code>CARD_VISA</code>, <code>CARD_MASTER</code> 和 <code>CARD_CREDIT</code> 。两个枚举间的枚举项数量不匹配—— <code>PaymentType</code> 有 5 个值，而 <code>PaymentTypeView</code> 只有 3 个。</p>
<p>为了在这些枚举项之间建立桥梁，我们可以使用<code>@ValueMappings</code>注解，该注解中可以包含多个<code>@ValueMapping</code>注解。这里，我们将<code>source</code>设置为三个具体枚举项之一，并将<code>target</code>设置为<code>CARD</code>。</p>
<p>MapStruct 自然会处理这些情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class PaymentTypeMapperImpl implements PaymentTypeMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType) &#123;</span><br><span class="line">        if (paymentType == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PaymentTypeView paymentTypeView;</span><br><span class="line"></span><br><span class="line">        switch (paymentType) &#123;</span><br><span class="line">            case CARD_VISA: paymentTypeView = PaymentTypeView.CARD;</span><br><span class="line">            break;</span><br><span class="line">            case CARD_MASTER: paymentTypeView = PaymentTypeView.CARD;</span><br><span class="line">            break;</span><br><span class="line">            case CARD_CREDIT: paymentTypeView = PaymentTypeView.CARD;</span><br><span class="line">            break;</span><br><span class="line">            case CASH: paymentTypeView = PaymentTypeView.CASH;</span><br><span class="line">            break;</span><br><span class="line">            case CHEQUE: paymentTypeView = PaymentTypeView.CHEQUE;</span><br><span class="line">            break;</span><br><span class="line">            default: throw new IllegalArgumentException( &quot;Unexpected enum constant: &quot; + paymentType );</span><br><span class="line">        &#125;</span><br><span class="line">        return paymentTypeView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CASH</code>和<code>CHEQUE</code>默认转换为对应值，特殊的 <code>CARD</code> 值通过<code>switch</code>循环处理。</p>
<p>但是，如果你要将很多值转换为一个更一般的值，这种方式就有些不切实际了。其实我们不必手动分配每一个值，只需要让 MapStruct 将所有剩余的可用枚举项（在目标枚举中找不到相同名称的枚举项），直接转换为对应的另一个枚举项。</p>
<p>可以通过 <code>MappingConstants</code>实现这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@ValueMapping(source = MappingConstants.ANY_REMAINING, target = &quot;CARD&quot;)</span><br><span class="line">PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，完成默认映射之后，所有剩余（未匹配）的枚举项都会映射为<code>CARD</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType) &#123;</span><br><span class="line">    if ( paymentType == null ) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PaymentTypeView paymentTypeView;</span><br><span class="line"></span><br><span class="line">    switch ( paymentType ) &#123;</span><br><span class="line">        case CASH: paymentTypeView = PaymentTypeView.CASH;</span><br><span class="line">        break;</span><br><span class="line">        case CHEQUE: paymentTypeView = PaymentTypeView.CHEQUE;</span><br><span class="line">        break;</span><br><span class="line">        default: paymentTypeView = PaymentTypeView.CARD;</span><br><span class="line">    &#125;</span><br><span class="line">    return paymentTypeView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种选择是使用<code>ANY UNMAPPED</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@ValueMapping(source = MappingConstants.ANY_UNMAPPED, target = &quot;CARD&quot;)</span><br><span class="line">PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br></pre></td></tr></table></figure>

<p>采用这种方式时，MapStruct 不会像前面那样先处理默认映射，再将剩余的枚举项映射到<code>target</code>值。而是，直接将<em>所有</em>未通过<code>@ValueMapping</code>注解做显式映射的值都转换为<code>target</code>值。</p>
<h3 id="集合映射"><a href="#集合映射" class="headerlink" title="集合映射"></a><strong>集合映射</strong></h3><p>简单来说，使用 MapStruct 处理集合映射的方式与处理简单类型相同。</p>
<p>我们创建一个简单的接口或抽象类并声明映射方法。 MapStruct 将根据我们的声明自动生成映射代码。 通常，生成的代码会遍历源集合，将每个元素转换为目标类型，并将每个转换后元素添加到目标集合中。</p>
<ul>
<li><h5 id="List-映射"><a href="#List-映射" class="headerlink" title="List 映射"></a><strong>List 映射</strong></h5></li>
</ul>
<p>我们先定义一个新的映射方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line">    List&lt;DoctorDto&gt; map(List&lt;Doctor&gt; doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;DoctorDto&gt; map(List&lt;Doctor&gt; doctor) &#123;</span><br><span class="line">        if ( doctor == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;DoctorDto&gt; list = new ArrayList&lt;DoctorDto&gt;( doctor.size() );</span><br><span class="line">        for ( Doctor doctor1 : doctor ) &#123;</span><br><span class="line">            list.add( doctorToDoctorDto( doctor1 ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected DoctorDto doctorToDoctorDto(Doctor doctor) &#123;</span><br><span class="line">        if ( doctor == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoctorDto doctorDto = new DoctorDto();</span><br><span class="line"></span><br><span class="line">        doctorDto.setId( doctor.getId() );</span><br><span class="line">        doctorDto.setName( doctor.getName() );</span><br><span class="line">        doctorDto.setSpecialization( doctor.getSpecialization() );</span><br><span class="line"></span><br><span class="line">        return doctorDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，MapStruct 为我们自动生成了从<code>Doctor</code>到<code>DoctorDto</code>的映射方法。</p>
<p>但是需要注意，如果我们在 DTO 中新增一个字段<code>fullName</code>，生成代码时会出现错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">警告: Unmapped target property: &quot;fullName&quot;.</span><br></pre></td></tr></table></figure>

<p>基本上，这意味着 MapStruct 在当前情况下无法为我们自动生成映射方法。因此，我们需要手动定义<code>Doctor</code>和<code>DoctorDto</code>之间的映射方法。具体参考之前的小节。</p>
<ul>
<li><h5 id="Set-和-Map-映射"><a href="#Set-和-Map-映射" class="headerlink" title="Set 和 Map 映射"></a><strong>Set 和 Map 映射</strong></h5></li>
</ul>
<p>Set 与 Map 型数据的处理方式与 List 相似。按照以下方式修改<code>DoctorMapper</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;DoctorDto&gt; setConvert(Set&lt;Doctor&gt; doctor);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, DoctorDto&gt; mapConvert(Map&lt;String, Doctor&gt; doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的最终实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;DoctorDto&gt; setConvert(Set&lt;Doctor&gt; doctor) &#123;</span><br><span class="line">        if ( doctor == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;DoctorDto&gt; set = new HashSet&lt;DoctorDto&gt;( Math.max( (int) ( doctor.size() / .75f ) + 1, 16 ) );</span><br><span class="line">        for ( Doctor doctor1 : doctor ) &#123;</span><br><span class="line">            set.add( doctorToDoctorDto( doctor1 ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Map&lt;String, DoctorDto&gt; mapConvert(Map&lt;String, Doctor&gt; doctor) &#123;</span><br><span class="line">        if ( doctor == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, DoctorDto&gt; map = new HashMap&lt;String, DoctorDto&gt;( Math.max( (int) ( doctor.size() / .75f ) + 1, 16 ) );</span><br><span class="line"></span><br><span class="line">        for ( java.util.Map.Entry&lt;String, Doctor&gt; entry : doctor.entrySet() ) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            DoctorDto value = doctorToDoctorDto( entry.getValue() );</span><br><span class="line">            map.put( key, value );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected DoctorDto doctorToDoctorDto(Doctor doctor) &#123;</span><br><span class="line">        if ( doctor == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoctorDto doctorDto = new DoctorDto();</span><br><span class="line"></span><br><span class="line">        doctorDto.setId( doctor.getId() );</span><br><span class="line">        doctorDto.setName( doctor.getName() );</span><br><span class="line">        doctorDto.setSpecialization( doctor.getSpecialization() );</span><br><span class="line"></span><br><span class="line">        return doctorDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 List 映射类似，MapStruct 自动生成了<code>Doctor</code>转换为<code>DoctorDto</code>的映射方法。</p>
<ul>
<li><h5 id="集合映射策略"><a href="#集合映射策略" class="headerlink" title="集合映射策略"></a><strong>集合映射策略</strong></h5></li>
</ul>
<p>很多场景中，我们需要对具有父子关系的数据类型进行转换。通常来说，会有一个数据类型（父），其字段是另一个数据类型（子）的集合。</p>
<p>对于这种情况，MapStruct 提供了一种方法来选择如何将子类型设置或添加到父类型中。具体来说，就是<code>@Mapper</code>注解中的<code>collectionMappingStrategy</code>属性，该属性可以取值为<code>ACCESSOR_ONLY</code>， <code>SETTER_PREFERRED</code>， <code>ADDER_PREFERRED</code> 或<code>TARGET_IMMUTABLE</code>。</p>
<p>这些值分别表示不同的为子类型集合赋值的方式。默认值是<code>ACCESSOR_ONLY</code>，这意味着只能使用访问器来设置子集合。</p>
<p>当父类型中的<em>Collection</em>字段<code>setter</code>方法不可用，但我们有一个子类型<code>add</code>方法时，这个选项就派上用场了；另一种有用的情况是父类型中的<em>Collection</em>字段是不可变的。</p>
<p>我们新建一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class Hospital &#123;</span><br><span class="line">    private List&lt;Doctor&gt; doctors;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时定义一个映射目标 DTO 类，同时定义子类型集合字段的 getter、setter 和 adder：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class HospitalDto &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;DoctorDto&gt; doctors;</span><br><span class="line"></span><br><span class="line">  // 子类型集合字段getter</span><br><span class="line">    public List&lt;DoctorDto&gt; getDoctors() &#123;</span><br><span class="line">        return doctors;</span><br><span class="line">    &#125;</span><br><span class="line">  // 子类型集合字段setter</span><br><span class="line">    public void setDoctors(List&lt;DoctorDto&gt; doctors) &#123;</span><br><span class="line">        this.doctors = doctors;</span><br><span class="line">    &#125;</span><br><span class="line">  // 子类型数据adder</span><br><span class="line">    public void addDoctor(DoctorDto doctorDTO) &#123;</span><br><span class="line">        if (doctors == null) &#123;</span><br><span class="line">            doctors = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doctors.add(doctorDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对应的映射器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(uses = DoctorMapper.class)</span><br><span class="line">public interface HospitalMapper &#123;</span><br><span class="line">    HospitalMapper INSTANCE = Mappers.getMapper(HospitalMapper.class);</span><br><span class="line"></span><br><span class="line">    HospitalDto toDto(Hospital hospital);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的最终实现代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class HospitalMapperImpl implements HospitalMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public HospitalDto toDto(Hospital hospital) &#123;</span><br><span class="line">        if ( hospital == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HospitalDto hospitalDto = new HospitalDto();</span><br><span class="line"></span><br><span class="line">        hospitalDto.setDoctors( doctorListToDoctorDtoList( hospital.getDoctors() ) );</span><br><span class="line"></span><br><span class="line">        return hospitalDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在默认情况下采用的策略是<code>ACCESSOR_ONLY</code>，使用 setter 方法<code>setDoctors()</code>向<code>HospitalDto</code>对象中写入列表数据。</p>
<p>相对的，如果使用 <code>ADDER_PREFERRED</code> 作为映射策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(collectionMappingStrategy = CollectionMappingStrategy.ADDER_PREFERRED,</span><br><span class="line">        uses = DoctorMapper.class)</span><br><span class="line">public interface HospitalMapper &#123;</span><br><span class="line">    HospitalMapper INSTANCE = Mappers.getMapper(HospitalMapper.class);</span><br><span class="line"></span><br><span class="line">    HospitalDto toDto(Hospital hospital);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，会使用 adder 方法逐个将转换后的子类型 DTO 对象加入父类型的集合字段中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class CompanyMapperAdderPreferredImpl implements CompanyMapperAdderPreferred &#123;</span><br><span class="line"></span><br><span class="line">    private final EmployeeMapper employeeMapper = Mappers.getMapper( EmployeeMapper.class );</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CompanyDTO map(Company company) &#123;</span><br><span class="line">        if ( company == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CompanyDTO companyDTO = new CompanyDTO();</span><br><span class="line"></span><br><span class="line">        if ( company.getEmployees() != null ) &#123;</span><br><span class="line">            for ( Employee employee : company.getEmployees() ) &#123;</span><br><span class="line">                companyDTO.addEmployee( employeeMapper.map( employee ) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return companyDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果目标 DTO 中既没有<code>setter</code>方法也没有<code>adder</code>方法，会先通过<code>getter</code>方法获取子类型集合，再调用集合的对应接口添加子类型对象。</p>
<p>可以在**<a href="https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#collection-mapping-strategies">参考文档</a>**中看到不同类型的 DTO 定义（是否包含 setter 方法或 adder 方法），采用不同的映射策略时，所使用的添加子类型到集合中的方式。</p>
<ul>
<li><h5 id="目标集合实现类型"><a href="#目标集合实现类型" class="headerlink" title="目标集合实现类型"></a><strong>目标集合实现类型</strong></h5></li>
</ul>
<p>MapStruct 支持将集合接口作为映射方法的目标类型。</p>
<p>在这种情况下，在生成的代码中会使用一些集合接口默认实现。 例如，上面的示例中，<code>List</code>的默认实现是<code>ArrayList</code>。</p>
<p>常见接口及其对应的默认实现如下：</p>
<p>无法复制加载中的内容</p>
<p>你可以在**<a href="https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#implementation-types-for-collection-mappings">参考文档</a>**中找到 MapStruct 支持的所有接口列表，以及每个接口对应的默认实现类型。</p>
<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a><strong>进阶操作</strong></h2><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h3><p>到目前为止，我们一直在通过<code>getMapper()</code>方法访问生成的映射器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br></pre></td></tr></table></figure>

<p>但是，如果你使用的是 Spring，只需要简单修改映射器配置，就可以像常规依赖项一样注入映射器。</p>
<p>修改 <code>DoctorMapper</code> 以支持 Spring 框架：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class="line">public interface DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>@Mapper</code>注解中添加<code>（componentModel = &quot;spring&quot;）</code>，是为了告诉 MapStruct，在生成映射器实现类时，我们希望它能支持通过 Spring 的依赖注入来创建。现在，就不需要在接口中添加 <code>INSTANCE</code> 字段了。</p>
<p>这次生成的 <code>DoctorMapperImpl</code> 会带有 <code>@Component</code> 注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Component</span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>只要被标记为<code>@Component</code>，Spring 就可以把它作为一个 bean 来处理，你就可以在其它类（如控制器）中通过<code>@Autowire</code>注解来使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Controller</span><br><span class="line">public class DoctorController() &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DoctorMapper doctorMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不使用 Spring, MapStruct 也支持**<a href="https://link.zhihu.com/?target=https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html">Java CDI</a>**：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(componentModel = &quot;cdi&quot;)</span><br><span class="line">public interface DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加默认值"><a href="#添加默认值" class="headerlink" title="添加默认值"></a><strong>添加默认值</strong></h3><p><code>@Mapping</code> 注解有两个很实用的标志就是常量 <code>constant</code> 和默认值 <code>defaultValue</code> 。无论<code>source</code>如何取值，都将始终使用常量值； 如果<code>source</code>取值为<code>null</code>，则会使用默认值。</p>
<p>修改一下 <code>DoctorMapper</code> ，添加一个 <code>constant</code> 和一个 <code>defaultValue</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line">    @Mapping(target = &quot;id&quot;, constant = &quot;-1&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;, defaultValue = &quot;Information Not Available&quot;)</span><br><span class="line">    DoctorDto toDto(Doctor doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>specialty</code>不可用，我们会替换为<code>&quot;Information Not Available&quot;</code>字符串，此外，我们将<code>id</code>硬编码为<code>-1</code>。</p>
<p>生成代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PatientMapper patientMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DoctorDto toDto(Doctor doctor) &#123;</span><br><span class="line">        if (doctor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoctorDto doctorDto = new DoctorDto();</span><br><span class="line"></span><br><span class="line">        if (doctor.getSpecialty() != null) &#123;</span><br><span class="line">            doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            doctorDto.setSpecialization(&quot;Information Not Available&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor.getPatientList()));</span><br><span class="line">        doctorDto.setName(doctor.getName());</span><br><span class="line"></span><br><span class="line">        doctorDto.setId(-1);</span><br><span class="line"></span><br><span class="line">        return doctorDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果 <code>doctor.getSpecialty()</code> 返回值为<code>null</code>，则将<code>specialization</code>设置为我们的默认信息。无论任何情况，都会对 <code>id</code>赋值，因为这是一个<code>constant</code>。</p>
<h3 id="添加表达式"><a href="#添加表达式" class="headerlink" title="添加表达式"></a><strong>添加表达式</strong></h3><p>MapStruct 甚至允许在<code>@Mapping</code>注解中输入 Java 表达式。你可以设置 <code>defaultExpression</code> （ <code>source</code> 取值为 <code>null</code>时生效），或者一个<code>expression</code>（类似常量，永久生效）。</p>
<p>在 <code>Doctor</code> 和 <code>DoctorDto</code>两个类中都加了两个新属性，一个是 <code>String</code> 类型的 <code>externalId</code> ，另一个是<code>LocalDateTime</code>类型的 <code>appointment</code> ，两个类大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">public class Doctor &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String externalId;</span><br><span class="line">    private String specialty;</span><br><span class="line">    private LocalDateTime availability;</span><br><span class="line">    private List&lt;Patient&gt; patientList;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DoctorDto &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String externalId;</span><br><span class="line">    private String specialization;</span><br><span class="line">    private LocalDateTime availability;</span><br><span class="line">    private List&lt;PatientDto&gt; patientDtoList;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>DoctorMapper</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;, imports = &#123;LocalDateTime.class, UUID.class&#125;)</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Mapping(target = &quot;externalId&quot;, expression = &quot;java(UUID.randomUUID().toString())&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctor.availability&quot;, target = &quot;availability&quot;, defaultExpression = &quot;java(LocalDateTime.now())&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class="line">    DoctorDto toDtoWithExpression(Doctor doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里将 <code>externalId</code>的值设置为 <code>java(UUID.randomUUID().toString())</code> ，如果源对象中没有 <code>availability</code> 属性，则会把目标对象中的 <code>availability</code> 设置为一个新的 <code>LocalDateTime</code>对象。</p>
<p>由于表达式只是字符串，我们必须在表达式中指定使用的类。但是这里的表达式并不是最终执行的代码，只是一个字母的文本值。因此，我们要在 <code>@Mapper</code> 中添加 <code>imports = &#123;LocalDateTime.class, UUID.class&#125;</code> 。</p>
<h3 id="添加自定义方法"><a href="#添加自定义方法" class="headerlink" title="添加自定义方法"></a><strong>添加自定义方法</strong></h3><p>到目前为止，我们一直使用的策略是添加一个“占位符”方法，并期望 MapStruct 能为我们实现它。其实我们还可以向接口中添加自定义的<code>default</code>方法，也可以通过<code>default</code>方法直接实现一个映射。然后我们可以通过实例直接调用该方法，没有任何问题。</p>
<p>为此，我们创建一个 <code>DoctorPatientSummary</code>类，其中包含一个 <code>Doctor</code> 及其 <code>Patient</code>列表的汇总信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class DoctorPatientSummary &#123;</span><br><span class="line">    private int doctorId;</span><br><span class="line">    private int patientCount;</span><br><span class="line">    private String doctorName;</span><br><span class="line">    private String specialization;</span><br><span class="line">    private String institute;</span><br><span class="line">    private List&lt;Integer&gt; patientIds;</span><br><span class="line">    // getters and setters or builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们在 <code>DoctorMapper</code>中添加一个<code>default</code>方法，该方法会将 <code>Doctor</code> 和 <code>Education</code> 对象转换为一个 <code>DoctorPatientSummary</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    default DoctorPatientSummary toDoctorPatientSummary(Doctor doctor, Education education) &#123;</span><br><span class="line"></span><br><span class="line">        return DoctorPatientSummary.builder()</span><br><span class="line">                .doctorId(doctor.getId())</span><br><span class="line">                .doctorName(doctor.getName())</span><br><span class="line">                .patientCount(doctor.getPatientList().size())</span><br><span class="line">        .patientIds(doctor.getPatientList()</span><br><span class="line">                     .stream()</span><br><span class="line">                      .map(Patient::getId)</span><br><span class="line">                     .collect(Collectors.toList()))</span><br><span class="line">              .institute(education.getInstitute())</span><br><span class="line">                .specialization(education.getDegreeName())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 Builder 模式创建<code>DoctorPatientSummary</code>对象。</p>
<p>在 MapStruct 生成映射器实现类之后，你就可以使用这个实现方法，就像访问任何其它映射器方法一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">DoctorPatientSummary summary = doctorMapper.toDoctorPatientSummary(dotor, education);</span><br></pre></td></tr></table></figure>

<h3 id="创建自定义映射器"><a href="#创建自定义映射器" class="headerlink" title="创建自定义映射器"></a><strong>创建自定义映射器</strong></h3><p>前面我们一直是通过接口来设计映射器功能，其实我们也可以通过一个带 <code>@Mapper</code> 的 <code>abstract</code> 类来实现一个映射器。MapStruct 也会为这个类创建一个实现，类似于创建一个接口实现。</p>
<p>我们重写一下前面的示例，这一次，我们将它修改为一个抽象类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public abstract class DoctorCustomMapper &#123;</span><br><span class="line">    public DoctorPatientSummary toDoctorPatientSummary(Doctor doctor, Education education) &#123;</span><br><span class="line"></span><br><span class="line">        return DoctorPatientSummary.builder()</span><br><span class="line">                .doctorId(doctor.getId())</span><br><span class="line">                .doctorName(doctor.getName())</span><br><span class="line">                .patientCount(doctor.getPatientList().size())</span><br><span class="line">                .patientIds(doctor.getPatientList()</span><br><span class="line">                        .stream()</span><br><span class="line">                        .map(Patient::getId)</span><br><span class="line">                        .collect(Collectors.toList()))</span><br><span class="line">                .institute(education.getInstitute())</span><br><span class="line">                .specialization(education.getDegreeName())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以用同样的方式使用这个映射器。由于限制较少，使用抽象类可以在创建自定义实现时给我们更多的控制和选择。另一个好处是可以添加<code>@BeforeMapping</code>和<code>@AfterMapping</code>方法。</p>
<h3 id="BeforeMapping-和-AfterMapping"><a href="#BeforeMapping-和-AfterMapping" class="headerlink" title="@BeforeMapping 和 @AfterMapping"></a><strong>@BeforeMapping 和 @AfterMapping</strong></h3><p>为了进一步控制和定制化，我们可以定义 <code>@BeforeMapping</code> 和 <code>@AfterMapping</code>方法。显然，这两个方法是在每次映射之前和之后执行的。也就是说，在最终的实现代码中，会在两个对象真正映射之前和之后添加并执行这两个方法。</p>
<p>可以在 <code>DoctorCustomMapper</code>中添加两个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class="line">public abstract class DoctorCustomMapper &#123;</span><br><span class="line"></span><br><span class="line">    @BeforeMapping</span><br><span class="line">    protected void validate(Doctor doctor) &#123;</span><br><span class="line">        if(doctor.getPatientList() == null)&#123;</span><br><span class="line">            doctor.setPatientList(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterMapping</span><br><span class="line">    protected void updateResult(@MappingTarget DoctorDto doctorDto) &#123;</span><br><span class="line">        doctorDto.setName(doctorDto.getName().toUpperCase());</span><br><span class="line">        doctorDto.setDegree(doctorDto.getDegree().toUpperCase());</span><br><span class="line">        doctorDto.setSpecialization(doctorDto.getSpecialization().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class="line">    public abstract DoctorDto toDoctorDto(Doctor doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于该抽象类生成一个映射器实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class DoctorCustomMapperImpl extends DoctorCustomMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PatientMapper patientMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DoctorDto toDoctorDto(Doctor doctor) &#123;</span><br><span class="line">        validate(doctor);</span><br><span class="line"></span><br><span class="line">        if (doctor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoctorDto doctorDto = new DoctorDto();</span><br><span class="line"></span><br><span class="line">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor</span><br><span class="line">            .getPatientList()));</span><br><span class="line">        doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class="line">        doctorDto.setId(doctor.getId());</span><br><span class="line">        doctorDto.setName(doctor.getName());</span><br><span class="line"></span><br><span class="line">        updateResult(doctorDto);</span><br><span class="line"></span><br><span class="line">        return doctorDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， <code>validate()</code> 方法会在 <code>DoctorDto</code> 对象实例化之前执行，而<code>updateResult()</code>方法会在映射结束之后执行。</p>
<h3 id="映射异常处理"><a href="#映射异常处理" class="headerlink" title="映射异常处理"></a><strong>映射异常处理</strong></h3><p>异常处理是不可避免的，应用程序随时会产生异常状态。MapStruct 提供了对异常处理的支持，可以简化开发者的工作。</p>
<p>考虑这样一个场景，我们想在 <code>Doctor</code> 映射为<code>DoctorDto</code>之前校验一下 <code>Doctor</code> 的数据。我们新建一个独立的 <code>Validator</code> 类进行校验：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class Validator &#123;</span><br><span class="line">    public int validateId(int id) throws ValidationException &#123;</span><br><span class="line">        if(id == -1)&#123;</span><br><span class="line">            throw new ValidationException(&quot;Invalid value in ID&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们修改一下 <code>DoctorMapper</code> 以使用 <code>Validator</code> 类，无需指定实现。跟之前一样， 在<code>@Mapper</code>使用的类列表中添加该类。我们还需要做的就是告诉 MapStruct 我们的 <code>toDto()</code> 会抛出 <code>throws ValidationException</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class="line">    DoctorDto toDto(Doctor doctor) throws ValidationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终生成的映射器代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PatientMapper patientMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Validator validator;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DoctorDto toDto(Doctor doctor) throws ValidationException &#123;</span><br><span class="line">        if (doctor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoctorDto doctorDto = new DoctorDto();</span><br><span class="line"></span><br><span class="line">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor</span><br><span class="line">            .getPatientList()));</span><br><span class="line">        doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class="line">        doctorDto.setId(validator.validateId(doctor.getId()));</span><br><span class="line">        doctorDto.setName(doctor.getName());</span><br><span class="line">        doctorDto.setExternalId(doctor.getExternalId());</span><br><span class="line">        doctorDto.setAvailability(doctor.getAvailability());</span><br><span class="line"></span><br><span class="line">        return doctorDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MapStruct 自动将<code>doctorDto</code>的<code>id</code>设置为<code>Validator</code>实例的方法返回值。它还在该方法签名中添加了一个 throws 子句。</p>
<p>注意，如果映射前后的一对属性的类型与<code>Validator</code>中的方法出入参类型一致，那该字段映射时就会调用<code>Validator</code>中的方法，所以该方式请谨慎使用。</p>
<h3 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a><strong>映射配置</strong></h3><p>MapStruct 为编写映射器方法提供了一些非常有用的配置。多数情况下，如果我们已经定义了两个类型之间的映射方法，当我们要添加相同类型之间的另一个映射方法时，我们往往会直接复制已有方法的映射配置。</p>
<p>其实我们不必手动复制这些注解，只需要简单的配置就可以创建一个相同&#x2F;相似的映射方法。</p>
<h5 id="继承配置"><a href="#继承配置" class="headerlink" title="继承配置"></a><strong>继承配置</strong></h5><p>我们回顾一下“**<a href="https://zhuanlan.zhihu.com/p/368731266/edit#%E6%9B%B4%E6%96%B0%E7%8E%B0%E6%9C%89%E5%AE%9E%E4%BE%8B">更新现有实例</a>**”，在该场景中，我们创建了一个映射器，根据 DoctorDto 对象的属性更新现有的 Doctor 对象的属性值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class&#125;)</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class="line">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们还有另一个映射器，将 <code>DoctorDto</code>转换为 <code>Doctor</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;)</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class="line">    Doctor toModel(DoctorDto doctorDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个映射方法使用了相同的注解配置， <code>source</code>和 <code>target</code>都是相同的。其实我们可以使用<code>@InheritConfiguration</code>注释，从而避免这两个映射器方法的重复配置。</p>
<p>如果对一个方法添加 <code>@InheritConfiguration</code> 注解，MapStruct 会检索其它的已配置方法，寻找可用于当前方法的注解配置。一般来说，这个注解都用于<code>mapping</code>方法后面的<code>update</code>方法，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class="line">public interface DoctorMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class="line">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class="line">    Doctor toModel(DoctorDto doctorDto);</span><br><span class="line"></span><br><span class="line">    @InheritConfiguration</span><br><span class="line">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="继承逆向配置"><a href="#继承逆向配置" class="headerlink" title="继承逆向配置"></a><strong>继承逆向配置</strong></h5><p>还有另外一个类似的场景，就是编写映射函数将**<em>Model</em>** 转为 **<em>DTO</em>**，以及将 <strong>*DTO*</strong> 转为 **<em>Model</em>**。如下面的代码所示，我们必须在两个函数上添加相同的注释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class="line">public interface PatientMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class="line">    Patient toModel(PatientDto patientDto);</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class="line">    PatientDto toDto(Patient patient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法的配置不会是完全相同的，实际上，它们应该是相反的。将 <strong>Model</strong> 转为 **<em>DTO</em>**，以及将 <strong>*DTO*</strong> 转为 **<em>Model</em>**——映射前后的字段相同，但是源属性字段与目标属性字段是相反的。</p>
<p>我们可以在第二个方法上使用<code>@InheritInverseConfiguration</code>注解，避免写两遍映射配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class="line">public interface PatientMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class="line">    Patient toModel(PatientDto patientDto);</span><br><span class="line"></span><br><span class="line">    @InheritInverseConfiguration</span><br><span class="line">    PatientDto toDto(Patient patient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个 Mapper 生成的代码是相同的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>在本文中，我们探讨了 MapStruct——一个用于创建映射器类的库。从基本映射到自定义方法和自定义映射器，此外， 我们还介绍了 MapStruct 提供的一些高级操作选项，包括依赖注入，数据类型映射、枚举映射和表达式使用。</p>
<p>MapStruct 提供了一个功能强大的集成插件，可减少开发人员编写模板代码的工作量，使创建映射器的过程变得简单快捷。</p>
]]></content>
      <tags>
        <tag>MapStruct</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot 核心技术</title>
    <url>/2021/08/23/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/SpringBoot2%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><h3 id="1、Spring-生态圈"><a href="#1、Spring-生态圈" class="headerlink" title="1、Spring 生态圈"></a>1、Spring 生态圈</h3><blockquote>
<p>Spring 官网：<a href="https://spring.io/">https://spring.io</a></p>
</blockquote>
<p><strong>Spring 能做什么？</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220515171610.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220515171610.png" alt="image-20220515171609895"></a></p>
<p><strong>Spring 的生态：</strong></p>
<ul>
<li>web 开发</li>
<li>数据访问</li>
<li>安全控制</li>
<li>分布式</li>
<li>消息服务</li>
<li>移动开发</li>
<li>批处理</li>
<li>…</li>
</ul>
<h3 id="2、为什么使用-SpringBoot？"><a href="#2、为什么使用-SpringBoot？" class="headerlink" title="2、为什么使用 SpringBoot？"></a>2、为什么使用 SpringBoot？</h3><blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p>
<p>能快速创建出生产级别的 Spring 应用。</p>
</blockquote>
<p><strong>SpringBoot 的优点：</strong></p>
<ul>
<li>创建独立 Spring 应用</li>
<li>内嵌 web 服务器</li>
<li>自动 starter 依赖，简化构建配置</li>
<li>自动配置 Spring 以及第三方功能</li>
<li>提供生产级别的监控、健康检查及外部化配置</li>
<li>无代码生成、无需编写 XML</li>
<li>SpringBoot 是整合 Spring 技术栈的一站式框架</li>
<li>SpringBoot 是简化 Spring 技术栈的快速开发脚手架</li>
</ul>
<p><strong>SpringBoot 的缺点：</strong></p>
<ul>
<li>人称版本帝，社区活跃，迭代快，需要时刻关注版本变化</li>
<li>封装太深，内部原理复杂，不容易精通</li>
</ul>
<h3 id="3、时代背景"><a href="#3、时代背景" class="headerlink" title="3、时代背景"></a>3、时代背景</h3><p>SpringBoot 诞生的时代背景，为了解决什么样的应用场景？</p>
<h4 id="3-1、微服务"><a href="#3-1、微服务" class="headerlink" title="3.1、微服务"></a>3.1、微服务</h4><p><a href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a> 提出微服务完整概念。</p>
<blockquote>
<p>In short, the <strong>microservice architectural style</strong> is an approach to developing a single application as a <strong>suite of small services</strong>, each <strong>running in its own process</strong> and communicating with <strong>lightweight</strong> mechanisms, often an <strong>HTTP</strong> resource API. These services are <strong>built around business capabilities</strong> and <strong>independently deployable</strong> by fully <strong>automated deployment</strong> machinery. There is a <strong>bare minimum of centralized management</strong> of these services, which may be <strong>written in different programming languages</strong> and use different data storage technologies.– <a href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a></p>
</blockquote>
<p><strong>主要提出：</strong></p>
<ul>
<li>微服务是一种架构风格</li>
<li>一个应用拆分为一组小型服务</li>
<li>每个服务运行在自己的进程内，也就是可独立部署和升级</li>
<li>服务之间使用轻量级 HTTP 交互</li>
<li>服务围绕业务功能拆分</li>
<li>可以由全自动部署机制独立部署</li>
<li>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</li>
</ul>
<h4 id="3-2、分布式"><a href="#3-2、分布式" class="headerlink" title="3.2、分布式"></a>3.2、分布式</h4><p>分布式架构，讲得是系统服务分布在多个物理隔离的节点上运行，统一对外提供服务。从用户层面来看，就是一组服务节点组成一个系统。</p>
<p><strong>分布式有哪些困难：</strong></p>
<ul>
<li>远程调用</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>服务容错</li>
<li>配置管理</li>
<li>服务监控</li>
<li>链路追踪</li>
<li>日志管理</li>
<li>任务调度</li>
<li>…</li>
</ul>
<p><strong>分布式的解决方案：</strong></p>
<p>&#x3D;&#x3D;SpringBoot + SpringCloud&#x3D;&#x3D;</p>
<h3 id="4、如何学习-SpringBoot？"><a href="#4、如何学习-SpringBoot？" class="headerlink" title="4、如何学习 SpringBoot？"></a>4、如何学习 SpringBoot？</h3><blockquote>
<p>官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">https://docs.spring.io/spring-boot/docs/current/reference/html/</a></p>
<p>版本更新日志：<a href="https://github.com/spring-projects/spring-boot/wiki#release-notes">https://github.com/spring-projects/spring-boot/wiki#release-notes</a></p>
</blockquote>
<h3 id="5、SpringBoot-特点"><a href="#5、SpringBoot-特点" class="headerlink" title="5、SpringBoot 特点"></a>5、SpringBoot 特点</h3><p>首先快速搭建一个<code>SpringBoot</code>应用</p>
<h4 id="5-1、准备工作"><a href="#5-1、准备工作" class="headerlink" title="5.1、准备工作"></a>5.1、准备工作</h4><p><strong>系统要求</strong></p>
<ul>
<li><a href="https://www.java.com/">Java 8</a> &amp; 兼容 java14 .</li>
<li>Maven 3.3+</li>
<li>idea 2022.1</li>
</ul>
<h5 id="maven-设置"><a href="#maven-设置" class="headerlink" title="maven 设置"></a>maven 设置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line"></span><br><span class="line">&lt;mirrors&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">        &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">    &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br><span class="line"></span><br><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;jdk-1.8&lt;/id&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;jdk&gt;1.8&lt;/jdk&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">            &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">            &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure>

<h5 id="创建一个-maven-项目"><a href="#创建一个-maven-项目" class="headerlink" title="创建一个 maven 项目"></a>创建一个 maven 项目</h5><ul>
<li>创建工程</li>
</ul>
<p>过程略，使用 idea 创建即可</p>
<ul>
<li>引入依赖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建主程序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * 主程序类</span><br><span class="line"> * @SpringBootApplication：这是一个SpringBoot应用</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class MainApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String handle01()&#123;</span><br><span class="line">        return &quot;Hello, Spring Boot 2!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>简化配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application.properties</span><br><span class="line">ELM</span><br><span class="line">server.port=8888</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<p>运行启动类中的 main 方法，访问接口测试：localhost:8888&#x2F;hello</p>
<h4 id="5-2、依赖管理"><a href="#5-2、依赖管理" class="headerlink" title="5.2、依赖管理"></a>5.2、依赖管理</h4><ul>
<li><strong>父项目做依赖管理</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line"></span><br><span class="line">&lt;!-- 父项目 --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- spring-boot-starter-parent的父项目 --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;!-- 几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制 --&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>开发导入 starter 场景启动器</strong></li>
</ul>
<p>官方支持的的 starter 列表：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using-boot-starter">Spring Boot Starters</a></p>
<p><code>spring-boot-starter-*</code>：这个 <code>*</code> 代表的就是某种场景，引入场景启动器可以帮助我们简化开发，依赖管理</p>
<p>第三方场景启动器：<code>*-spring-boot-starter</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;!-- 所有的场景启动器最底层的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无需关注版本号，自动根据场景启动器版本仲裁（父项目）</strong><ol>
<li>引入依赖默认都可以不写版本</li>
<li>引入非版本仲裁的 jar，要写版本号。</li>
</ol>
</li>
<li><strong>可以修改默认版本号</strong><ol>
<li>查看 spring-boot-dependencies 里面规定当前依赖的版本 用的 key</li>
<li>在当前项目里面重写配置</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APACHE</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-3、自动配置"><a href="#5-3、自动配置" class="headerlink" title="5.3、自动配置"></a>5.3、自动配置</h4><p><code>spring-boot-starter-web</code> 这个场景启动器会帮助我们做好很多配置</p>
<ul>
<li><p>自动配置好 Tomcat</p>
<ul>
<li>引入 Tomcat 依赖</li>
<li>配置 Tomcat</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动配好 SpringMVC</p>
</li>
<li><ul>
<li>引入 SpringMVC 全套组件</li>
<li>自动配置好 SpringMVC 常用组件（功能）</li>
</ul>
</li>
<li><p>自动配好 Web 常用功能，如：字符编码问题</p>
<ul>
<li>SpringBoot 帮我们配置好了所有 web 开发的常用场景</li>
</ul>
</li>
<li><p>默认的包结构</p>
<ul>
<li>主程序所在的包及其下面的所有子包里面的组件都会被扫描进来</li>
<li>无需以前的包扫描配置</li>
<li>想要改变扫描路径，@SpringBootApplication(scanBasePackages&#x3D;”com.vansys”)<ul>
<li>或者使用@ComponentScan 指定扫描路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LESS</span><br><span class="line">@SpringBootApplication</span><br><span class="line">等同于</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(&quot;com.vansys&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>各种配置拥有默认值<ul>
<li>默认配置最终都是映射到某个类上，如：MultipartProperties</li>
<li>配置文件的值最终会绑定在每个类上，这个类会在容器中创建对象</li>
</ul>
</li>
<li>按需加载所有自动配置项<ul>
<li>非常多的 starter</li>
<li>引入了哪些场景，相对应的场景才会开启</li>
<li>SprongBoot 所有的自动配置功能都在 spring-boot-autoconfigure 包里面</li>
</ul>
</li>
<li>…</li>
</ul>
<h3 id="6、容器功能"><a href="#6、容器功能" class="headerlink" title="6、容器功能"></a>6、容器功能</h3><h4 id="6-1、组件添加"><a href="#6-1、组件添加" class="headerlink" title="6.1、组件添加"></a>6.1、组件添加</h4><h5 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h5><ul>
<li>基本使用</li>
<li>Full 模式与 Lite 模式<ul>
<li>配置类组件之间无依赖关系用 Lite 模式，加速容器的启动过程，减少判断</li>
<li>配置类组件之间有依赖关系，方法会被调用得到之前的单实例组件，用 Full 模式</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">#############################Configuration使用示例######################################</span><br><span class="line">/**</span><br><span class="line"> * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的</span><br><span class="line"> * 2、配置类本身也是组件</span><br><span class="line"> * 3、proxyBeanMethods：代理bean的方法</span><br><span class="line"> *      Full(proxyBeanMethods = true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】</span><br><span class="line"> *      Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】</span><br><span class="line"> *      组件依赖必须使用Full模式默认。其他默认是否Lite模式</span><br><span class="line"> */</span><br><span class="line">@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span><br><span class="line">    public User user01()&#123;</span><br><span class="line">        User zhangsan = new User(&quot;zhangsan&quot;, 18);</span><br><span class="line">        //user组件依赖了Pet组件</span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        return zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;tom&quot;)</span><br><span class="line">    public Pet tomcatPet()&#123;</span><br><span class="line">        return new Pet(&quot;tomcat&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#########################@Configuration测试代码如下###################################</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class MainApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1、返回我们IOC容器</span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        //2、查看容器里面的组件</span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        for (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3、从容器中获取组件</span><br><span class="line"></span><br><span class="line">        Pet tom01 = run.getBean(&quot;tom&quot;, Pet.class);</span><br><span class="line"></span><br><span class="line">        Pet tom02 = run.getBean(&quot;tom&quot;, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;组件：&quot;+(tom01 == tom02));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //4、com.vansys.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span><br><span class="line">        MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span><br><span class="line">        //保持组件单实例</span><br><span class="line">        User user = bean.user01();</span><br><span class="line">        User user1 = bean.user01();</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        User user01 = run.getBean(&quot;user01&quot;, User.class);</span><br><span class="line">        Pet tom = run.getBean(&quot;tom&quot;, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Bean、-Component、-Controller、-Service、-Repository"><a href="#Bean、-Component、-Controller、-Service、-Repository" class="headerlink" title="@Bean、@Component、@Controller、@Service、@Repository"></a>@Bean、@Component、@Controller、@Service、@Repository</h5><p>在类上使用这些这些注解也可以实现往容器里添加组件</p>
<h5 id="ComponentScan、-Import"><a href="#ComponentScan、-Import" class="headerlink" title="@ComponentScan、@Import"></a>@ComponentScan、@Import</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LESS</span><br><span class="line">// 给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span><br><span class="line">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="line">@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h5><p>条件装配：满足@Conditional 指定的条件，则进行组件注入</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220515224340.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220515224340.png" alt="image-20220515224340380"></a></p>
<h5 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h5><p>原生配置文件引入，可以引入一个 <code>beans.xml</code> 配置文件</p>
<h4 id="6-2、配置绑定"><a href="#6-2、配置绑定" class="headerlink" title="6.2、配置绑定"></a>6.2、配置绑定</h4><h5 id="Component-ConfigurationProperties"><a href="#Component-ConfigurationProperties" class="headerlink" title="@Component + @ConfigurationProperties"></a>@Component + @ConfigurationProperties</h5><p>通过 <code>prefix</code> 匹配 <code>application.properties</code> 核心配置文件的配置，并指定注入到容器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><br><span class="line">public class Car &#123;</span><br><span class="line"></span><br><span class="line">    private String brand;</span><br><span class="line">    private Integer price;</span><br><span class="line"></span><br><span class="line">    public String getBrand() &#123;</span><br><span class="line">        return brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBrand(String brand) &#123;</span><br><span class="line">        this.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(Integer price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Car&#123;&quot; +</span><br><span class="line">                &quot;brand=&#x27;&quot; + brand + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="EnableConfigurationProperties-ConfigurationProperties"><a href="#EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties + @ConfigurationProperties"></a>@EnableConfigurationProperties + @ConfigurationProperties</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@EnableConfigurationProperties(Car.class)</span><br><span class="line">//1、开启Car配置绑定功能</span><br><span class="line">//2、把这个Car这个组件自动注册到容器中</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring 注解详解：<a href="https://www.bilibili.com/video/BV1gW411W7wy">https://www.bilibili.com/video/BV1gW411W7wy</a></p>
</blockquote>
<h3 id="7、自动配置原理入门"><a href="#7、自动配置原理入门" class="headerlink" title="7、自动配置原理入门"></a>7、自动配置原理入门</h3><h4 id="7-1、引导加载自动配置类"><a href="#7-1、引导加载自动配置类" class="headerlink" title="7.1、引导加载自动配置类"></a>7.1、引导加载自动配置类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public class MainApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>SpringBootConfiguration</p>
<ul>
<li>@Configuration：表明当前是一个配置类</li>
</ul>
</li>
<li><p>@ComponentScan</p>
<ul>
<li>指定扫描哪些包下的组件</li>
</ul>
</li>
<li><p>@EnableAutoConfiguration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@AutoConfigurationPackage</li>
</ul>
<p>自动配置包？指定了默认的包规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">//利用Registrar给容器中导入一系列组件</span><br><span class="line">//将指定的一个包下的所有组件导入进来？MainApplication 所在包下。</span><br><span class="line">@Import(&#123;AutoConfigurationPackages.Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Import(AutoConfigurationImportSelector.class)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REASONML</span><br><span class="line">1、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</span><br><span class="line">2、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</span><br><span class="line">3、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件</span><br><span class="line">4、从META-INF/spring.factories位置来加载一个文件。</span><br><span class="line">	默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件</span><br><span class="line">    spring-boot-autoconfigure-2.6.7.RELEASE.jar包里面也有META-INF/spring.factories</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220515232710.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20220515232710.png" alt="image-20220515232710021"></a></p>
<blockquote>
<p>spring-boot-autoconfigure-2.6.7.RELEASE.jar&#x2F;META-INF&#x2F;spring.factories 文件里面写死了 spring-boot 一启动就要给容器中加载的所有配置类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIVESCRIPT</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.netty.NettyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</span><br></pre></td></tr></table></figure>

<h4 id="7-2、按需开启自动配置项"><a href="#7-2、按需开启自动配置项" class="headerlink" title="7.2、按需开启自动配置项"></a>7.2、按需开启自动配置项</h4><p><code>spring-boot-2.6.7.RELEASE</code> 版本默认提供了 133 个自动配置项，全为 <code>xxxAutoConfiguration</code> 的自动配置类，但是根据 Spring 的 <code>@Conditional</code> 注解，最终会按需配置。</p>
<h4 id="7-3、修改默认配置"><a href="#7-3、修改默认配置" class="headerlink" title="7.3、修改默认配置"></a>7.3、修改默认配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">//给容器中加入了文件上传解析器；</span><br><span class="line">@Bean</span><br><span class="line">//容器中有这个类型组件</span><br><span class="line">@ConditionalOnBean(MultipartResolver.class)</span><br><span class="line">//容器中没有这个名字 multipartResolver 的组件</span><br><span class="line">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span><br><span class="line">public MultipartResolver multipartResolver(MultipartResolver resolver) &#123;</span><br><span class="line">    //给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span><br><span class="line">    //SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span><br><span class="line">    // Detect if the user has created a MultipartResolver but named it incorrectly</span><br><span class="line">    return resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;SpringBoot 默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public CharacterEncodingFilter characterEncodingFilter() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>SpringBoot 先加载所有的自动配置类 xxxxxAutoConfiguration</li>
<li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties 里面拿。xxxProperties 和配置文件进行了绑定</li>
<li>生效的配置类就会给容器中装配很多组件</li>
<li>只要容器中有这些组件，相当于这些功能就有了</li>
<li>定制化配置</li>
<li><ul>
<li>用户直接自己使用@Bean 替换底层的组件</li>
<li>用户去看这个组件是获取的配置文件什么值就去修改。</li>
</ul>
</li>
</ul>
<blockquote>
<p>xxxxxAutoConfiguration —&gt; 组件 —&gt;** **xxxxProperties 里面拿值 —-&gt; application.properties</p>
</blockquote>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h3><h4 id="1-1、文件类型"><a href="#1-1、文件类型" class="headerlink" title="1.1、文件类型"></a>1.1、文件类型</h4><ul>
<li>properties</li>
</ul>
<p>同以前的 properties 用法</p>
<ul>
<li>yaml</li>
</ul>
<p>YAML 是 <code>YAML Ain&#39;t Markup Language</code>（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：<code>Yet Another Markup Language</code>（仍是一种标记语言）。</p>
<p>非常适合用来做以数据为中心的配置文件</p>
<p><strong>基本语法</strong></p>
<ul>
<li><code>key: value</code>；kv 之间有空格</li>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用 tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li><code>#</code> 表示注释</li>
<li>‘’ 与 “” 表示字符串内容，会被 转义&#x2F;不转义</li>
</ul>
<p><strong>数据类型</strong></p>
<ul>
<li>字面量：单个的、不可再分的值。date、boolean、string、number、null</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line">k: v</span><br></pre></td></tr></table></figure>

<ul>
<li>对象：键值对的集合。map、hash、set、object</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line">行内写法：k: &#123;k1:v1,k2:v2,k3:v3&#125;</span><br><span class="line">#或</span><br><span class="line">k:</span><br><span class="line">  k1: v1</span><br><span class="line">  k2: v2</span><br><span class="line">  K3: v3</span><br></pre></td></tr></table></figure>

<ul>
<li>数组：一组按次序排列的值。array、list、queue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line">行内写法：k: [v1,v2,v3]</span><br><span class="line">#或</span><br><span class="line">k:</span><br><span class="line"> - v1</span><br><span class="line"> - v2</span><br><span class="line"> - v3</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">	private String userName;</span><br><span class="line">	private Boolean boss;</span><br><span class="line">	private Date birth;</span><br><span class="line">	private Integer age;</span><br><span class="line">	private Pet pet;</span><br><span class="line">	private String[] interests;</span><br><span class="line">	private List&lt;String&gt; animal;</span><br><span class="line">	private Map&lt;String, Object&gt; score;</span><br><span class="line">	private Set&lt;Double&gt; salarys;</span><br><span class="line">	private Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Pet &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private Double weight;</span><br><span class="line">&#125;</span><br><span class="line">YAML</span><br><span class="line"></span><br><span class="line"># yaml表示以上对象</span><br><span class="line">person:</span><br><span class="line">  userName: zhangsan</span><br><span class="line">  boss: false</span><br><span class="line">  birth: 2019/12/12 20:12:33</span><br><span class="line">  age: 18</span><br><span class="line">  pet:</span><br><span class="line">    name: tomcat</span><br><span class="line">    weight: 23.4</span><br><span class="line">  interests: [篮球,游泳]</span><br><span class="line">  animal:</span><br><span class="line">    - jerry</span><br><span class="line">    - mario</span><br><span class="line">  score:</span><br><span class="line">    english:</span><br><span class="line">      first: 30</span><br><span class="line">      second: 40</span><br><span class="line">      third: 50</span><br><span class="line">    math: [131,140,148]</span><br><span class="line">    chinese: &#123;first: 128,second: 136&#125;</span><br><span class="line">  salarys: [3999,4999.98,5999.99]</span><br><span class="line">  allPets:</span><br><span class="line">    sick:</span><br><span class="line">      - &#123;name: tom&#125;</span><br><span class="line">      - &#123;name: jerry,weight: 47&#125;</span><br><span class="line">    health: [&#123;name: mario,weight: 47&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="1-2、配置提示"><a href="#1-2、配置提示" class="headerlink" title="1.2、配置提示"></a>1.2、配置提示</h4><p>&#x3D;&#x3D;自定义的类和配置文件绑定一般没有提示&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果在项目中使用 AspectJ，则需要确保注释处理器仅运行一次。 --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;proc&gt;none&lt;/proc&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2、Web-开发"><a href="#2、Web-开发" class="headerlink" title="2、Web 开发"></a>2、Web 开发</h3><h4 id="2-1、SpringMVC-自动配置概览"><a href="#2-1、SpringMVC-自动配置概览" class="headerlink" title="2.1、SpringMVC 自动配置概览"></a>2.1、SpringMVC 自动配置概览</h4><p>Spring Boot provides auto-configuration for Spring MVC that <strong>works well with most applications.(大多场景我们都无需自定义配置)</strong></p>
<p>The auto-configuration adds the following features on top of Spring’s defaults:</p>
<ul>
<li>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</li>
<li><ul>
<li>内容协商视图解析器和 BeanName 视图解析器</li>
</ul>
</li>
<li>Support for serving static resources, including support for WebJars (covered <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content">later in this document</a>)).</li>
<li><ul>
<li>静态资源（包括 webjars）</li>
</ul>
</li>
<li>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</li>
<li><ul>
<li>自动注册 <code>Converter，GenericConverter，Formatter</code></li>
</ul>
</li>
<li>Support for <code>HttpMessageConverters</code> (covered <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters">later in this document</a>).</li>
<li><ul>
<li>支持 <code>HttpMessageConverters</code> （后来我们配合内容协商理解原理）</li>
</ul>
</li>
<li>Automatic registration of <code>MessageCodesResolver</code> (covered <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-message-codes">later in this document</a>).</li>
<li><ul>
<li>自动注册 <code>MessageCodesResolver</code> （国际化用）</li>
</ul>
</li>
<li>Static <code>index.html</code> support.</li>
<li><ul>
<li>静态 index.html 页支持</li>
</ul>
</li>
<li>Custom <code>Favicon</code> support (covered <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon">later in this document</a>).</li>
<li><ul>
<li>自定义 <code>Favicon</code></li>
</ul>
</li>
<li>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer">later in this document</a>).</li>
<li><ul>
<li>自动使用 <code>ConfigurableWebBindingInitializer</code> ，（DataBinder 负责将请求数据绑定到 JavaBean 上）</li>
</ul>
</li>
</ul>
<blockquote>
<p>If you want to keep those Spring Boot MVC customizations and make more <a href="https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p>
<p><strong>不用@EnableWebMvc 注解。使用</strong> <code>@Configuration**</code> <strong>+</strong> <code>WebMvcConfigurer</code> <strong>自定义规则</strong></p>
</blockquote>
<blockquote>
<p>If you want to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, and still keep the Spring Boot MVC customizations, you can declare a bean of type <code>WebMvcRegistrations</code> and use it to provide custom instances of those components.</p>
<p><strong>声明</strong> <code>WebMvcRegistrations</code> <strong>改变默认底层组件</strong></p>
</blockquote>
<blockquote>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p>
<p><strong>使用</strong> &#x3D;&#x3D;@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管 SpringMVC&#x3D;&#x3D;</p>
</blockquote>
]]></content>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 常见面试题</title>
    <url>/2021/09/10/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>面试题节选自：<a href="https://javaguide.cn/">Java 面试指南 | JavaGuide</a>、<a href="https://r2coding.com/#/">Road 2 Coding | 编程自学之路</a></p>
<p>每天一记，始终如一…</p>
</blockquote>
<h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（Java 虚拟机实现平台无关性）；</li>
<li>支持多线程</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<blockquote>
<p><code>一次编写，随处运行</code> 是 Java 经典的跨平台口号。</p>
<p>但是目前市面上虚拟化技术已经非常成熟，通过 Docker 容器化技术就很容易实现跨平台。</p>
<p>Java 最大的优势应该是强大的生态！</p>
</blockquote>
<h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p>
<p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">Comparison of Java virtual machinesopen in new window</a> ，感兴趣的可以去看看。并且，你可以在 <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specificationsopen in new window</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p>
<h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><strong>Java 程序从源代码到运行的过程如下所示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.java -&gt; javac 编译 -&gt; .class -&gt; 解释器&amp;JIT -&gt; 机器可理解的代码 -&gt; 机器运行</span><br></pre></td></tr></table></figure>

<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>
</blockquote>
<h3 id="AIT-和-AOT-的区别？为什么不全部使用-AOT-呢？"><a href="#AIT-和-AOT-的区别？为什么不全部使用-AOT-呢？" class="headerlink" title="AIT 和 AOT 的区别？为什么不全部使用 AOT 呢？"></a>AIT 和 AOT 的区别？为什么不全部使用 AOT 呢？</h3><ul>
<li><strong>JIT（Just-in-Time，即时编译）</strong></li>
<li><strong>AOT（Ahead-of-Time，预编译）</strong></li>
</ul>
<p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p>
<p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>
<h3 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h3><ul>
<li><strong>编译型：</strong><a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言</a>会通过<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译型语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型：</strong><a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言</a>会通过<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释型语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<blockquote>
<p><strong>维基百科中介绍：</strong></p>
<p>为了改善编译语言的效率而发展出的<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF">即时编译</a>技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81">字节码</a>。到执行期时，再将字节码直译，之后执行。<a href="https://zh.wikipedia.org/wiki/Java">Java</a>与<a href="https://zh.wikipedia.org/wiki/LLVM">LLVM</a>是这种技术的代表产物。</p>
<p><strong>相关阅读：</strong><a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java 即时编译器原理解析及实践</a></p>
</blockquote>
<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>
<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p>
<p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识</strong>符 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。</p>
<h3 id="Java-语言关键字有哪些？true、false-和-null-是关键字吗？"><a href="#Java-语言关键字有哪些？true、false-和-null-是关键字吗？" class="headerlink" title="Java 语言关键字有哪些？true、false 和 null 是关键字吗？"></a>Java 语言关键字有哪些？true、false 和 null 是关键字吗？</h3><blockquote>
<p>官方文档：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">Java 语言关键字 | (oracle.com)</a></p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103173519.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103173519.png" alt="image-20221103173508830"></a></p>
<blockquote>
<p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p>
<p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li>
<li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li>
</ul>
</blockquote>
<p><strong>虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用</strong></p>
<h3 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li>
</ol>
<p><code>return</code> 用于跳出所在的方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="成员变量与局部变量的区别？"></a>成员变量与局部变量的区别？</h4><ul>
<li><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>、<code>private</code>、<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
<li><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量存在于栈内存。</li>
<li><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>
<li><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外：被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ul>
<h4 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h4><p>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，他们都共享同一份静态变量。</p>
<p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>
<h4 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h4><ol>
<li><strong>形式</strong>：字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li>
<li><strong>含义</strong>：字符常量相当于一个整型值(ASCII 值)，可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放的位置)。</li>
<li><strong>占内存大小</strong>：字符常量只占 2 个字节；字符串常量占若干个字节。</li>
</ol>
<p><strong>(注意：<code>char</code> 在 Java 中占两个字节)</strong></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法为什么不能调用非静态成员？"><a href="#静态方法为什么不能调用非静态成员？" class="headerlink" title="静态方法为什么不能调用非静态成员？"></a>静态方法为什么不能调用非静态成员？</h4><ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</p>
<p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h4 id="重载和重写有什么区别？"><a href="#重载和重写有什么区别？" class="headerlink" title="重载和重写有什么区别？"></a>重载和重写有什么区别？</h4><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<p><strong>重载</strong></p>
<p>发生在同一个类中（或者父类与之类之间），方法名必须相同，参数类型不同、个数不同，顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对付类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong></p>
<ul>
<li>”两同“即方法名相同、形参列表相同；</li>
<li>”两小“指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类型应比父类方法抛出的异常类型更小或相等；</li>
<li>”一大“指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<blockquote>
<p>关于 <strong>重写的返回值类型</strong> 这里需要额外说明一下：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
</blockquote>
<h4 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h4><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static void method1(String... args) &#123;</span><br><span class="line">   //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static void method2(String arg1,String... args) &#123;</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高！</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型了解吗？"><a href="#Java-中的几种基本数据类型了解吗？" class="headerlink" title="Java 中的几种基本数据类型了解吗？"></a>Java 中的几种基本数据类型了解吗？</h3><p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型：<ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code></li>
</ul>
<p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
<td>true、false</td>
</tr>
</tbody></table>
<blockquote>
<p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
<p>另外，Java 的每种基本数据类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Jav··a 编程思想》2.2 节有提到）。</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析；</li>
<li><code>char a = &#39;h&#39;</code> 字符：单引号，<code>String a = &quot;hello&quot;</code> 字符串：双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code>。</p>
<h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul>
<li>成员变量包装类型不赋值就是 <code>null</code>，而基本类型有默认值且不是 <code>null</code>；</li>
<li>包装类型可用于泛型，而基本类型不可以；</li>
<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，而基本数据类型的成员变量（未被 <code>static</code> 修饰）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有的对象实例都存在于堆中；</li>
<li>相比于对象类型，基本数据类型占用的空间非常小。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行 <code>逃逸分析</code>，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p>
<blockquote>
<p><a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java 即时编译器原理解析及实践 - 逃逸分析</a></p>
</blockquote>
<p><strong>注意：基本数据类型存放在栈中是一个常见的误区！</strong>基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该给要使用基本数据类型对应的包装类型），就存放在堆中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">class BasicTypeVar &#123;</span><br><span class="line">    private int x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装类型的缓存机制了解吗？"><a href="#包装类型的缓存机制了解吗？" class="headerlink" title="包装类型的缓存机制了解吗？"></a>包装类型的缓存机制了解吗？</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128,127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>Ture</code> or <code>False</code>。</p>
<p><strong><code>Integer</code> 缓存源码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Character</code> 缓存源码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public static Character valueOf(char c) &#123;</span><br><span class="line">    if (c &lt;= 127) &#123; // must cache</span><br><span class="line">      return CharacterCache.cache[(int)c];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Character(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class CharacterCache &#123;</span><br><span class="line">    private CharacterCache()&#123;&#125;</span><br><span class="line">    static final Character cache[] = new Character[127 + 1];</span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i = 0; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = new Character((char)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Boolean</code> 缓存源码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static final Boolean TRUE = new Boolean(true);</span><br><span class="line"></span><br><span class="line">public static final Boolean FALSE = new Boolean(false);</span><br><span class="line"></span><br><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">    return (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果超过对应范围仍然回去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Fload</code>、<code>Double</code> 并没有实现缓存机制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Integer i1 = 33;</span><br><span class="line">Integer i2 = 33;</span><br><span class="line">System.out.println(i1 == i2);// 输出 true</span><br><span class="line"></span><br><span class="line">Float i11 = 333f;</span><br><span class="line">Float i22 = 333f;</span><br><span class="line">System.out.println(i11 == i22);// 输出 false</span><br><span class="line"></span><br><span class="line">Double i3 = 1.2;</span><br><span class="line">Double i4 = 1.2;</span><br><span class="line">System.out.println(i3 == i4);// 输出 false</span><br></pre></td></tr></table></figure>

<p>下面我们来看一下问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Integer i1 = 40;</span><br><span class="line">Integer i2 = new Integer(40);</span><br><span class="line">System.out.println(i1 == i2);</span><br></pre></td></tr></table></figure>

<p><code>Integer i1 = 40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1 = Integer.valueOf(40)</code>。因此，<code>i1</code> 直接使用的是缓存中的对象。而 <code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code>。</p>
<p><strong>记住：所有整型包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较。</strong></p>
<h3 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h3><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱：</strong>将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱：</strong>将包装类型转换为基本数据类型</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Integer i = 10; // 装箱</span><br><span class="line">int n = i; // 拆箱</span><br></pre></td></tr></table></figure>

<p>上面这两行代码对应的字节码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER 8 L1</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> BIPUSH 10</span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER 9 L2</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>从字节码中，我们发现装箱其实就是调用了包装类的 <code>valueOf</code> 方法，拆箱其实就是调用了 <code>xxxValue()</code> 方法。</p>
<p>因此：</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>；</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h3 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><p>浮点数运算精度丢失代码演示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">float a = 2.0f - 1.9f;</span><br><span class="line">float b = 1.8f - 1.7f;</span><br><span class="line">System.out.println(a); // 0.100000024</span><br><span class="line">System.out.println(b);// 0.099999905</span><br><span class="line">System.out.println(a == b); // false</span><br></pre></td></tr></table></figure>

<p>为什么会出现这个问题呢？</p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储再计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>就比如说十进制下的 0.2 就没办法精确转换为二进制小数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span><br><span class="line">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">0.8 * 2 = 1.6 -&gt; 1</span><br><span class="line">0.6 * 2 = 1.2 -&gt; 1</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关于浮点数的更多内容，建议看一下<a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础（四）浮点数</a>这篇文章。</p>
<h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部门需要将浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">BigDecimal a = new BigDecimal(&quot;1.0&quot;);</span><br><span class="line">BigDecimal b = new BigDecimal(&quot;0.9&quot;);</span><br><span class="line">BigDecimal c = new BigDecimal(&quot;0.8&quot;);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b);</span><br><span class="line">BigDecimal y = b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); /* 0.1 */</span><br><span class="line">System.out.println(y); /* 0.1 */</span><br><span class="line">System.out.println(Objects.equals(x, y)); /* true */</span><br></pre></td></tr></table></figure>

<h3 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>
<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">long l = Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + 1); // -9223372036854775808</span><br><span class="line">System.out.println(l + 1 == Long.MIN_VALUE); // true</span><br></pre></td></tr></table></figure>

<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整型数据。</p>
<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>
<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题；</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题；</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供外界访问的方法，那么这个类也没有什么意义了。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码地重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，<strong>只是拥有</strong></li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展</li>
<li>子类可以用自己的方式实现父类的方法（以后介绍）</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类打得引用指向子类的实例。</p>
<p><strong>多态的特点：</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><p><strong>共同点：</strong></p>
<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>接口主要用于对类的行为进行约束，你是实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系</li>
<li>一个类只能继承一个类，但是可以实现多个接口</li>
<li>接口中成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认是 <code>default</code>，可在子类中被重新定义，也可被重新赋值</li>
</ul>
<h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>结论：</p>
<ul>
<li><strong>浅拷贝：</strong>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是拷贝对象和原对象共用同一个内部对象</li>
<li><strong>浅拷贝：</strong>深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</li>
</ul>
<p>案例：</p>
<p><strong>浅拷贝</strong></p>
<p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>
<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    // 省略构造函数、Getter&amp;Setter方法</span><br><span class="line">    @Override</span><br><span class="line">    public Address clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Address) super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">    private Address address;</span><br><span class="line">    // 省略构造函数、Getter&amp;Setter方法</span><br><span class="line">    @Override</span><br><span class="line">    public Person clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Person person = (Person) super.clone();</span><br><span class="line">            return person;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">// true</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出，<code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<p><strong>深拷贝</strong></p>
<p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Override</span><br><span class="line">public Person clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Person person = (Person) super.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        return person;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">// false</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结果就可以看出，虽然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<p><strong>那什么是引用拷贝呢？</strong>简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p>下图可以描述浅拷贝、深拷贝、引用拷贝：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221122165417.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221122165417.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></a></p>
<h2 id="Java-常见类"><a href="#Java-常见类" class="headerlink" title="Java 常见类"></a>Java 常见类</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是所有类的父类。主要提供有以下 11 个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="line"> */</span><br><span class="line">public final native Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="line"> */</span><br><span class="line">public native int hashCode();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="line"> */</span><br><span class="line">public boolean equals(Object obj);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="line"> */</span><br><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="line"> */</span><br><span class="line">public String toString();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="line"> */</span><br><span class="line">public final native void notify();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="line"> */</span><br><span class="line">public final native void notifyAll();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="line"> */</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span><br><span class="line"> */</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="line"> */</span><br><span class="line">public final void wait() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="line"> */</span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="x3D-x3D-和-equals-的区别？"><a href="#x3D-x3D-和-equals-的区别？" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别？"></a>&#x3D;&#x3D; 和 equals() 的区别？</h4><p><code>==</code> 对于基本类型来和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值</li>
<li>对于引用类型来说，<code>==</code> 比较的是对象的内存地址</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code> 方法存在于 <code>Object</code> 类中，而 <code>Object</code> 类是所有类的直接或间接父类，因此所有的类都有 <code>equals()</code> 方法。</p>
<p><code>Object</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">     return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code> 方法</strong>：通过 <code>equals()</code> 方法比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code> 类 <code>equals()</code> 方法。</li>
<li><strong>类重写了 <code>equals()</code> 方法</strong>：一般我们都重写 <code>equals()</code> 方法来比较两个对象中属性是否相等；若它们的属性相等，则返回 <code>true</code>（即认为这两个对象相等）。</li>
</ul>
<p><code>String</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a>hashCode() 有什么用？</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数）</p>
]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成工具之 Jenkins</title>
    <url>/2022/09/27/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7%E4%B9%8B%20Jenkins/</url>
    <content><![CDATA[<h2 id="持续集成及-Jenkins-介绍"><a href="#持续集成及-Jenkins-介绍" class="headerlink" title="持续集成及 Jenkins 介绍"></a>持续集成及 Jenkins 介绍</h2><h3 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h3><p>软件开发生命周期又叫做<strong>SDLC</strong>（Software Development Life Cycle），它是集合了计划、开发、测试 和部署过程的集合。如下图所示 ：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309153101.png" alt="image-20220309153101326"></p>
<ul>
<li>需求分析</li>
</ul>
<p>这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部 或者客户提出的。这阶段主要是对信息的收集，也有可能是对现有项目的改善和重新做一个新的项目。 还要分析项目的预算多长，可以从哪方面受益及布局，这也是项目创建的目标。</p>
<ul>
<li>设计</li>
</ul>
<p>第二阶段就是设计阶段，系统架构和满意状态（就是要做成什么样子，有什么功能），和创建一个项目 计划。计划可以使用图表，布局设计或者文者的方式呈现。</p>
<ul>
<li>实现</li>
</ul>
<p>第三阶段就是实现阶段，项目经理创建和分配工作给开者，开发者根据任务和在设计阶段定义的目标进 行开发代码。依据项目的大小和复杂程度，可以需要数月或更长时间才能完成。</p>
<ul>
<li>测试</li>
</ul>
<p>测试人员进行代码测试 ，包括功能测试、代码测试、压力测试等。</p>
<ul>
<li>进化</li>
</ul>
<p>最后进阶段就是对产品不断的进化改进和维护阶段，根据用户的使用情况，可能需要对某功能进行修 改，bug 修复，功能增加等。</p>
<h3 id="软件开发瀑布模型"><a href="#软件开发瀑布模型" class="headerlink" title="软件开发瀑布模型"></a>软件开发瀑布模型</h3><p>瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁 衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有 其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开发，但是已经不适合现在的开发了。</p>
<p>下图对软件开发模型的一个阐述。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309154059.png" alt="image-20220309154059145"></p>
<table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>简单易用和理解</td>
<td>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。</td>
</tr>
<tr>
<td>当前一阶段完成后，您只需要去关注后续阶段。</td>
<td>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。</td>
</tr>
<tr>
<td>为项目提供了按阶段划分的检查节点</td>
<td>瀑布模型的突出缺点是不适应用户需求的变化。</td>
</tr>
</tbody></table>
<h3 id="软件的敏捷开发"><a href="#软件的敏捷开发" class="headerlink" title="软件的敏捷开发"></a>软件的敏捷开发</h3><h4 id="什么是敏捷开发？"><a href="#什么是敏捷开发？" class="headerlink" title="什么是敏捷开发？"></a>什么是敏捷开发？</h4><p>敏捷开发（Agile Development）的核心是迭代开发（Iterative Development）与 增量开发（Incremental Development）。</p>
<ul>
<li><strong>何为迭代开发</strong>？</li>
</ul>
<p>对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次“大开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次“大开发”变成多次“小开发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。</p>
<ul>
<li><strong>何为增量开发</strong>？</li>
</ul>
<p>软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。</p>
<h4 id="敏捷开发如何迭代？"><a href="#敏捷开发如何迭代？" class="headerlink" title="敏捷开发如何迭代？"></a>敏捷开发如何迭代？</h4><p>虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309154857.png" alt="image-20220309154857660"></p>
<h4 id="敏捷开发有什么好处？"><a href="#敏捷开发有什么好处？" class="headerlink" title="敏捷开发有什么好处？"></a>敏捷开发有什么好处？</h4><ul>
<li><strong>早期交付</strong></li>
</ul>
<p>敏捷开发的第一个好处，就是早期交付，从而大大降低成本。</p>
<ul>
<li><strong>降低风险</strong></li>
</ul>
<p>敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。</p>
<h3 id="什么是持续集成？"><a href="#什么是持续集成？" class="headerlink" title="什么是持续集成？"></a>什么是持续集成？</h3><p>持续集成（Continuous integration，简称 CI）指的是，频繁地（一天多次）将代码集成到主干。</p>
<p><strong>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。</strong>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
<p>通过持续集成，团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归功于持续集成。</p>
<p><strong>持续集成的流程</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309155459.png" alt="image-20220309155459830"></p>
<p>根据持续集成的设计，代码从提交到生产，整个过程有以下几步。</p>
<ul>
<li>提交</li>
</ul>
<p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p>
<ul>
<li>测试（第一轮）</li>
</ul>
<p>代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。</p>
<ul>
<li>构建</li>
</ul>
<p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p>
<p>交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS 脚本、图片）等等。</p>
<ul>
<li>测试（第二轮）</li>
</ul>
<p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p>
<ul>
<li>部署</li>
</ul>
<p>过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。</p>
<ul>
<li>回滚</li>
</ul>
<p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指 向上一个版本的目录。</p>
<h3 id="持续集成的组成要素"><a href="#持续集成的组成要素" class="headerlink" title="持续集成的组成要素"></a>持续集成的组成要素</h3><ul>
<li>一个自动构建过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，无需人工干预。</li>
<li>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般使用 SVN 或 Git。</li>
<li>一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器。</li>
</ul>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309165502.png" alt="image-20220309165502124"></p>
<h3 id="持续集成的好处"><a href="#持续集成的好处" class="headerlink" title="持续集成的好处"></a>持续集成的好处</h3><ol>
<li>降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少；</li>
<li>对系统健康持续检查，减少发布风险带来的问题；</li>
<li>减少重复性工作；</li>
<li>持续部署，提供可部署单元包；</li>
<li>持续交付可供使用的版本；</li>
<li>增强团队信心；</li>
</ol>
<h3 id="Jenkins-介绍"><a href="#Jenkins-介绍" class="headerlink" title="Jenkins 介绍"></a>Jenkins 介绍</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309165729.png" alt="image-20220309165729929"></p>
<p>Jenkins 是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动 化构建、测试和部署等功能。官网：<a href="https://www.jenkins.io/">Jenkins</a>。</p>
<p><strong>Jenkins 的特征：</strong></p>
<ul>
<li>开源的 Java 语言开发持续集成工具，支持持续集成，持续部署。</li>
<li>易于安装部署配置：可通过 yum 安装,或下载 war 包以及通过 docker 容器等快速实现安装部署，可方便 web 界面配置管理。</li>
<li>消息通知及测试报告：集成 RSS&#x2F;E-mail 通过 RSS 发布构建结果或当构建完成时通过 e-mail 通知，生成 JUnit&#x2F;TestNG 测试报告。</li>
<li>分布式构建：支持 Jenkins 能够让多台计算机一起构建&#x2F;测试。</li>
<li>文件识别：Jenkins 能够跟踪哪次构建生成哪些 jar，哪次构建使用哪个版本的 jar 等。</li>
<li>丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如 git，svn，maven，docker 等。</li>
</ul>
<h2 id="Jenkins-安装与配置"><a href="#Jenkins-安装与配置" class="headerlink" title="Jenkins 安装与配置"></a>Jenkins 安装与配置</h2><h3 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h3><blockquote>
<p><a href="https://www.jenkins.io/zh/doc/book/installing/">Jenkins 官方安装文档</a></p>
</blockquote>
<p><strong>Docker 安装 Jenkins（推荐）</strong></p>
<ul>
<li><p>Docker 安装与配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 1、卸载旧的版本</span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"># 2、需要的安装包</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"># 3、设置镜像的仓库</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的，十分慢！</span><br><span class="line"># 建议使用阿里云的镜像地址</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 更新yum软件包索引</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"># 4、安装docker相关的 docker-ce 社区版 ee 企业版</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"># 5、启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 6、使用docker version查看是否安装成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Docker 安装 Jenkins</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line"># 使用命令直接安装</span><br><span class="line">docker run -d --name jenkins --restart always \</span><br><span class="line">--user root -p 8180:8080 -p 51000:50000 \</span><br><span class="line">-v /var/jenkins_home:/var/jenkins_home \</span><br><span class="line">-v /opt/maven/apache-maven-3.6.3:/opt/maven/apache-maven-3.6.3 \</span><br><span class="line">-v /usr/local/java/jdk1.8.0_251:/usr/local/java/jdk1.8.0_251 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>War 安装 Jenkins</strong></p>
<ul>
<li>获取 Jenkins 安装包</li>
</ul>
<p>下载页面：<a href="https://jenkins.io/zh/download/">https://jenkins.io/zh/download/</a></p>
<p>安装文件：jenkins.war</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARDUINO</span><br><span class="line">1、将最新的稳定Jenkins WAR包 下载到您计算机上的相应目录。</span><br><span class="line"></span><br><span class="line">2、在下载的目录内打开一个终端/命令提示符窗口到。</span><br><span class="line"></span><br><span class="line">3、运行命令java -jar jenkins.war</span><br><span class="line"></span><br><span class="line">4、浏览http://localhost:8080并等到*Unlock Jenkins*页面出现。</span><br><span class="line"></span><br><span class="line">5、继续使用Post-installation setup wizard后面步骤设置向导。</span><br></pre></td></tr></table></figure>

<p><strong>解锁 Jenkins</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309174609.png" alt="image-20220309174609417"></p>
<p>获取并输入 admin 账户密码（我这里是 docker 安装的，目录是映射到指定位置的，密码实际存放路径以提示为主）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>

<p><strong>跳过插件安装</strong></p>
<p>因为 Jenkins 插件需要连接默认官网下载，速度非常慢，而且容易安装失败，所以我们暂时先跳过插件安装。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309174531.png" alt="image-20220309174531892"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309174831.png" alt="image-20220309174831016"></p>
<p><strong>添加一个管理员账户，并进入 Jenkins 后台</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309174954.png" alt="image-20220309174953956"></p>
<p><strong>保存并完成</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309175748.png" alt="image-20220309175748708"></p>
<p><strong>开始使用 Jenkins</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309175816.png" alt="image-20220309175816074"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309175908.png" alt="image-20220309175908276"></p>
<h3 id="Jenkins-插件管理"><a href="#Jenkins-插件管理" class="headerlink" title="Jenkins 插件管理"></a>Jenkins 插件管理</h3><p>Jenkins 本身不提供很多功能，我们可以通过使用插件来满足我们的使用。例如从 Gitlab 拉取代码，使用 Maven 构建项目等功能需要依靠插件完成。接下来演示如何下载插件。</p>
<p><strong>修改 Jenkins 插件下载地址</strong></p>
<p>Jenkins 国外官方插件地址下载速度非常慢，所以可以修改为国内插件地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins，点击Available</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309180153.png" alt="image-20220309180153473"></p>
<p>这样做是为了把 Jenkins 官方的插件列表下载到本地，接着修改地址文件，替换为国内插件地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JBOSS-CLI</span><br><span class="line"># 进入配置目录 （目录视情况而定，安装的jenkins_home下）</span><br><span class="line">cd /var/jenkins_home/updates</span><br><span class="line"></span><br><span class="line"># 执行命令</span><br><span class="line">sed -i &#x27;s/http:\/\/updates.jenkinsci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27; default.json &amp;&amp; sed -i &#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27; default.json</span><br></pre></td></tr></table></figure>

<p>最后，Manage Plugins 点击 Advanced，把 Update Site 改为国内插件下载地址</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309180807.png" alt="image-20220309180807037"></p>
<p>Sumbit 后，在浏览器输入： <a href="http://120.78.204.65:8180/restart">http://120.78.204.65:8180/restart</a> ，重启 Jenkins。</p>
<p><strong>下载中文汉化插件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins，点击Available，搜索&quot;Chinese&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181055.png" alt="image-20220309181055822"></p>
<p>完成后如下图所示：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181122.png" alt="image-20220309181122066"></p>
<p>重启 Jenkins 之后，就看到 Jenkins 汉化了！（PS：某些菜单可能会汉化失败）</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181408.png" alt="image-20220309181408200"></p>
<h3 id="Jenkins-用户权限管理"><a href="#Jenkins-用户权限管理" class="headerlink" title="Jenkins 用户权限管理"></a>Jenkins 用户权限管理</h3><p>我们可以利用<code>Role-based Authorization Strategy</code>插件来管理 Jenkins 用户权限</p>
<p><strong>安装 Role-based Authorization Strategy 插件</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181600.png" alt="image-20220309181600238"></p>
<p><strong>开启权限全局安全配置</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181914.png" alt="image-20220309181914873"></p>
<p>授权策略切换为”Role-Based Strategy”，保存</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181940.png" alt="image-20220309181940124"></p>
<p><strong>创建角色</strong></p>
<p>在系统管理页面进入 Manage and Assign Roles</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182209.png" alt="image-20220309182209559"></p>
<p>点击”Manage Roles”</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182301.png" alt="image-20220309182301430"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182435.png" alt="image-20220309182435102"></p>
<p><code>Global roles（全局角色）</code>：管理员等高级用户可以创建基于全局的角色</p>
<p><code>Item roles（项目角色）</code>： 针对某个或者某些项目的角色</p>
<p><code>Node roles（节点角色）</code>：节点相关的权限</p>
<p>我们添加以下三个角色：</p>
<ul>
<li>baseRole：该角色为全局角色。这个角色需要绑定 Overall 下面的 Read 权限，是为了给所有用户绑定最基本的 Jenkins 访问权限。注意：如果不给后续用户绑定这个角色，会报错误：<code>用户名 is missing the Overall/Read permission</code></li>
<li>role1：该角色为项目角色。使用正则表达式绑定”vx-chx.*“，意思是只能操作 vx-chx 开头的项目。</li>
<li>role2：该角色为项目角色。使用正则表达式绑定”vx-phm.*“，意思是只能操作 vx-phm 开头的项目。</li>
</ul>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182812.png" alt="image-20220309182812353"></p>
<p>保存</p>
<p><strong>创建用户</strong></p>
<p>在系统管理页面进入 Manage Users</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182917.png" alt="image-20220309182917026"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309183107.png" alt="image-20220309183107565"></p>
<p>分别创建两个用户：vxchx 和 vxphm</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309183223.png" alt="image-20220309183223041"></p>
<p><strong>给用户分配角色</strong></p>
<p>系统管理页面进入 Manage and Assign Roles，点击 Assign Roles</p>
<p>绑定规则如下：</p>
<ul>
<li><p>vxchx 用户分别绑定 baseRole 和 role1 角色</p>
</li>
<li><p>vxphm 用户分别绑定 baseRole 和 role2 角色</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309183455.png" alt="image-20220309183455591"></p>
</li>
</ul>
<p>保存</p>
<p><strong>创建项目测试权限</strong></p>
<p>以 admin 管理员账户创建两个项目，分别为 vx-chx-test 和 vx-phm-test</p>
<p>结果为： vxchx 用户登录，只能看到 vx-chx-test 项目 vxphm 用户登录，只能看到 vx-phm-test 项目</p>
<h3 id="Jenkins-凭证管理"><a href="#Jenkins-凭证管理" class="headerlink" title="Jenkins 凭证管理"></a>Jenkins 凭证管理</h3><p>凭据可以用来存储需要密文保护的数据库密码、Gitlab 密码信息、Docker 私有仓库密码等，以便 Jenkins 可以和这些第三方的应用进行交互。</p>
<p><strong>安装 Credentials Binding 插件</strong></p>
<p>要在 Jenkins 使用凭证管理功能，需要安装<code>Credentials Binding</code>插件</p>
<blockquote>
<p>注：新版本已经默认安装了此插件，这里无需另外再安装了</p>
</blockquote>
<p>系统管理中选择 <code>Manage Credentials</code></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309184117.png" alt="image-20220309184117479"></p>
<p>可以添加的凭证有 5 种：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309184218.png" alt="image-20220309184218399"></p>
<ul>
<li>Username with password：用户名和密码</li>
<li>SSH Username with private key： 使用 SSH 用户和密钥</li>
<li>Secret file：需要保密的文本文件，使用时 Jenkins 会将文件复制到一个临时目录中，再将文件路径 设置到一个变量中，等构建结束后，所复制的 Secret file 就会被删除。</li>
<li>GitHub App：GitHub 的 API 令牌</li>
<li>Secret text：需要保存的一个加密的文本串，如钉钉机器人或 Github 的 api token</li>
<li>Certificate：通过上传证书文件的方式</li>
</ul>
<p>常用的凭证类型有：<strong>Username with password（用户密码）</strong>和 <strong>SSH Username with private key（SSH 密钥）</strong></p>
<p>接下来以使用 Git 工具到 Gitlab 拉取项目源码为例，演示 Jenkins 的如何管理 Gitlab 的凭证。</p>
<p><strong>安装 Git 插件和 Git 工具</strong></p>
<p>为了让 Jenkins 支持从 Gitlab 拉取源码，需要安装 Git 插件以及在服务器上安装 Git 工具。</p>
<p>Git 插件安装：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310094719.png" alt="image-20220310094712046"></p>
<p>服务器上安装 Git 工具（以 CentOS7 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 安装</span><br><span class="line">yum install git -y</span><br><span class="line"># 安装后查看版本</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p><strong>用户密码类型</strong></p>
<p>1）创建凭据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; 凭证 -&gt; 系统 -&gt; 全局凭据 -&gt; 添加凭据</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310095750.png" alt="image-20220310095750604"></p>
<p>选择”Username with password”，输入 Gitlab 的用户名和密码，点击”确定”。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310100359.png" alt="image-20220310100359012"></p>
<p><strong>SSH 密钥类型</strong></p>
<p>SSH 免密登录示意图</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310100539.png" alt="image-20220310100539140"></p>
<p>1）使用 root 用户生成公钥和私钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>在&#x2F;root&#x2F;.ssh&#x2F;目录保存了公钥和使用</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310101013.png" alt="image-20220310101013313"></p>
<p>id_rsa：私钥文件</p>
<p>id_rsa.pub：公钥文件</p>
<p>2）把生成的公钥放在 Gitlab 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">登录gitlab -&gt; 点击头像 -&gt; Settings -&gt; SSH Keys</span><br></pre></td></tr></table></figure>

<p>复制刚才 id_rsa.pub 文件的内容到这里，点击”Add Key”</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310101538.png" alt="image-20220310101538008"></p>
<p>3）在 Jenkins 中添加凭证，配置私钥</p>
<p>在 Jenkins 添加一个新的凭证，类型为”SSH Username with private key”，把刚才生成私有文件内容复制过来</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310102203.png" alt="image-20220310102203814"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310102427.png" alt="image-20220310102427213"></p>
<h3 id="Jenkins-关联-JDK-和-Maven"><a href="#Jenkins-关联-JDK-和-Maven" class="headerlink" title="Jenkins 关联 JDK 和 Maven"></a>Jenkins 关联 JDK 和 Maven</h3><p><strong>关联 JDK</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; 系统管理 -&gt; 全局工具配置 -&gt; JDK -&gt; 新增JDK，配置如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310102744.png" alt="image-20220310102744563"></p>
<p><strong>关联 Maven</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; 系统管理 -&gt; 全局工具配置 -&gt; Maven -&gt; 新增Maven，配置如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310102836.png" alt="image-20220310102835922"></p>
<h3 id="添加-Jenkins-全局变量"><a href="#添加-Jenkins-全局变量" class="headerlink" title="添加 Jenkins 全局变量"></a><strong>添加 Jenkins 全局变量</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; 系统管理 -&gt; 全局属性 -&gt; 添加三个环境变量，配置如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310103242.png" alt="image-20220310103241974"></p>
<h3 id="Jenkins-关闭跨站请求伪造保护"><a href="#Jenkins-关闭跨站请求伪造保护" class="headerlink" title="Jenkins 关闭跨站请求伪造保护"></a>Jenkins 关闭跨站请求伪造保护</h3><ul>
<li>Docker 容器运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APPLESCRIPT</span><br><span class="line"># 1、进入运行的容器</span><br><span class="line">docker exec -u root -it 你的Jenkins容器名称或者容器id bash</span><br><span class="line"></span><br><span class="line"># 2、输入命令，编辑jenkins启动配置文件</span><br><span class="line">vi /usr/local/bin/jenkins.sh</span><br><span class="line"></span><br><span class="line"># 3、在图中标记处，加入以下配置</span><br><span class="line">-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true</span><br><span class="line"></span><br><span class="line"># 4、重启容器</span><br><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220312001027.png" alt="image-20220312001020531"></p>
<h2 id="Jenkins-构建-Maven-项目"><a href="#Jenkins-构建-Maven-项目" class="headerlink" title="Jenkins 构建 Maven 项目"></a>Jenkins 构建 Maven 项目</h2><blockquote>
<p>构建方式均采用 Jar 包方式，War 方式参考<a href="http://doc.jeecg.com/2043887">WAR 部署方案 · JeecgBoot 开发文档</a></p>
</blockquote>
<h3 id="Jenkins-项目构建类型"><a href="#Jenkins-项目构建类型" class="headerlink" title="Jenkins 项目构建类型"></a>Jenkins 项目构建类型</h3><p>Jenkins 中自动构建项目的类型有很多，常用的有以下三种：</p>
<ul>
<li>自由风格软件项目（FreeStyle Project）</li>
<li>Maven 项目（Maven Project）</li>
<li>流水线项目（Pipeline Project）</li>
</ul>
<p>每种类型的构建其实都可以完成一样的构建过程与结果，只是在操作方式、灵活度等方面有所区别，在实际开发中可以根据自己的需求和习惯来选择。（PS：个人推荐使用流水线类型，因为灵活度非常高）</p>
<h3 id="自由风格项目构建"><a href="#自由风格项目构建" class="headerlink" title="自由风格项目构建"></a>自由风格项目构建</h3><p>下面演示创建一个自由风格项目来完成项目的集成过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拉取代码 -&gt; 编译 -&gt; 打包 -&gt; 部署</span><br></pre></td></tr></table></figure>

<p><strong>拉取代码</strong></p>
<p>1）创建项目</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310112707.png" alt="image-20220310112707895"></p>
<p>2）源码管理，从 Gitlab 拉取代码</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310112815.png" alt="image-20220310112815147"></p>
<p><strong>编译打包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构建 -&gt; 添加构建步骤 -&gt; 执行shell</span><br><span class="line">BASH</span><br><span class="line">echo &quot;开始编译和打包&quot;</span><br><span class="line">mvn clean package</span><br><span class="line">echo &quot;编译和打包结束&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310112952.png" alt="image-20220310112952936"></p>
<p><strong>部署</strong></p>
<p>把项目部署到远程的服务器上，并启动</p>
<p>1）安装<code>Publish Over SSH</code>插件</p>
<p>Jenkins 本身无法实现远程部署到服务器上的功能，需要安装<code>Publish Over SSH</code>插件实现</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310113332.png" alt="image-20220310113332137"></p>
<p>2）配置<code>Publish over SSH</code>，添加 SSH 服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开系统管理 -&gt; 系统配置 -&gt; 拉到底部，选择Publish over SSH区域选择新增</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310114012.png" alt="image-20220310114012322"></p>
<p><code>点击高级 -&gt; 填写服务器密码</code>（也可选择 ssh 验证，在 Jenkins 中配置本机私钥，将公钥发送到目标机器，即可完成无密码登录）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送命令：ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.xxx.xxx</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310114702.png" alt="image-20220310114702171"></p>
<ul>
<li>Passphrase： 密码（目标机器的密码）</li>
<li>Path to key：key 文件（私钥）的路径</li>
<li>SSH Server Name： 标识的名字（随便你取什么）</li>
<li>Hostname： 需要连接 ssh 的主机名或 ip 地址，此处填写应用服务器 IP（建议 ip）</li>
<li>Username： 用户名</li>
<li>Remote Directory： 远程目录(要发布的目录,比如&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;)</li>
</ul>
<p>3）添加构建步骤</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310115055.png" alt="image-20220310115055853"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310115245.png" alt="image-20220310115245384"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APACHE</span><br><span class="line"># 脚本参考</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">cd /apps</span><br><span class="line">ps -ef|grep jeecg-boot-module-system-3.1.0.jar|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -s 9</span><br><span class="line">BUILD_ID=dontKillMe</span><br><span class="line">nohup java -jar jeecg-boot-module-system-3.1.0.jar &gt; jeecg-boot-module-system-3.1.0.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>4）点击”立即构建”，开始构建过程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310115628.png" alt="image-20220310115628609"></p>
<p>5）构建成功，并自动化部署，访问测试！</p>
<h3 id="Maven-项目构建"><a href="#Maven-项目构建" class="headerlink" title="Maven 项目构建"></a>Maven 项目构建</h3><p>1）安装 Maven Integration Plugin（高版本的 Jenkins 已预装了此插件）</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310135008.png" alt="image-20220310135008339"></p>
<p>2）创建 Maven 项目</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310135103.png" alt="image-20220310135103444"></p>
<p>3）配置项目</p>
<p>拉取代码和远程部署的过程和自由风格项目一样，只是”构建”部分不同</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310135300.png" alt="image-20220310135300799"></p>
<h3 id="Pipeline-流水线项目构建"><a href="#Pipeline-流水线项目构建" class="headerlink" title="Pipeline 流水线项目构建(*)"></a>Pipeline 流水线项目构建(*)</h3><h4 id="Pipeline-简介"><a href="#Pipeline-简介" class="headerlink" title="Pipeline 简介"></a>Pipeline 简介</h4><p><strong>1）概念</strong></p>
<p>Pipeline，简单来说，就是一套运行在 Jenkins 上的工作流框架，将原来独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排和可视化的工作。</p>
<p><strong>2）使用 Pipeline 有以下好处（来自翻译自官方文档）：</strong></p>
<p>代码：Pipeline 以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流 程。持久：无论是计划内的还是计划外的服务器重启。Pipeline 都是可恢复的。可停止：Pipeline 可接 收交互式输入，以确定是否继续执行 Pipeline。多功能：Pipeline 支持现实世界中复杂的持续交付要求。它支持 fork&#x2F;join、循环执行，并行执行任务的功能。可扩展：Pipeline 插件支持其 DSL 的自定义扩展，以及与其他插件集成的多个选项。</p>
<p><strong>3）如何创建 Jenkins Pipeline 呢？</strong></p>
<ul>
<li>Pipeline 脚本是由<strong>Groovy</strong>语言实现的，但是我们没必要单独去学习 Groovy</li>
<li>Pipeline 支持两种语法：<strong>Declarative</strong>(声明式)和<strong>Scripted Pipeline</strong>(脚本式)语法</li>
<li>Pipeline 也有两种创建方法：可以直接在 Jenkins 的 Web UI 界面中输入脚本；也可以通过创建一个 Jenkinsfile 脚本文件放入项目源码库中（一般我们都推荐在 Jenkins 中直接从源代码控制(SCM)中直接载入 Jenkinsfile Pipeline 这种方法）。</li>
</ul>
<h4 id="Pipeline-语法快速入门"><a href="#Pipeline-语法快速入门" class="headerlink" title="Pipeline 语法快速入门"></a>Pipeline 语法快速入门</h4><p><strong>1）Declarative 声明式-Pipeline</strong></p>
<p>创建一个流水线项目</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310154144.png" alt="image-20220310154144897"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">流水线 -&gt; 选择HelloWorld模板</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310154618.png" alt="image-20220310154618000"></p>
<p>生成的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROOVY</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Hello&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Hello World&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>stages：</strong>代表整个流水线的所有执行阶段。通常 stages 只有 1 个，里面包含多个 stage</li>
<li><strong>stage：</strong>代表流水线中的某个阶段，可能出现 n 个。一般分为拉取代码，编译构建，部署等阶段。</li>
<li><strong>steps：</strong>代表一个阶段内需要执行的逻辑。steps 里面是 shell 脚本，git 拉取代码，ssh 远程发布等任意内容。</li>
</ul>
<p>编写一个简单声明式的 Pipeline：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROOVY</span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;拉取代码&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">            	echo &#x27;拉取代码&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;编译构建&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">            	echo &#x27;编译构建&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;项目部署&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">            	echo &#x27;项目部署&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击构建，进入<code>Blue Ocean</code>可以看到整个构建过程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310155756.png" alt="image-20220310155756052"></p>
<p><strong>2）Scripted Pipeline 脚本式-Pipeline</strong></p>
<p>创建项目</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310155938.png" alt="image-20220310155938728"></p>
<p>选择 <code>Scripted Pipeline&quot;</code></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310160044.png" alt="image-20220310160044398"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROOVY</span><br><span class="line">node &#123;</span><br><span class="line">    def mvnHome</span><br><span class="line">    stage(&#x27;Preparation&#x27;) &#123; // for display purposes</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    stage(&#x27;Build&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    stage(&#x27;Results&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Node：节点，一个 Node 就是一个 Jenkins 节点，Master 或者 Agent，是执行 Step 的具体运行环境，后续讲到 Jenkins 的 Master-Slave 架构的时候用到。</li>
<li>Stage：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作，比如： Build、Test、Deploy，Stage 是一个逻辑分组的概念。</li>
<li>Step：步骤，Step 是最基本的操作单元，可以是打印一句话，也可以是构建一个 Docker 镜像， 由各类 Jenkins 插件提供，比如命令：sh ‘make’，就相当于我们平时 shell 终端中执行 make 命令 一样。</li>
</ul>
<p>编写一个简单的脚本式 Pipeline</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVASCRIPT</span><br><span class="line">node &#123;</span><br><span class="line">    def mvnHome</span><br><span class="line">    stage(&#x27;拉取代码&#x27;) &#123; // for display purposes</span><br><span class="line">    	echo &#x27;拉取代码&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(&#x27;编译构建&#x27;) &#123;</span><br><span class="line">    	echo &#x27;编译构建&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(&#x27;项目部署&#x27;) &#123;</span><br><span class="line">    	echo &#x27;项目部署&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建结果和声明式一样！</p>
<p><strong>Pipeline Script from SCM</strong></p>
<p>刚才我们都是直接在 Jenkins 的 UI 界面编写 Pipeline 代码，这样不方便脚本维护，建议把 Pipeline 脚本放在项目中（一起进行版本控制）</p>
<p><strong>1）在项目根目录建立 Jenkinsfile 文件，把内容复制到该文件中</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310163924.png" alt="image-20220310163924603"></p>
<p>把 Jenkinsfile 上传到 Gitlab</p>
<p><strong>2）在项目中引用该文件</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310164207.png" alt="image-20220310164207097"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310164225.png" alt="image-20220310164225747"></p>
<h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><h4 id="Jenkinsfile-环境变量"><a href="#Jenkinsfile-环境变量" class="headerlink" title="Jenkinsfile 环境变量"></a>Jenkinsfile 环境变量</h4><table>
<thead>
<tr>
<th>环境变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BRANCH_NAME</td>
<td>在 multibranch 项目中，BRANCH_NAME 用于标明构建分支的名称。</td>
</tr>
<tr>
<td>CHANGE_ID</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明变更 ID，比如 Pull Request</td>
</tr>
<tr>
<td>CHANGE_URL</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明变更的 URL</td>
</tr>
<tr>
<td>CHANGE_TITLE</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明变更的标题</td>
</tr>
<tr>
<td>CHANGE_AUTHOR</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明提交变更的人员的名称</td>
</tr>
<tr>
<td>CHANGE_AUTHOR_DISPLAY_NAME</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明提交变更的人员的显示名称</td>
</tr>
<tr>
<td>CHANGE_AUTHOR_EMAIL</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明提交变更的人员的邮件地址</td>
</tr>
<tr>
<td>CHANGE_TARGET</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于合并后的分支信息等</td>
</tr>
<tr>
<td>BUILD_NUMBER</td>
<td>当前的构建编号</td>
</tr>
<tr>
<td>BUILD_ID</td>
<td>在 1.597 版本后引进，表示当前构建 ID</td>
</tr>
<tr>
<td>BUILD_DISPLAY_NAME</td>
<td>当前构建的显示信息</td>
</tr>
<tr>
<td>JOB_NAME</td>
<td>构建 Job 的全称，包含项目信息</td>
</tr>
<tr>
<td>JOB_BASE_NAME</td>
<td>除去项目信息的 Job 名称</td>
</tr>
<tr>
<td>BUILD_TAG</td>
<td>构建标签</td>
</tr>
<tr>
<td>EXECUTOR_NUMBER</td>
<td>执行器编号，用于标识构建器的不同编号</td>
</tr>
<tr>
<td>NODE_NAME</td>
<td>构建节点的名称</td>
</tr>
<tr>
<td>NODE_LABELS</td>
<td>节点标签</td>
</tr>
<tr>
<td>WORKSPACE</td>
<td>构建时使用的工作空间的绝对路径</td>
</tr>
<tr>
<td>JENKINS_HOME</td>
<td>JENKINS 根目录的绝对路径</td>
</tr>
<tr>
<td>JENKINS_URL</td>
<td>Jenkins 的 URL 信息</td>
</tr>
<tr>
<td>BUILD_URL</td>
<td>构建的 URL 信息</td>
</tr>
<tr>
<td>JOB_URL</td>
<td>构建 Job 的 URL 信息</td>
</tr>
<tr>
<td>GIT_COMMIT</td>
<td>git 提交的 hash 码</td>
</tr>
<tr>
<td>GIT_PREVIOUS_COMMIT</td>
<td>当前分支上次提交的 hash 码</td>
</tr>
<tr>
<td>GIT_PREVIOUS_SUCCESSFUL_COMMIT</td>
<td>当前分支上次成功构建时提交的 hash 码</td>
</tr>
<tr>
<td>GIT_BRANCH</td>
<td>远程分支名称</td>
</tr>
<tr>
<td>GIT_LOCAL_BRANCH</td>
<td>本地分支名称</td>
</tr>
<tr>
<td>GIT_URL</td>
<td>远程 URL 地址</td>
</tr>
<tr>
<td>GIT_COMMITTER_NAME</td>
<td>Git 提交者的名称</td>
</tr>
<tr>
<td>GIT_AUTHOR_NAME</td>
<td>Git Author 的名称</td>
</tr>
<tr>
<td>GIT_COMMITTER_EMAIL</td>
<td>Git 提交者的 email 地址</td>
</tr>
<tr>
<td>GIT_AUTHOR_EMAIL</td>
<td>Git Author 的 email 地址</td>
</tr>
<tr>
<td>MERCURIAL_REVISION</td>
<td>Mercurial 的版本 ID 信息</td>
</tr>
<tr>
<td>MERCURIAL_REVISION_SHORT</td>
<td>Mercurial 的版本 ID 缩写</td>
</tr>
<tr>
<td>MERCURIAL_REVISION_NUMBER</td>
<td>Mercurial 的版本号信息</td>
</tr>
<tr>
<td>MERCURIAL_REVISION_BRANCH</td>
<td>分支版本信息</td>
</tr>
<tr>
<td>MERCURIAL_REPOSITORY_URL</td>
<td>仓库 URL 信息</td>
</tr>
<tr>
<td>SVN_REVISION</td>
<td>Subversion 的当前版本信息</td>
</tr>
<tr>
<td>SVN_URL</td>
<td>当前工作空间中被 checkout 的 Subversion 工程的 URL 地址信息</td>
</tr>
</tbody></table>
<h3 id="常用的构建触发器"><a href="#常用的构建触发器" class="headerlink" title="常用的构建触发器"></a>常用的构建触发器</h3><p>Jenkins 内置 4 种构建触发器：</p>
<ul>
<li>触发远程构建</li>
<li>其他工程构建后触发（Build after other projects are build）</li>
<li>定时构建（Build periodically）</li>
<li>轮询 SCM（Poll SCM）</li>
<li>GitHub 钩子触发的 GIT SCM 轮询（GitHub hook trigger for GITScm polling）</li>
</ul>
<p><strong>触发远程构建</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310164928.png" alt="image-20220310164928630"></p>
<p>触发构建 url：<a href="http://192.168.88.86:8180/job/vx-phm/build?token=abcabc">http://192.168.88.86:8180/job/vx-phm/build?token=abcabc</a></p>
<p><strong>其他工程构建后触发</strong></p>
<p>1）创建 pre_job 流水线工程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310170455.png" alt="image-20220310170454942"></p>
<p>2）配置需要触发的工程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310170935.png" alt="image-20220310170935519"></p>
<p><strong>定时构建</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310171234.png" alt="image-20220310171234011"></p>
<p>定时字符串从左往右分别为： 分 时 日 月 周</p>
<p>一些定时表达式的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line"></span><br><span class="line">每30分钟构建一次：H代表形参 H/30 * * * * 10:02 10:32</span><br><span class="line"></span><br><span class="line">每2个小时构建一次: H H/2 * * *</span><br><span class="line"></span><br><span class="line">每天的8点，12点，22点，一天构建3次： (多个时间点中间用逗号隔开) 0 8,12,22 * * *</span><br><span class="line"></span><br><span class="line">每天中午12点定时构建一次 H 12 * * *</span><br><span class="line"></span><br><span class="line">每天下午18点定时构建一次 H 18 * * *</span><br><span class="line"></span><br><span class="line">在每个小时的前半个小时内的每10分钟 H(0-29)/10 * * * *</span><br><span class="line"></span><br><span class="line">每两小时一次，每个工作日上午9点到下午5点(也许是上午10:38，下午12:38，下午2:38，下午</span><br><span class="line">4:38) H H(9-16)/2 * * 1-5</span><br></pre></td></tr></table></figure>

<p><strong>轮询 SCM</strong></p>
<p>轮询 SCM，是指定时扫描本地代码仓库的代码是否有变更，如果代码有变更就触发项目构建。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310171348.png" alt="image-20220310171348558"><br>注意：此构建触发器，Jenkins 会定时扫描本地整个项目的代码，增大系统的开销，不建议使用。</p>
<h3 id="Git-Hook-自动触发构建"><a href="#Git-Hook-自动触发构建" class="headerlink" title="Git Hook 自动触发构建(*)"></a>Git Hook 自动触发构建(*)</h3><p>刚才我们看到在 Jenkins 的内置构建触发器中，轮询 SCM 可以实现 Gitlab 代码更新，项目自动构建，但是该方案的性能不佳。那有没有更好的方案呢？有的。就是利用 Gitlab 的 webhook 实现代码 push 到仓库，立即触发项目自动构建。</p>
<p><strong>安装 Gitlab Hook 插件</strong></p>
<p>需要安装两个插件：</p>
<p>Gitlab Hook 和 Gitlab</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310172047.png" alt="image-20220310172047813"></p>
<p><strong>Jenkins 设置自动构建</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310172445.png" alt="image-20220310172445870"></p>
<p>等会需要把生成的 webhook URL 配置到 Gitlab 中。</p>
<p><strong>Gitlab 配置 webhook</strong></p>
<p>1）开启 webhook 功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用root账户登录到后台，点击Admin Area -&gt; Settings -&gt; Network</span><br><span class="line">勾选&quot;Allow requests to the local network from web hooks and services&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310172805.png" alt="image-20220310172805087"></p>
<p>2）在项目中添加 webhook</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击项目 -&gt; Settings -&gt; Webhooks</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310173325.png" alt="image-20220310173325550"></p>
<p>注意：以下设置必须完成，否则会报错！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统管理 -&gt; 系统配置</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310173704.png" alt="image-20220310173704682"></p>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC 并发编程</title>
    <url>/2023/03/05/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="什么是-JUC"><a href="#什么是-JUC" class="headerlink" title="什么是 JUC"></a>什么是 JUC</h2><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404140130.png" alt="img"></p>
<p>JUC 是 java.util.concurrent 的简写。在 jdk 官方手册中可以看到 juc 相关的 jar 包有三个。</p>
<p>用中文概括一下，JUC 的意思就是 java 并发编程工具包</p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><blockquote>
<p>如果不能使用一句话说出来的技术，不扎实！</p>
</blockquote>
<p>进程：一个程序，QQ.exe Music.exe 程序的集合</p>
<p>一个进程往往可以包含多个线程，至少包含一个！</p>
<p>Java 默认有几个线程？ 2 个 main、GC</p>
<p>线程：线程是程序执行中一个单一的顺序控制流程</p>
<p>对于 Java 而言：Thread、Runnable、Callable</p>
<p><strong>Java 真的可以开启线程吗？</strong> 开不了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public synchronized void start() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">         * group threads created/set up by the VM. Any new functionality added</span><br><span class="line">         * to this method in the future may have to also be added to the VM.</span><br><span class="line">         *</span><br><span class="line">         * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">         */</span><br><span class="line">        if (threadStatus != 0)</span><br><span class="line">            throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        /* Notify the group that this thread is about to be started</span><br><span class="line">         * so that it can be added to the group&#x27;s list of threads</span><br><span class="line">         * and the group&#x27;s unstarted count can be decremented. */</span><br><span class="line">        group.add(this);</span><br><span class="line"></span><br><span class="line">        boolean started = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">                /* do nothing. If start0 threw a Throwable then</span><br><span class="line">                  it will be passed up the call stack */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	// 本地方法，底层的C++，Java无法直接操作硬件</span><br><span class="line">    private native void start0();</span><br></pre></td></tr></table></figure>

<h3 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h3><p>并发编程：并发、并行</p>
<p>并发（多线程操作同一个资源）</p>
<ul>
<li>CPU 一核，模拟出来多条线程，天下武功，唯快不破，快速交替</li>
</ul>
<p>并行（多个人一起行走）</p>
<ul>
<li>CPU 多核，多个线程可以同时执行；线程池</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.demo01;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 14:20</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取CPU的核心数</span><br><span class="line">        // CPU密集型，IO密集型</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发编程的本质：<strong>充分利用 CPU 的资源</strong></p>
<p>所有的公司都很看重！</p>
<h3 id="线程有几个状态"><a href="#线程有几个状态" class="headerlink" title="线程有几个状态"></a>线程有几个状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public enum State &#123;</span><br><span class="line">       	//新生</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        //运行</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        //阻塞</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        //等待</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        //超时等待</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        //终止</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="wait-x2F-sleep-的区别"><a href="#wait-x2F-sleep-的区别" class="headerlink" title="wait&#x2F;sleep 的区别"></a>wait&#x2F;sleep 的区别</h3><ol>
<li><p><strong>来自不同的类</strong></p>
<p>wait &#x3D;&gt; Object</p>
<p>sleep &#x3D;&gt; Thread</p>
</li>
<li><p><strong>关于锁的释放</strong></p>
<p>wait 会释放锁，sleep 睡觉了，抱着锁睡觉，不会释放！</p>
</li>
<li><p><strong>使用的范围是不同的</strong></p>
<p>wait：只能在同步代码块中使用</p>
<p>sleep：可以在任何地方睡</p>
</li>
</ol>
<h2 id="Lock-锁（重点）"><a href="#Lock-锁（重点）" class="headerlink" title="Lock 锁（重点）"></a>Lock 锁（重点）</h2><h3 id="传统-synchronized"><a href="#传统-synchronized" class="headerlink" title="传统 synchronized"></a>传统 synchronized</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.demo01;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 真正的多线程开发，公司中的开发，降低耦合性</span><br><span class="line"> * * 线程就是一个单独的资源类，没有任何附属的操作！</span><br><span class="line"> * * 1、 属性、方法</span><br><span class="line"> *</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 14:42</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class SaleTicketDemo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 并发：多线程操作同一个资源类, 把资源类丢入线程</span><br><span class="line">        Ticket ticket = new Ticket();</span><br><span class="line">        // @FunctionalInterface 函数式接口，jdk1.8 lambda表达式 (参数)-&gt;&#123; 代码 &#125;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 1; i &lt; 40; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 1; i &lt; 40; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 1; i &lt; 40; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 资源类 OOP</span><br><span class="line">class Ticket &#123;</span><br><span class="line">    // 属性、方法</span><br><span class="line">    private int number = 30;</span><br><span class="line"></span><br><span class="line">    // 卖票的方式</span><br><span class="line">    // synchronized 本质: 队列，锁</span><br><span class="line">    public synchronized void sale() &#123;</span><br><span class="line">        if (number &gt; 0) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;卖出了&quot; + (number--) + &quot;票,剩余：&quot; + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404145103.png" alt="image-20210404145103174"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404145122.png" alt="image-20210404145122205"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404145431.png" alt="image-20210404145431054"></p>
<p>公平锁：十分公平；可以先来后到</p>
<p><strong>非公平锁：十分不公平；可以插队（默认）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.demo01;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 14:42</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class SaleTicketDemo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 并发：多线程操作同一个资源类, 把资源类丢入线程</span><br><span class="line">        Ticket2 ticket = new Ticket2();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 1; i &lt; 40; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 1; i &lt; 40; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 1; i &lt; 40; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lock三部曲</span><br><span class="line"> * 1.new ReentrantLock();</span><br><span class="line"> * 2.Lock.lock() //加锁</span><br><span class="line"> * 3.finally =&gt; lock.unlock() //解锁</span><br><span class="line"> */</span><br><span class="line">class Ticket2 &#123;</span><br><span class="line">    // 属性、方法</span><br><span class="line">    private int number = 30;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    // 卖票的方式</span><br><span class="line">    public void sale() &#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();//加锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //业务代码</span><br><span class="line">            if (number &gt; 0) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;票,剩余：&quot; + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-和-Lock-区别"><a href="#synchronized-和-Lock-区别" class="headerlink" title="synchronized 和 Lock 区别"></a>synchronized 和 Lock 区别</h3><ol>
<li>synchronize 内置的 Java 关键字，Lock 是一个 Java 类</li>
<li>synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁</li>
<li>synchronized 会自动释放锁，Lock 必须要手动释放锁！如果不释放锁，<strong>死锁</strong></li>
<li>synchronized 线程 1（获得锁，阻塞）、线程 2（等待，傻傻的等）；Lock 锁就不一定会等待下去；</li>
<li>synchronized 可重入锁，不可以中断的，非公平；Lock 可重入锁，可以判断锁，非公平（可以自己设置）</li>
<li>synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码！</li>
</ol>
<h2 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h2><h3 id="生产者和消费者问题-synchronized-版"><a href="#生产者和消费者问题-synchronized-版" class="headerlink" title="生产者和消费者问题 synchronized 版"></a>生产者和消费者问题 synchronized 版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.pc;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.bcel.internal.generic.NEW;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线程之间的通信问题：生产者与消费者问题！ 等待唤醒，通知唤醒</span><br><span class="line"> * 线程交替执行 A B 操作同一个变量 num = 0</span><br><span class="line"> * A num+1</span><br><span class="line"> * B num-1</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 15:10</span><br><span class="line"> */</span><br><span class="line">public class A &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data = new Data();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断等待、业务、通知</span><br><span class="line">//数字 资源类</span><br><span class="line">class Data &#123;</span><br><span class="line">    private int number = 0;</span><br><span class="line"></span><br><span class="line">    //+1</span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        if (number != 0) &#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number);</span><br><span class="line">        // 通知其他线程，我+1完毕了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //-1</span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        if (number == 0) &#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        // 通知其他线程，我-1完毕了</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number);</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题存在，A B C D 4 个线程 虚假唤醒</p>
</blockquote>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404152512.png" alt="image-20210404152512622"></p>
<p><strong>if 改为 while 判断</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.pc;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.bcel.internal.generic.NEW;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线程之间的通信问题：生产者与消费者问题！ 等待唤醒，通知唤醒</span><br><span class="line"> *</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 15:10</span><br><span class="line"> */</span><br><span class="line">public class A &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data = new Data();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;D&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断等待、业务、通知</span><br><span class="line">//数字 资源类</span><br><span class="line">class Data &#123;</span><br><span class="line">    private int number = 0;</span><br><span class="line"></span><br><span class="line">    //+1</span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        while (number != 0) &#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number);</span><br><span class="line">        // 通知其他线程，我+1完毕了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //-1</span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        while (number == 0) &#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        // 通知其他线程，我-1完毕了</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number);</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JUC-版的生产者与消费者问题"><a href="#JUC-版的生产者与消费者问题" class="headerlink" title="JUC 版的生产者与消费者问题"></a>JUC 版的生产者与消费者问题</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404153425.png" alt="image-20210404153311646"></p>
<p><strong>通过 Lock 找到 Condition</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404160949.png" alt="image-20210404160949444"></p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.pc;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 16:01</span><br><span class="line"> */</span><br><span class="line">public class B &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data2 data = new Data2();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;D&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断等待、业务、通知</span><br><span class="line">//数字 资源类</span><br><span class="line">class Data2 &#123;</span><br><span class="line">    private int number = 0;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line">    //condition.await();  //等待</span><br><span class="line">    //condition.signalAll(); //唤醒全部</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //+1</span><br><span class="line">    public void increment() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //业务代码</span><br><span class="line">            while (number != 0) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number);</span><br><span class="line">            // 通知其他线程，我+1完毕了</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //-1</span><br><span class="line">    public void decrement() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number == 0) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            // 通知其他线程，我-1完毕了</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任何一个新的技术诞生，绝不是仅仅只是覆盖了原来的技术，一定存在优势和补充！</strong></p>
<h3 id="Condition-精准的通知和唤醒线程"><a href="#Condition-精准的通知和唤醒线程" class="headerlink" title="Condition 精准的通知和唤醒线程"></a>Condition 精准的通知和唤醒线程</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404161317.png" alt="image-20210404161317196"></p>
<p>代码测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.pc;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 16:14</span><br><span class="line"> * A执行完调用B，B执行完调用C，C执行完调用A</span><br><span class="line"> */</span><br><span class="line">public class C &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Data3 data3 = new Data3();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//资源类 Lock</span><br><span class="line">class Data3 &#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    Condition condition1 = lock.newCondition();</span><br><span class="line">    Condition condition2 = lock.newCondition();</span><br><span class="line">    Condition condition3 = lock.newCondition();</span><br><span class="line">    private int number = 1; // 1A 2B 3C</span><br><span class="line"></span><br><span class="line">    public void printA() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //业务，判断 -&gt; 执行 -&gt; 通知</span><br><span class="line">            while (number != 1) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;AAAAAAA&quot;);</span><br><span class="line">            //唤醒，唤醒指定的人，B</span><br><span class="line">            number = 2;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printB() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //业务，判断 -&gt; 执行 -&gt; 通知</span><br><span class="line">            while (number != 2) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;BBBBBB&quot;);</span><br><span class="line">            //唤醒，唤醒指定的人，C</span><br><span class="line">            number = 3;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printC() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //业务，判断 -&gt; 执行 -&gt; 通知</span><br><span class="line">            while (number != 3) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;CCCCCCCC&quot;);</span><br><span class="line">            //唤醒，唤醒指定的人，A</span><br><span class="line">            number = 1;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-锁现象"><a href="#8-锁现象" class="headerlink" title="8 锁现象"></a>8 锁现象</h2><p>任何判断锁的是谁！永远的知道什么是锁，锁到底锁的是谁！</p>
<p>**深刻理解我们的锁 **</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 8锁，就是关于锁的8个问题</span><br><span class="line"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1发短信 2打电话</span><br><span class="line"> * 1、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1发短信 2打电话</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 16:30</span><br><span class="line"> */</span><br><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line"></span><br><span class="line">        //锁的存在</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone &#123;</span><br><span class="line"></span><br><span class="line">    // synchronized 锁的对象是方法的调用者！</span><br><span class="line">    // 两个方法用的是同一所，谁先拿到谁执行！</span><br><span class="line">    public synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 3. 增加了一个普通方法！先执行发短信还是hello？  普通方法hello</span><br><span class="line"> * 4. 两个对象，两个同步方法，发短信还是打电话？  //打电话</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 16:36</span><br><span class="line"> */</span><br><span class="line">public class Test2  &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //两个不同的对象 两把锁</span><br><span class="line">        Phone2 phone1 = new Phone2();</span><br><span class="line">        Phone2 phone2 = new Phone2();</span><br><span class="line"></span><br><span class="line">        //锁的存在</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2 &#123;</span><br><span class="line"></span><br><span class="line">    // synchronized 锁的对象是方法的调用者！</span><br><span class="line">    // 两个方法用的是同一锁，谁先拿到谁执行！</span><br><span class="line">    public synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这里没有锁！不是同步方法！不受锁的影响</span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 5.增加两个静态同步方法，只有一个对象，先打印 发短信？打电话？ 发短信</span><br><span class="line"> * 6.增加两个静态同步方法，两个对象！，先打印 发短信？打电话？ 发短信</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 17:22</span><br><span class="line"> */</span><br><span class="line">public class Test3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //两个不同的对象 类模板Class只有一个 static，锁的是Class</span><br><span class="line">        Phone3 phone1 = new Phone3();</span><br><span class="line">        Phone3 phone2 = new Phone3();</span><br><span class="line"></span><br><span class="line">        //锁的存在</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone3 &#123;</span><br><span class="line"></span><br><span class="line">    // synchronized 锁的对象是方法的调用者！</span><br><span class="line">    // staic静态方法</span><br><span class="line">    // 类一加载就有了！锁的是Class Phone3.class</span><br><span class="line">    public static synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void call() &#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 7. 一个静态同步方法，一个普通同步方法 一个对象 先打印 发短信？打电话？ 打电话</span><br><span class="line"> * 8. 一个静态同步方法，一个普通同步方法 两个对象 先打印 发短信？打电话？ 打电话</span><br><span class="line"> *</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 17:27</span><br><span class="line"> */</span><br><span class="line">public class Test4 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //两个不同的对象 类模板Class只有一个 static，锁的是Class</span><br><span class="line">        Phone4 phone1 = new Phone4();</span><br><span class="line">        Phone4 phone2 = new Phone4();</span><br><span class="line"></span><br><span class="line">        //锁的存在</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone4 &#123;</span><br><span class="line"></span><br><span class="line">    // staic静态同步方法  锁的是Class</span><br><span class="line">    public static synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //普通同步方法 锁的是调用对象</span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<p>new this 具体的一个对象</p>
<p>static Class 唯一的模板</p>
<h2 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h2><h3 id="List-不安全"><a href="#List-不安全" class="headerlink" title="List 不安全"></a>List 不安全</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.unsafe;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * java.util.ConcurrentModificationException 并发修改异常;</span><br><span class="line"> *</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 17:34</span><br><span class="line"> */</span><br><span class="line">public class ListTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 并发下 ArrayList 不安全的</span><br><span class="line">        /**</span><br><span class="line">         * 解决方案：</span><br><span class="line">         * 1、List&lt;String&gt; list = new Vector&lt;&gt;();</span><br><span class="line">         * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">         * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">         */</span><br><span class="line">        // CopyOnWriter COW 计算机程序设计领域的一种优化策略：</span><br><span class="line">        // 多个线程调用的时候，list，读取时是固定的，写入（覆盖）</span><br><span class="line">        // 在写入的时候避免覆盖，造成数据问题  -- 读写分离</span><br><span class="line">        // CopyOnWriterList 比 Vector NB在哪里？ =&gt; 前者效率高</span><br><span class="line">        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学习方法推荐：1、先会用、2、货比 3 家，寻找其他解决方案，3、分析源码！</p>
<h3 id="Set-不安全"><a href="#Set-不安全" class="headerlink" title="Set 不安全"></a>Set 不安全</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.unsafe;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同理可证：java.util.ConcurrentModificationException 并发修改异常</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 17:49</span><br><span class="line"> */</span><br><span class="line">public class SetList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        //Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 300; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HashSet 底层是什么？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//add set 本质就是map key是无法重复的！！</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final Object PRESENT = new Object(); //常量 不变的值！</span><br></pre></td></tr></table></figure>

<h3 id="Map-不安全"><a href="#Map-不安全" class="headerlink" title="Map 不安全"></a>Map 不安全</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.unsafe;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 17:57</span><br><span class="line"> */</span><br><span class="line">public class MapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // map 是这样的用的吗？ 不是，工作中不用HashMap()</span><br><span class="line">        //  默认等价于什么 new HashMap&lt;&gt;(16,0.75f);</span><br><span class="line">        //Map&lt;String,String&gt; map =  new HashMap&lt;&gt;();</span><br><span class="line">        //Map&lt;String,String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span><br><span class="line">        // 研究ConcurrentHashMap原理</span><br><span class="line">        Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callable（简单）"><a href="#Callable（简单）" class="headerlink" title="Callable（简单）"></a>Callable（简单）</h2><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404181130.png" alt="image-20210404181130827"></p>
<ol>
<li>可以有返回值</li>
<li>可以抛出异常</li>
<li>方法不同 ，run()&#x2F;call()</li>
</ol>
<p><strong>代码测试：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.callable;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 启动Callable</span><br><span class="line"> *</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 18:13</span><br><span class="line"> */</span><br><span class="line">public class CallableTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //怎么启动callable</span><br><span class="line">        // 1.new Thread(new Runnable()).start();</span><br><span class="line">        // 2.new Thread(new FutureTask&lt;V&gt;()).start();</span><br><span class="line">        // 3.new Thread(new FutureTask&lt;V&gt;(new Callable())).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        //适配类 FutureTask</span><br><span class="line">        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(myThread);</span><br><span class="line">        new Thread(task, &quot;A&quot;).start();</span><br><span class="line">        new Thread(task, &quot;B&quot;).start(); //结果会被缓存，效率高</span><br><span class="line"></span><br><span class="line">        String s = task.get(); // 这个get方法可能会产生阻塞！ 把它放到最后，或者使用异步通信来处理</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Callable&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;call()&quot;);</span><br><span class="line">        return &quot;123&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节：</p>
<ol>
<li>有缓存</li>
<li>结果可能需要等待，会阻塞！</li>
</ol>
<h2 id="常用的辅助类"><a href="#常用的辅助类" class="headerlink" title="常用的辅助类"></a>常用的辅助类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404211341.png" alt="image-20210404211341279"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.add;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计数器</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 21:14</span><br><span class="line"> */</span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //总数是6</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(6);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;Go Out&quot;);</span><br><span class="line">                countDownLatch.countDown(); //数量-1</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await(); //等待计数器归零，再向下执行</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;关门&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>&#x3D;&#x3D;countDownLatch.countDown()&#x3D;&#x3D; &#x2F;&#x2F;数量-1</p>
<p>&#x3D;&#x3D;countDownLatch.await()&#x3D;&#x3D; &#x2F;&#x2F;等待计数器归零，然后再向下执行</p>
<p>每次有线程调用 countDownLatch()数量-1，假设计数器变为 0，countDownLatch.await()就会被唤醒，继续往下执行</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404212740.png" alt="image-20210404212739912"></p>
<p>加法计数器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.add;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 21:28</span><br><span class="line"> */</span><br><span class="line">public class CycliBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 集齐七颗龙珠，召唤神龙</span><br><span class="line">         */</span><br><span class="line">        //召唤龙珠的线程</span><br><span class="line">        CyclicBarrier barrier = new CyclicBarrier(7,()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;召唤神龙成功&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">            int temp = i;</span><br><span class="line">            // lambda能操作i吗</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;收集&quot;+temp+&quot;个龙珠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    barrier.await(); //等待</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210404213555.png" alt="image-20210404213555658"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.add;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-04 21:36</span><br><span class="line"> */</span><br><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //线程数量：停车位</span><br><span class="line">        Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                //acquire()得到</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //release()释放</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>&#x3D;&#x3D;semaphore.acquire();&#x3D;&#x3D; &#x2F;&#x2F; 获得，假设已经满了，等待，等待被释放为止！</p>
<p>&#x3D;&#x3D;semaphore.release();&#x3D;&#x3D; &#x2F;&#x2F; 释放，会将当前的信号量释放+1，然后唤醒等待的线程！</p>
<p>作用：多个共享资源互斥的使用！并发限流，控制并发的线程数</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>ReadWriteLock</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405142737.png" alt="image-20210405142730413"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.rw;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占锁（写锁） 一次只能被一个线程占有</span><br><span class="line"> * 共享锁（读锁）  多个线程可以同时占有</span><br><span class="line"> * ReadWriteLock</span><br><span class="line"> * 读-读 可以共存！</span><br><span class="line"> * 读-写 不能共存！</span><br><span class="line"> * 写-写 不能共存！</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 14:28</span><br><span class="line"> */</span><br><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyCacheLock myCache = new MyCacheLock();</span><br><span class="line"></span><br><span class="line">        //写入</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int temp = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(temp + &quot;&quot;, temp);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //读取</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int temp = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(temp + &quot;&quot;);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义缓存</span><br><span class="line"> */</span><br><span class="line">class MyCache &#123;</span><br><span class="line">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 存，写</span><br><span class="line">    public void put(String key, Object value) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;写入完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取，读</span><br><span class="line">    public void get(String key) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);</span><br><span class="line">        Object o = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;读取完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCacheLock &#123;</span><br><span class="line">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    // 读写锁，更加细粒度的控制</span><br><span class="line">    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    // 存，写入的时候，只希望同时只有一个线程写</span><br><span class="line">    public void put(String key, Object value) &#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;写入完毕&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取，读</span><br><span class="line">    public void get(String key) &#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;读取完毕&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405160056.png" alt="image-20210405160056615"></p>
<h3 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405160225.png" alt="image-20210405160225524"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405160713.png" alt="image-20210405160713694"></p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><strong>BlockingQueue</strong></h3><p>不是新的东西，属于 Collection 集合框架下</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405160927.png" alt="image-20210405160927280"></p>
<p>什么情况下我们会使用阻塞队列：多线程并发处理，线程池！</p>
<h3 id="学会使用队列"><a href="#学会使用队列" class="headerlink" title="学会使用队列"></a><strong>学会使用队列</strong></h3><p>添加、移除</p>
<p><strong>四组 API</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>有返回值，抛出异常</th>
<th>有返回值，不抛出异常</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer()</td>
<td>put()</td>
<td>offer(,,)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>foll()</td>
<td>take()</td>
<td>foll(,)</td>
</tr>
<tr>
<td>检测队首元素</td>
<td>element</td>
<td>peek</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抛出异常</span><br><span class="line"> */</span><br><span class="line">public static void test1() &#123;</span><br><span class="line">    //队列的大小</span><br><span class="line">    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3);</span><br><span class="line">    System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">    System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">    System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line">    //java.lang.IllegalStateException: Queue full 抛出异常！队列已满</span><br><span class="line">    //System.out.println(blockingQueue.add(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;==========&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    //java.util.NoSuchElementException 抛出异常！没有元素</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 有返回值，不抛出异常</span><br><span class="line"> */</span><br><span class="line">public static void test2()&#123;</span><br><span class="line">    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">    //System.out.println(blockingQueue.offer(&quot;d&quot;));  //返回false</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;========&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());  //返回null</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 阻塞等待</span><br><span class="line"> */</span><br><span class="line">public static void test3() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    blockingQueue.put(&quot;a&quot;);</span><br><span class="line">    blockingQueue.put(&quot;b&quot;);</span><br><span class="line">    blockingQueue.put(&quot;c&quot;);</span><br><span class="line">    //blockingQueue.put(&quot;d&quot;); //程序一直阻塞</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;========&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take()); //程序一直阻塞</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 超时等待</span><br><span class="line"> */</span><br><span class="line">public static void test4() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">    //System.out.println(blockingQueue.offer(&quot;d&quot;,2, TimeUnit.SECONDS));  //超时等待2秒</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=========&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll(2,TimeUnit.SECONDS)); //超时等待2秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p><strong>同步队列</strong></p>
<p>进去一个元素，必须等待取出来之后，才能再往里面放一个元素！</p>
<p>put、take</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.bq;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步队列</span><br><span class="line"> * 和其他的BlockingQueue不一样，SynchronousQueue 不存储元素</span><br><span class="line"> * put了一个元素，必须从里面先take出来，否则无法继续往里面put值</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 17:03</span><br><span class="line"> */</span><br><span class="line">public class SynchronousQueueTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;();//同步队列</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;);</span><br><span class="line">                blockingQueue.put(&quot;1&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;put 2&quot;);</span><br><span class="line">                blockingQueue.put(&quot;2&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;put 3&quot;);</span><br><span class="line">                blockingQueue.put(&quot;3&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+blockingQueue.take());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池（重点）"><a href="#线程池（重点）" class="headerlink" title="线程池（重点）"></a>线程池（重点）</h2><p>线程池：三大方法、七大参数、四种拒绝策略</p>
<h3 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h3><p>程序的运行，本质：占用系统的资源！优化资源的使用！&#x3D;&gt;池化技术</p>
<p>线程池、连接池、内存池、对象池….创建、销毁。十分浪费资源</p>
<p>池化技术：事先准备好一些资源，有人要用，就到我这里来拿，用完之后还给我。</p>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ol>
<li>降低资源的消耗</li>
<li>提高响应的速度</li>
<li>方便管理</li>
</ol>
<p>&#x3D;&#x3D;<strong>线程复用，可以控制最大并发数、管理线程</strong>&#x3D;&#x3D;</p>
<h3 id="线程池：三大方法"><a href="#线程池：三大方法" class="headerlink" title="线程池：三大方法"></a>线程池：三大方法</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405171700.png" alt="image-20210405171659980"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.pool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Executors 工具类 3大方法</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 17:19</span><br><span class="line"> */</span><br><span class="line">public class Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //单个线程</span><br><span class="line">        //ExecutorService threadPool =  Executors.newFixedThreadPool(5); //创建一个固定大小的线程池</span><br><span class="line">        ExecutorService threadPool =  Executors.newCachedThreadPool(); //可伸缩的，缓存线程池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            threadPool.shutdown();  //关闭线程池</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3><p><strong>源码分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//本质都是ThreadPoolExecutor()</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,  //核心线程池大小</span><br><span class="line">                          int maximumPoolSize, //最大核心线程池大小</span><br><span class="line">                          long keepAliveTime,  //超时了没有人调用就会释放</span><br><span class="line">                          TimeUnit unit,  //超时单位</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,  //阻塞队列</span><br><span class="line">                          ThreadFactory threadFactory,  //线程工厂，创建线程的，一般不用动</span><br><span class="line">                          RejectedExecutionHandler handler  //拒绝策略) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405181241.png" alt="image-20210405181241166"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405190839.png" alt="image-20210405181515918"></p>
<h3 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.pool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Executors 工具类 3大方法</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 17:19</span><br><span class="line"> */</span><br><span class="line">public class Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //自定义线程池！工作中 ThreadPoolExecutor</span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(2,</span><br><span class="line">                5,</span><br><span class="line">                3,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                /**</span><br><span class="line">                 * 四种拒绝策略</span><br><span class="line">                 * 1.new ThreadPoolExecutor.AbortPolicy());  // 银行满了，还有人进来，不处理这个人的，抛出异常</span><br><span class="line">                 * 2.new ThreadPoolExecutor.CallerRunsPolicy());  // 哪来的去哪里</span><br><span class="line">                 * 3.new ThreadPoolExecutor.DiscardPolicy());  // 队列满了，不会抛出异常，丢弃</span><br><span class="line">                 * 4.new ThreadPoolExecutor.DiscardOldestPolicy());  // 队列满了，丢弃最早的任务，添加新任务</span><br><span class="line">                 */</span><br><span class="line">                new ThreadPoolExecutor.DiscardOldestPolicy());  // 队列满了，丢弃最早的任务，添加新任务</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 最大承载：Deque + max</span><br><span class="line">            // 抛出 java.util.concurrent.RejectedExecutionException</span><br><span class="line">            for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            threadPool.shutdown();  //关闭线程池</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405185214.png" alt="image-20210405185214360"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * 四种拒绝策略</span><br><span class="line"> * 1.new ThreadPoolExecutor.AbortPolicy());  // 银行满了，还有人进来，不处理这个人的，抛出异常</span><br><span class="line"> * 2.new ThreadPoolExecutor.CallerRunsPolicy());  // 哪来的去哪里</span><br><span class="line"> * 3.new ThreadPoolExecutor.DiscardPolicy());  // 队列满了，不会抛出异常，丢弃</span><br><span class="line"> * 4.new ThreadPoolExecutor.DiscardOldestPolicy());  // 队列满了，丢弃最早的任务，添加新任务</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h3 id="小结和扩展"><a href="#小结和扩展" class="headerlink" title="小结和扩展"></a>小结和扩展</h3><p>最大线程池大小如何去设置！</p>
<p>了解：IO 密集型，CPU 密集型：（调优）！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.pool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 17:19</span><br><span class="line"> */</span><br><span class="line">public class Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //自定义线程池！工作中 ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 最大线程到底该如何定义？</span><br><span class="line">         * 1. CPU密集型，几核，就是几，可以保持CPU效率最高</span><br><span class="line">         * 2. IO密集型，判断你程序中十分耗IO的线程</span><br><span class="line">         * 程序  15个大型任务  io十分占用资源！ -&gt; 30个</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //获取CPU的核心数</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(2,</span><br><span class="line">                Runtime.getRuntime().availableProcessors(),</span><br><span class="line">                3,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">        try &#123;</span><br><span class="line">            // 最大承载：Deque + max</span><br><span class="line">            // 抛出 java.util.concurrent.RejectedExecutionException</span><br><span class="line">            for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            threadPool.shutdown();  //关闭线程池</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四大函数式接口（重点、必需掌握）"><a href="#四大函数式接口（重点、必需掌握）" class="headerlink" title="四大函数式接口（重点、必需掌握）"></a>四大函数式接口（重点、必需掌握）</h2><p>新时代的程序员：lambda 表达式、链式编程、函数式接口、Stream 流式计算</p>
<h3 id="函数式接口：只有一个方法的接口"><a href="#函数式接口：只有一个方法的接口" class="headerlink" title="函数式接口：只有一个方法的接口"></a>函数式接口：只有一个方法的接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//超级多的FunctionInterface</span><br><span class="line">//简化编程模型，在新版本的框架底层大量应用！</span><br><span class="line">//forEach(消费者类型的函数式接口)</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405193839.png" alt="image-20210405193839177"></p>
<p><strong>代码测试：</strong></p>
<h3 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a>Function 接口</h3><p>函数型接口</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405195016.png" alt="image-20210405195016832"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.function;</span><br><span class="line"></span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Function 函数型接口，有一个输入参数，有一个输出参数</span><br><span class="line"> * 只要是函数型接口，都可以用lambda表达式简化</span><br><span class="line"> *</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 19:45</span><br><span class="line"> */</span><br><span class="line">public class Demo01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Function&lt;String, String&gt; function = new Function&lt;String, String&gt;() &#123;</span><br><span class="line">        //    @Override</span><br><span class="line">        //    public String apply(String s) &#123;</span><br><span class="line">        //        return s;</span><br><span class="line">        //    &#125;</span><br><span class="line">        //&#125;;</span><br><span class="line"></span><br><span class="line">       	//使用lambda表达式简化</span><br><span class="line">        Function&lt;String, String&gt; function = (str) -&gt; &#123;return str;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(function.apply(&quot;asd&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Predicate-接口"><a href="#Predicate-接口" class="headerlink" title="Predicate 接口"></a>Predicate 接口</h3><p>断定型接口</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405195655.png" alt="image-20210405195655121"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.function;</span><br><span class="line"></span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 断定型接口：有一个输入参数，返回值只能是布尔值！</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 19:51</span><br><span class="line"> */</span><br><span class="line">public class Demo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //判断字符是否为空</span><br><span class="line">        //Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span><br><span class="line">        //    @Override</span><br><span class="line">        //    public boolean test(String s) &#123;</span><br><span class="line">        //        return s.isEmpty();</span><br><span class="line">        //    &#125;</span><br><span class="line">        //&#125;;</span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; predicate = str -&gt; str.isEmpty();</span><br><span class="line"></span><br><span class="line">        System.out.println(predicate.test(&quot;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a>Consumer 接口</h3><p>消费型接口</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405200414.png" alt="image-20210405200414021"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.function;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.bcel.internal.generic.NEW;</span><br><span class="line"></span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消费性接口：一个输入参数，没有返回值</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 20:00</span><br><span class="line"> */</span><br><span class="line">public class Demo03 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span><br><span class="line">        //    @Override</span><br><span class="line">        //    public void accept(String s) &#123;</span><br><span class="line">        //        System.out.println(s);</span><br><span class="line">        //    &#125;</span><br><span class="line">        //&#125;;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br><span class="line"></span><br><span class="line">        consumer.accept(&quot;asd&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a>Supplier 接口</h3><p>供给型接口</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405200437.png" alt="image-20210405200437068"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.function;</span><br><span class="line"></span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Supplier供给型接口 没有参数，只有返回值</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-05 20:03</span><br><span class="line"> */</span><br><span class="line">public class Demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        //    @Override</span><br><span class="line">        //    public Integer get() &#123;</span><br><span class="line">        //        return 1024;</span><br><span class="line">        //    &#125;</span><br><span class="line">        //&#125;;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier = () -&gt; 1024;</span><br><span class="line"></span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream-流式计算"><a href="#Stream-流式计算" class="headerlink" title="Stream 流式计算"></a>Stream 流式计算</h2><h3 id="什么是流式计算？"><a href="#什么是流式计算？" class="headerlink" title="什么是流式计算？"></a>什么是流式计算？</h3><p>大数据时代：存储+计算</p>
<p>集合是用来存储东西的</p>
<p>计算都应该交给流来操作！</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210405225822.png" alt="image-20210405225822466"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.stream;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 现有5个用户，筛选：</span><br><span class="line"> * 1. ID偶数的</span><br><span class="line"> * 2. 年纪大于23岁</span><br><span class="line"> * 3. 用户名转为大写字母</span><br><span class="line"> * 4. 用户名字母倒排序</span><br><span class="line"> * 5. 只输出一个用户</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * * @author IRVING</span><br><span class="line"> * * @create 2021-04-05 22:49</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User u1 = new User(1, &quot;a&quot;, 21);</span><br><span class="line">        User u2 = new User(2, &quot;b&quot;, 22);</span><br><span class="line">        User u3 = new User(3, &quot;c&quot;, 23);</span><br><span class="line">        User u4 = new User(4, &quot;d&quot;, 24);</span><br><span class="line">        User u5 = new User(6, &quot;e&quot;, 26);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">        users.stream()</span><br><span class="line">                .filter(u -&gt; u.getId() % 2 == 0)</span><br><span class="line">                .filter(u -&gt; u.getAge() &gt; 23)</span><br><span class="line">                .peek(user -&gt; user.setName(user.getName().toUpperCase()))</span><br><span class="line">                .sorted(Comparator.comparing(User::getName, Comparator.reverseOrder()))</span><br><span class="line">                .limit(1)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>分支合并</p>
<h3 id="什么是-ForkJoin？"><a href="#什么是-ForkJoin？" class="headerlink" title="什么是 ForkJoin？"></a>什么是 ForkJoin？</h3><p>ForkJoin 在 JDK1.7，并行执行任务！提高效率，大数据量！</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406124700.png" alt="image-20210406124653585"></p>
<blockquote>
<p>ForkJoin 特点：工作窃取</p>
</blockquote>
<p>这个里面维护的都是双端队列</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406125200.png" alt="image-20210406125200490"></p>
<h3 id="如何使用-ForkJoin"><a href="#如何使用-ForkJoin" class="headerlink" title="如何使用 ForkJoin?"></a>如何使用 ForkJoin?</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406130207.png" alt="image-20210406130207157"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406132051.png" alt="image-20210406132051647"></p>
<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>Future 设计的初衷：对将来的某个事件的结果进行建模</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406221746.png" alt="image-20210406221739820"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.future;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步调用：CompletableFuture</span><br><span class="line"> * 异步执行</span><br><span class="line"> * 成功回调</span><br><span class="line"> * 失败回调</span><br><span class="line"> *</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-06 22:18</span><br><span class="line"> */</span><br><span class="line">public class Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //发起一个请求</span><br><span class="line">        //CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        //    try &#123;</span><br><span class="line">        //        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        //    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        //        e.printStackTrace();</span><br><span class="line">        //    &#125;</span><br><span class="line">        //    System.out.println(Thread.currentThread().getName() + &quot;runAsync=&gt;Void&quot;);</span><br><span class="line">        //&#125;);</span><br><span class="line">        //</span><br><span class="line">        //System.out.println(&quot;1111&quot;);</span><br><span class="line">        //</span><br><span class="line">        //completableFuture.get(); //获取阻塞执行结果</span><br><span class="line"></span><br><span class="line">        //有返回值的</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;runAsync=&gt;Integer&quot;);</span><br><span class="line">            int i = 10/0;</span><br><span class="line">            return 1024;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        completableFuture.whenComplete((t,u)-&gt;&#123;</span><br><span class="line">            System.out.println(t); //正常的返回结果</span><br><span class="line">            System.out.println(u); //错误信息 java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">        &#125;).exceptionally((e)-&gt;&#123;</span><br><span class="line">            System.out.println(e.getMessage()); //可以获取到错误的返回结果</span><br><span class="line">            return 233;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="请你谈谈你对-Volatile-的理解"><a href="#请你谈谈你对-Volatile-的理解" class="headerlink" title="请你谈谈你对 Volatile 的理解"></a>请你谈谈你对 Volatile 的理解</h3><p>Volatile 是 Java 虚拟机提供的<strong>轻量级的同步机制</strong></p>
<ol>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ol>
<h3 id="什么是-JMM"><a href="#什么是-JMM" class="headerlink" title="什么是 JMM"></a>什么是 JMM</h3><p>JMM：java 内存模型，不存在的东西，概念！约定！</p>
<p><strong>关于 JMM 一些同步的约定：</strong></p>
<ol>
<li>线程解锁前，必须把共享变量立刻刷回主内存</li>
<li>线程加锁前，必须读取主内存中的最新值到工作内存中！</li>
<li>加锁和解锁必须是同一把锁！</li>
</ol>
<p>线程 <strong>工作内存、主内存</strong></p>
<h3 id="8-种操作"><a href="#8-种操作" class="headerlink" title="8 种操作"></a>8 种操作</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406224257.png" alt="image-20210406224257522"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406224329.png" alt="image-20210406224329039"></p>
<p><strong>内存交互操作有 8 种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许例外）</strong></p>
<ul>
<li>lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li>
<li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用</li>
<li>load （载入）：作用于工作内存的变量，它把 read 操作从主存中变量放入工作内存中</li>
<li>use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li>
<li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li>
<li>store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的 write 使用</li>
<li>write 　（写入）：作用于主内存中的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>
<p><strong>JMM 对这八种指令的使用，制定了如下规则：</strong></p>
<ul>
<li>不允许 read 和 load、store 和 write 操作之一单独出现。即使用了 read 必须 load，使用了 store 必须 write</li>
<li>不允许线程丢弃他最近的 assign 操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有 assign 的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施 use、store 操作之前，必须经过 assign 和 load 操作</li>
<li>一个变量同一时间只有一个线程能对其进行 lock。多次 lock 后，必须执行相同次数的 unlock 才能解锁</li>
<li>如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新 load 或 assign 操作初始化变量的值</li>
<li>如果一个变量没有被 lock，就不能对其进行 unlock 操作。也不能 unlock 一个被其他线程锁住的变量</li>
<li>对一个变量进行 unlock 操作之前，必须把此变量同步回主内存</li>
</ul>
<p>问题：程序不知道主内存的值被修改过了！！</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406224933.png" alt="image-20210406224933254"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.volatile1;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-06 22:50</span><br><span class="line"> */</span><br><span class="line">public class JMMDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int num = 0;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            while (num ==  0)&#123; //线程1对主内存的变化不知道</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        num = 1;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.volatile1;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-06 22:50</span><br><span class="line"> */</span><br><span class="line">public class JMMDemo &#123;</span><br><span class="line">    /*</span><br><span class="line">      不加 volatile 程序就会死循环</span><br><span class="line">      加 volatile 可以保证可见性</span><br><span class="line">     */</span><br><span class="line">    private volatile static int num = 0;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            while (num ==  0)&#123; //线程1对主内存的变化不知道</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        num = 1;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><p>原子性：不可分割</p>
<p>线程 A 在执行任务的时候，不能被打扰的，也不能被分割，要么同时成功，要么同时失败！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.volatile1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-06 22:55</span><br><span class="line"> */</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    //volatile不保证原子性</span><br><span class="line">    private volatile static int num = 0;</span><br><span class="line"></span><br><span class="line">    public static void add() &#123;</span><br><span class="line">        num++; //不是一个原子性操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //理论上num结果为2万</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int i1 = 0; i1 &lt; 1000; i1++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 2) &#123; //main gc</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;==&gt;&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果不加 lock 和 synchronized，怎样保持原子性</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406230445.png" alt="image-20210406230445570"></p>
<p>使用原子类，解决原子性问题</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406230556.png" alt="image-20210406230556520"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.volatile1;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-06 22:55</span><br><span class="line"> */</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    //volatile不保证原子性</span><br><span class="line">    //使用原子类的Integer</span><br><span class="line">    private volatile static AtomicInteger num = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public static void add() &#123;</span><br><span class="line">        //num++; //不是一个原子性操作</span><br><span class="line">        num.getAndIncrement();  // AtomicInteger +1 方法 CAS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //理论上num结果为2万</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int i1 = 0; i1 &lt; 1000; i1++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 2) &#123; //main gc</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;==&gt;&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些类的底层都直接和操作系统挂钩！！直接在内存中修改只！Usafe 类是一个很特殊的存在！</p>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>什么是指令重排：<strong>你写的程序，计算机并不是按照你写的那样去执行的</strong></p>
<p>源代码 –&gt; 编译器优化的重排 –&gt; 指令并行也可能会重排 –&gt; 内存也可能会重排 –&gt;执行</p>
<p>&#x3D;&#x3D;<strong>处理器在进行指令重排的时候，考虑：数据之间的依赖性！</strong>&#x3D;&#x3D;</p>
<p>可能造成影响的结果：a b x y 四个数都是 0</p>
<table>
<thead>
<tr>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody><tr>
<td>x&#x3D;a</td>
<td>y&#x3D;b</td>
</tr>
<tr>
<td>b&#x3D;1</td>
<td>a&#x3D;2</td>
</tr>
</tbody></table>
<p>正常的结果：x&#x3D;0 y&#x3D;0 但是可能由于指令重排</p>
<table>
<thead>
<tr>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody><tr>
<td>b&#x3D;1</td>
<td>a&#x3D;2</td>
</tr>
<tr>
<td>x&#x3D;a</td>
<td>y&#x3D;b</td>
</tr>
</tbody></table>
<p>指令重排导致的诡异结果：x&#x3D;2 y&#x3D;1</p>
<p><strong>volatile 可以避免指令重排：</strong></p>
<p>内存屏障。CPU 指令。</p>
<p>作用：</p>
<p>1、保证特定的操作的执行顺序！</p>
<p>2、可以保证某些变量的内存可见性 （利用这些特性 volatile 实现了可见性）</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406232313.png" alt="image-20210406232313816"></p>
<p><strong>Volatile 是可以保持可见性，不能保证原子性，因为内存屏障，可以保证避免指令重排的现象产生！</strong></p>
<h2 id="深入理解-CAS"><a href="#深入理解-CAS" class="headerlink" title="深入理解 CAS"></a>深入理解 CAS</h2><h3 id="什么是-CAS？"><a href="#什么是-CAS？" class="headerlink" title="什么是 CAS？"></a>什么是 CAS？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-06 23:52</span><br><span class="line"> */</span><br><span class="line">public class CASDemo &#123;</span><br><span class="line"></span><br><span class="line">    //CAS  compareAndSet：比较并交换 compareAndSwap</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(2020);</span><br><span class="line"></span><br><span class="line">        // 期望、更新</span><br><span class="line">        // public final boolean compareAndSet(int expect, int update)</span><br><span class="line">        // 如果我期望的值达到了，那么就会更新，否则就不更新 CAS 是CPU的并发原语</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406235854.png" alt="image-20210406235854081"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210406235912.png" alt="image-20210406235912021"></p>
<p>CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就 一直循环！</p>
<p>缺点：</p>
<p>1、 循环会耗时</p>
<p>2、一次性只能保证一个共享变量的原子性</p>
<p>3、ABA 问题</p>
<h3 id="ABA-问题（狸猫换太子）"><a href="#ABA-问题（狸猫换太子）" class="headerlink" title="ABA 问题（狸猫换太子）"></a>ABA 问题（狸猫换太子）</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210407000535.png" alt="image-20210407000535708"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-06 23:52</span><br><span class="line"> */</span><br><span class="line">public class CASDemo &#123;</span><br><span class="line"></span><br><span class="line">    //CAS  compareAndSet：比较并交换 compareAndSwap</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(2020);</span><br><span class="line"></span><br><span class="line">        // 对于我们写的SQL ：乐观锁！</span><br><span class="line">        // 期望、更新</span><br><span class="line">        // public final boolean compareAndSet(int expect, int update)</span><br><span class="line">        // 如果我期望的值达到了，那么就会更新，否则就不更新 CAS 是CPU的并发原语</span><br><span class="line">        // ==============捣乱的线程==============</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2021, 2020));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        // ==============期望的线程==============</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 6666));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>解决 ABA 问题，引入原子引用！对应的思想就是我们的乐观锁</p>
<p>带版本号的原子操作！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line">import java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line">import java.util.zip.DeflaterOutputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-07 0:10</span><br><span class="line"> */</span><br><span class="line">public class CASDemo02 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // AtomicStampedReference 注意：如果泛型是一个包装类，注意对象的引用问题</span><br><span class="line"></span><br><span class="line">        // 正常在业务操作，这里面比较的都是一个个对象</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; integer = new AtomicStampedReference&lt;&gt;(1, 1);</span><br><span class="line"></span><br><span class="line">        //乐观锁的原理</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            int stamp = integer.getStamp();  //获得版本号</span><br><span class="line">            System.out.println(&quot;a1=&gt;&quot;+stamp);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(integer.compareAndSet(1, 2, integer.getStamp(), integer.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;a2=&gt;&quot;+integer.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(integer.compareAndSet(2, 1, integer.getStamp(), integer.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;a3=&gt;&quot;+integer.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;a&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            int stamp = integer.getStamp();  //获得版本号</span><br><span class="line">            System.out.println(&quot;b1=&gt;&quot;+stamp);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(integer.compareAndSet(1, 6, stamp, stamp + 1));</span><br><span class="line">            System.out.println(&quot;b2=&gt;&quot;+integer.getStamp());</span><br><span class="line">        &#125;, &quot;b&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p><strong>Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实 例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间；</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210407002800.png" alt="image-20210407002800024"></p>
<h2 id="各种锁的理解"><a href="#各种锁的理解" class="headerlink" title="各种锁的理解"></a>各种锁的理解</h2><h3 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h3><p>公平锁：非常公平，不能够插队，必须先来后到！</p>
<p>非公平锁：非常不公平，可以插队（默认都是非公平）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">	sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">	sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h3><p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210407003348.png" alt="image-20210407003347941"></p>
<blockquote>
<p>synchronized 版</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.lock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-07 0:39</span><br><span class="line"> */</span><br><span class="line">public class Demo01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void sms() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);</span><br><span class="line">        call(); //这里也有锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Lock 版</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-07 0:39</span><br><span class="line"> */</span><br><span class="line">public class Demo02 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone2 phone = new Phone2();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2 &#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void sms() &#123;</span><br><span class="line">        lock.lock(); //细节问题：lock.lock()，lock.unlock(); //lock锁必须配对，否则就会死在里面</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);</span><br><span class="line">            call(); //这里也有锁</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;call&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自选锁"><a href="#自选锁" class="headerlink" title="自选锁"></a>自选锁</h3><p>spinlock</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210407004626.png" alt="image-20210407004626556"></p>
<p><strong>自定义锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自旋锁</span><br><span class="line"> *</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-07 0:52</span><br><span class="line"> */</span><br><span class="line">public class SpinlockDemo &#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //加锁</span><br><span class="line">    public void mylock() &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + &quot;==&gt;mylock&quot;);</span><br><span class="line"></span><br><span class="line">        //自旋锁</span><br><span class="line">        while (!atomicReference.compareAndSet(null, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解锁</span><br><span class="line">    public void myunlock() &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + &quot;==&gt;myunlock&quot;);</span><br><span class="line">        atomicReference.compareAndSet(thread, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.ouwen.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-04-07 0:59</span><br><span class="line"> */</span><br><span class="line">public class TestSpinLock &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //ReentrantLock lock = new ReentrantLock();</span><br><span class="line">        //lock.lock();</span><br><span class="line">        //lock.unlock();</span><br><span class="line"></span><br><span class="line">        //地层使用CAS实现自旋锁</span><br><span class="line">        SpinlockDemo lock = new SpinlockDemo();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            lock.mylock();</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.myunlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,&quot;T1&quot;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            lock.mylock();</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.myunlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,&quot;T2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是什么？</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210407010904.png" alt="image-20210407010904630"></p>
<h4 id="如何解决死锁问题？"><a href="#如何解决死锁问题？" class="headerlink" title="如何解决死锁问题？"></a>如何解决死锁问题？</h4><p>1、使用<code>jps -l</code>定位进程号</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210407011207.png" alt="image-20210407011207227"></p>
<p>2、使用<code>jstack 进程号</code> 找到死锁问题</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20210407011248.png" alt="image-20210407011248176"></p>
<p><strong>查看堆栈信息，找到死锁问题！</strong></p>
]]></content>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>常用编程环境与开发工具安装手册</title>
    <url>/2022/09/12/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<blockquote>
<p><strong>安装目录示分区大小而定，不可盲目复制命令进行安装！</strong></p>
</blockquote>
<h2 id="安装-Docker-容器服务"><a href="#安装-Docker-容器服务" class="headerlink" title="安装 Docker 容器服务"></a>安装 Docker 容器服务</h2><h3 id="CentOS-安装"><a href="#CentOS-安装" class="headerlink" title="CentOS 安装"></a>CentOS 安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 1. 卸载旧的版本</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"># 2. 安装yum-utils包（提供 yum-config-manager 程序）</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"># 3. 设置镜像的仓库</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的，十分慢！</span><br><span class="line"># 建议使用阿里云的镜像地址</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 更新yum软件包索引</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"># 4. 安装docker相关的 docker-ce docker-compose （默认为最新版）</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line"># 5. 安装指定版本</span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span><br><span class="line">sudo yum install docker-ce-20.10.13 docker-ce-cli-20.10.13 containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line"># 6. 启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"># 7. 使用docker version查看是否安装成功</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-安装"><a href="#Ubuntu-安装" class="headerlink" title="Ubuntu 安装"></a>Ubuntu 安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 1. 卸载旧的版本</span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line"># 2. 更新软件包索引并安装软件包，以允许通过 HTTPS 使用存储库：aptapt</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line"># 3. 添加 Docker 的官方 GPG 密钥：</span><br><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"># 4. 设置存储库</span><br><span class="line">echo \</span><br><span class="line">  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line">  $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"># 5. 更新包索引，并安装最新版本的 Docker 引擎、容器和 Docker Compose</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line"># 安装指定版本</span><br><span class="line">sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line"># 先列出存储库中的可用版本</span><br><span class="line">apt-cache madison docker-ce</span><br><span class="line"> docker-ce | 5:20.10.18~3-0~ubuntu-focal | https://download.docker.com/linux/ubuntu focal/stable amd64 Packages</span><br><span class="line"> docker-ce | 5:20.10.17~3-0~ubuntu-focal | https://download.docker.com/linux/ubuntu focal/stable amd64 Packages</span><br><span class="line"> docker-ce | 5:20.10.16~3-0~ubuntu-focal | https://download.docker.com/linux/ubuntu focal/stable amd64 Packages</span><br><span class="line"></span><br><span class="line"># 取出其中的版本号，例如：5:20.10.17~3-0~ubuntu-focal</span><br><span class="line">sudo apt-get install docker-ce=5:20.10.17~3-0~ubuntu-focal docker-ce-cli=5:20.10.17~3-0~ubuntu-focal containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 6. 启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"># 7. 使用docker version查看是否安装成功</span><br></pre></td></tr></table></figure>

<h2 id="Redis-缓存安装部署"><a href="#Redis-缓存安装部署" class="headerlink" title="Redis 缓存安装部署"></a>Redis 缓存安装部署</h2><p>这里下载的是<code>redis-5.0.8.tar.gz</code>安装包，并将其直接放在了<code>opt</code>⽬录下</p>
<h3 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h3><p>1、在<code>/usr/local/</code>下创建<code>redis</code>⽂件夹并进⼊</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd /usr/local/</span><br><span class="line">mkdir redis</span><br><span class="line">cd redis</span><br></pre></td></tr></table></figure>

<p>2、将<code>Redis</code>安装包解压到<code>/usr/local/redis</code>中即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">tar zxvf /opt/redis-5.0.8.tar.gz -C ./</span><br></pre></td></tr></table></figure>

<p>解压完之后， <code>/usr/local/redis</code>⽬录中会出现⼀个 <code>redis-5.0.8.tar.gz</code> 的⽬录</p>
<h3 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd redis-5.0.8/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="将-Redis-安装为系统服务并后台启动"><a href="#将-Redis-安装为系统服务并后台启动" class="headerlink" title="将 Redis 安装为系统服务并后台启动"></a>将 Redis 安装为系统服务并后台启动</h3><p>进入<code>utils</code>目录，并执行如下脚本即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd utils/</span><br><span class="line">./install_server.sh</span><br></pre></td></tr></table></figure>

<p>此处我全部选择默认配置，有需要可以按需选择</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220401194438.png" alt="image-20220401194430903"></p>
<h3 id="查看-Redis-服务启动情况"><a href="#查看-Redis-服务启动情况" class="headerlink" title="查看 Redis 服务启动情况"></a>查看 Redis 服务启动情况</h3><p>直接执行如下命令来查看 Redis 的启动结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">systemctl status redis_6379.service</span><br><span class="line"></span><br><span class="line"># 扩展</span><br><span class="line">启动：systemctl start redis_6379.service</span><br><span class="line">停止：systemctl stop redis_6379.service</span><br><span class="line">重启：systemctl restart redis_6379.service</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220401194604.png" alt="image-20220401194604551"></p>
<h3 id="启动-Redis-客户端并测试"><a href="#启动-Redis-客户端并测试" class="headerlink" title="启动 Redis 客户端并测试"></a>启动 Redis 客户端并测试</h3><p>启动自带的<code>redis-cli</code>客户端，测试通过：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220401194833.png" alt="image-20220401194833905"></p>
<p>但是此时只能在本地访问，无法远程连接，因此还需要做部分设置</p>
<h3 id="运行远程连接"><a href="#运行远程连接" class="headerlink" title="运行远程连接"></a>运行远程连接</h3><p>编辑<code>redis</code>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">vim /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>

<p>将<code>bind 127.0.0.1</code>修改为<code>0.0.0.0</code></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220401195240.png" alt="image-20220401195240594"></p>
<p>保存然后重启<code>Redis</code>服务即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">systemctl restart redis_6379.service</span><br></pre></td></tr></table></figure>

<h3 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h3><p>编辑<code>redis</code>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">vim /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>

<p>找到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1C</span><br><span class="line">#requirepass foobared</span><br></pre></td></tr></table></figure>

<p>去掉注释，将<code>foobared</code>修改为自己想要的密码，保存即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APACHE</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure>

<p>保存然后重启<code>Redis</code>服务即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">systemctl restart redis_6379.service</span><br></pre></td></tr></table></figure>

<p>这样后续的访问需要先输入密码认证通过：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220401195615.png" alt="image-20220401195615345"></p>
<h2 id="WEB-服务器-Nginx-安装部署"><a href="#WEB-服务器-Nginx-安装部署" class="headerlink" title="WEB 服务器 Nginx 安装部署"></a>WEB 服务器 Nginx 安装部署</h2><p>这⾥下载的是<code>nginx-1.17.10.tar.gz</code>安装包，并将其直接放在了<code>opt</code>⽬录下</p>
<h3 id="解压安装包-1"><a href="#解压安装包-1" class="headerlink" title="解压安装包"></a>解压安装包</h3><p>1、在<code>/usr/local/</code>下创建<code>nginx</code>⽂件夹并进⼊</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd /usr/local/</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br></pre></td></tr></table></figure>

<p>2、将<code>Nginx</code>安装包解压到<code>/usr/local/nginx</code>中即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APACHE</span><br><span class="line">tar zxvf /opt/nginx-1.17.10.tar.gz -C ./</span><br></pre></td></tr></table></figure>

<p>解压完之后， <code>/usr/local/nginx</code> ⽬录中会出现⼀个 <code>nginx-1.17.10</code> 的⽬录</p>
<h3 id="预先安装额外的依赖"><a href="#预先安装额外的依赖" class="headerlink" title="预先安装额外的依赖"></a>预先安装额外的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">yum -y install pcre-devel openssl openssl-devel gcc gcc-c++ autoconf automake make</span><br></pre></td></tr></table></figure>

<h3 id="编译安装-Nginx"><a href="#编译安装-Nginx" class="headerlink" title="编译安装 Nginx"></a>编译安装 Nginx</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd nginx-1.17.10</span><br><span class="line"># 使用 --prefix= 可以指定目录安装</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>安装完成后，Nginx 的可执⾏⽂件位置位于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<h3 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h3><p>直接执⾏如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<p>如果想停⽌ Nginx 服务，可执⾏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure>

<p>如果修改了配置⽂件后想重新加载 Nginx，可执⾏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<p>注意其配置⽂件位于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<h3 id="Centos6-9-注册为系统服务，并开机自启"><a href="#Centos6-9-注册为系统服务，并开机自启" class="headerlink" title="Centos6.9 注册为系统服务，并开机自启"></a>Centos6.9 注册为系统服务，并开机自启</h3><p>首先，在 linux 系统的&#x2F;etc&#x2F;init.d&#x2F;目录下创建 nginx 文件，使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/init.d/nginx</span><br><span class="line">SH</span><br><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line"># nginx - this script starts and stops the nginx daemon</span><br><span class="line">#</span><br><span class="line"># chkconfig:   - 85 15</span><br><span class="line"># description:  NGINX is an HTTP(S) server, HTTP(S) reverse \</span><br><span class="line">#               proxy and IMAP/POP3 proxy server</span><br><span class="line"># processname: nginx</span><br><span class="line"># config:      /etc/nginx/nginx.conf</span><br><span class="line"># config:      /etc/sysconfig/nginx</span><br><span class="line"># pidfile:     /var/run/nginx.pid</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line"># 这里根据实际安装位置修改</span><br><span class="line">nginx=&quot;/usr/local/nginx/sbin/nginx&quot;</span><br><span class="line">prog=$(basename $nginx)</span><br><span class="line"># 这里根据实际配置文件位置修改</span><br><span class="line">NGINX_CONF_FILE=&quot;/usr/local/nginx/conf&quot;</span><br><span class="line">[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx</span><br><span class="line">lockfile=/var/lock/subsys/nginx</span><br><span class="line">make_dirs() &#123;</span><br><span class="line">   # make required directories</span><br><span class="line">   user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &#x27;s/[^*]*--user=\([^ ]*\).*/\1/g&#x27; -`</span><br><span class="line">   if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then</span><br><span class="line">       useradd -M -s /bin/nologin $user</span><br><span class="line">   fi</span><br><span class="line">   options=`$nginx -V 2&gt;&amp;1 | grep &#x27;configure arguments:&#x27;`</span><br><span class="line">   for opt in $options; do</span><br><span class="line">       if [ `echo $opt | grep &#x27;.*-temp-path&#x27;` ]; then</span><br><span class="line">           value=`echo $opt | cut -d &quot;=&quot; -f 2`</span><br><span class="line">           if [ ! -d &quot;$value&quot; ]; then</span><br><span class="line">               # echo &quot;creating&quot; $value</span><br><span class="line">               mkdir -p $value &amp;&amp; chown -R $user $value</span><br><span class="line">           fi</span><br><span class="line">       fi</span><br><span class="line">   done</span><br><span class="line">&#125;</span><br><span class="line">start() &#123;</span><br><span class="line">    [ -x $nginx ] || exit 5</span><br><span class="line">    [ -f $NGINX_CONF_FILE ] || exit 6</span><br><span class="line">    make_dirs</span><br><span class="line">    echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">    daemon $nginx -c $NGINX_CONF_FILE</span><br><span class="line">    retval=$?</span><br><span class="line">    echo</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; touch $lockfile</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line">stop() &#123;</span><br><span class="line">    echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">    killproc $prog -QUIT</span><br><span class="line">    retval=$?</span><br><span class="line">    echo</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line">restart() &#123;</span><br><span class="line">    configtest || return $?</span><br><span class="line">    stop</span><br><span class="line">    sleep 1</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line">reload() &#123;</span><br><span class="line">    configtest || return $?</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    killproc $nginx -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line">force_reload() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line">configtest() &#123;</span><br><span class="line">  $nginx -t -c $NGINX_CONF_FILE</span><br><span class="line">&#125;</span><br><span class="line">rh_status() &#123;</span><br><span class="line">    status $prog</span><br><span class="line">&#125;</span><br><span class="line">rh_status_q() &#123;</span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        rh_status_q &amp;&amp; exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    restart|configtest)</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    reload)</span><br><span class="line">        rh_status_q || exit 7</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    force-reload)</span><br><span class="line">        force_reload</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        rh_status</span><br><span class="line">        ;;</span><br><span class="line">    condrestart|try-restart)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">            ;;</span><br><span class="line">    *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>保存脚本文件，并修改权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 修改文件权限</span><br><span class="line">chmod a+x /etc/init.d/nginx</span><br><span class="line"># 添加为系统服务</span><br><span class="line">chkconfig --add /etc/init.d/nginx</span><br><span class="line"># 服务启动/停止命令</span><br><span class="line">service nginx start</span><br><span class="line">service nginx stop</span><br><span class="line"># 设置终端模式开机启动</span><br><span class="line">chkconfig nginx on</span><br></pre></td></tr></table></figure>

<h3 id="CentOS7-注册为系统服务，并开机自启"><a href="#CentOS7-注册为系统服务，并开机自启" class="headerlink" title="CentOS7 注册为系统服务，并开机自启"></a>CentOS7 注册为系统服务，并开机自启</h3><p>在系统中创建服务脚本，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/nginx.service</span><br><span class="line">GRADLE</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx - web server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">ExecQuit=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>重新加载系统服务，并设置开机自启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 重新加载系统服务</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"># 启动服务</span><br><span class="line">systemctl start nginx.service</span><br><span class="line"># 开机自启</span><br><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure>

<h2 id="JDK（Java-环境）安装"><a href="#JDK（Java-环境）安装" class="headerlink" title="JDK（Java 环境）安装"></a>JDK（Java 环境）安装</h2><blockquote>
<p>注意：这⾥安装的是 Oracle JDK</p>
</blockquote>
<h3 id="准备-JDK-安装包"><a href="#准备-JDK-安装包" class="headerlink" title="准备 JDK 安装包"></a>准备 JDK 安装包</h3><p>我这里下载的是<code>jdk-8u251-linux-x64.tar.gz</code>安装包，并将其放在了<code>/opt</code>目录下</p>
<h3 id="卸载已有的-OPENJDK（如果有）"><a href="#卸载已有的-OPENJDK（如果有）" class="headerlink" title="卸载已有的 OPENJDK（如果有）"></a>卸载已有的 OPENJDK（如果有）</h3><p>如果系统⾃带有<code>OpenJDK</code>，可以按照如下步骤提前卸载之。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220308133517.png" alt="image-20220308132559705"></p>
<p>接下来可以将<code>java</code>开头的安装包均卸载即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">yum -y remove java-1.7.0-openjdk-1.7.0.141-2.6.10.5.el7.x86_64</span><br><span class="line">yum -y remove java-1.8.0-openjdk-1.8.0.131-11.b12.el7.x86_64</span><br><span class="line">... 省略 ...</span><br></pre></td></tr></table></figure>

<h3 id="创建目录并解压"><a href="#创建目录并解压" class="headerlink" title="创建目录并解压"></a>创建目录并解压</h3><p>1、在<code>/usr/local/</code>下创建<code>java</code>文件夹并进入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd /usr/local/</span><br><span class="line">mkdir java</span><br><span class="line">cd java</span><br></pre></td></tr></table></figure>

<p>2、将上⾯准备好的 JDK 安装包解压到 &#x2F;usr&#x2F;local&#x2F;java 中即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">tar -zxvf /opt/jdk-8u251-linux-x64.tar.gz -C ./</span><br></pre></td></tr></table></figure>

<p>解压完之后， &#x2F;usr&#x2F;local&#x2F;java ⽬录中会出现⼀个 jdk1.8.0_251 的⽬录</p>
<h3 id="配置-JDK-环境变量"><a href="#配置-JDK-环境变量" class="headerlink" title="配置 JDK 环境变量"></a>配置 JDK 环境变量</h3><p>编辑<code>/etc/profile</code>文件，在文件尾部加入如下<code>JDK</code>环境配置即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROUTEROS</span><br><span class="line">JAVA_HOME=/usr/local/java/jdk1.8.0_251</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>

<p>然后执⾏如下命令让环境变量⽣效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRADLE</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="验证-JDK-安装结果"><a href="#验证-JDK-安装结果" class="headerlink" title="验证 JDK 安装结果"></a>验证 JDK 安装结果</h3><p>输入如下命令即可检查安装结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APPLESCRIPT</span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line">javac</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220308153603.png" alt="image-20220308153602981"></p>
<h2 id="Maven-项目构建和管理工具安装"><a href="#Maven-项目构建和管理工具安装" class="headerlink" title="Maven 项目构建和管理工具安装"></a>Maven 项目构建和管理工具安装</h2><h3 id="准备-MAVEN-安装包并解压"><a href="#准备-MAVEN-安装包并解压" class="headerlink" title="准备 MAVEN 安装包并解压"></a>准备 MAVEN 安装包并解压</h3><p>这⾥下载的是<code>apache-maven-3.6.3-bin.tar.gz</code>安装包，并将其放置于提前创建好的<code>/usr/local/maven</code>⽬录下。</p>
<p>执⾏命令解压之：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">tar -zxvf /opt/apache-maven-3.6.3-bin.tar.gz -C ./</span><br></pre></td></tr></table></figure>

<p>即可在当前⽬录得到 &#x2F;usr&#x2F;local&#x2F;maven&#x2F;apache-maven-3.6.3 ⽬录</p>
<h3 id="配置-MAVEN-加速镜像源"><a href="#配置-MAVEN-加速镜像源" class="headerlink" title="配置 MAVEN 加速镜像源"></a>配置 MAVEN 加速镜像源</h3><p>这⾥配置的是阿⾥云的 maven 镜像源。</p>
<p>编辑修改<code>/usr/local/maven/apache-maven-3.6.3/conf/settings.xml</code>⽂件，在<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>标签对⾥添加如下内容即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220308154746.png" alt="image-20220308154746010"></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>因为下载的是⼆进制版安装包，所以解压完，配置好环境变量即可使用了。</p>
<p>编辑修改 <code>/etc/profile</code> ⽂件，在⽂件尾部添加如下内容，配置 <code>maven</code> 的安装路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROUTEROS</span><br><span class="line">export MAVEN_HOME=/usr/local/maven/apache-maven-3.6.3</span><br><span class="line">export PATH=$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>接下来执行 <code>source /etc/profile</code> 来刷新环境变量，让 <code>maven</code> 环境的路径配置生效</p>
<h3 id="检验安装结果"><a href="#检验安装结果" class="headerlink" title="检验安装结果"></a>检验安装结果</h3><p>执⾏ <code>mvn –v</code> ，能打印出 <code>maven</code> 版本信息说明安装、配置成功：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220308155428.png" alt="image-20220308155428868"></p>
<h2 id="Jenkins-安装与配置"><a href="#Jenkins-安装与配置" class="headerlink" title="Jenkins 安装与配置"></a>Jenkins 安装与配置</h2><h3 id="安装-Jenkins-Master"><a href="#安装-Jenkins-Master" class="headerlink" title="安装 Jenkins Master"></a>安装 Jenkins Master</h3><blockquote>
<p><a href="https://www.jenkins.io/zh/doc/book/installing/">Jenkins 官方安装文档</a></p>
</blockquote>
<p><strong>Docker 安装 Jenkins（推荐）</strong></p>
<ul>
<li><p>使用 Docker 安装 Jenkins</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line"></span><br><span class="line"># 使用命令直接安装（包含构建工具）</span><br><span class="line">docker run -d --name jenkins --restart always \</span><br><span class="line">--user root -p 8080:8080 -p 50000:50000 \</span><br><span class="line">-v /var/jenkins_home:/var/jenkins_home \</span><br><span class="line">-v /usr/local/maven/apache-maven-3.6.3:/usr/local/maven/apache-maven-3.6.3 \</span><br><span class="line">-v /usr/local/java/jdk1.8.0_251:/usr/local/java/jdk1.8.0_251 \</span><br><span class="line">-v /usr/local/sonar-scanner/sonar-scanner-4.6.0.2311-linux:/usr/local/sonar-scanner/sonar-scanner-4.6.0.2311-linux \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">jenkinsci/blueocean</span><br><span class="line"></span><br><span class="line"># 简易安装</span><br><span class="line">docker run -d --name jenkins --restart always \</span><br><span class="line">--user root -p 8080:8080 -p 50000:50000 \</span><br><span class="line">-v /u01/jenkins_home:/var/jenkins_home \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>War 安装 Jenkins</strong></p>
<ul>
<li>获取 Jenkins 安装包</li>
</ul>
<p>下载页面：<a href="https://jenkins.io/zh/download/">https://jenkins.io/zh/download/</a></p>
<p>安装文件：jenkins.war</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARDUINO</span><br><span class="line">1、将最新的稳定Jenkins WAR包 下载到您计算机上的相应目录。</span><br><span class="line"></span><br><span class="line">2、在下载的目录内打开一个终端/命令提示符窗口到。</span><br><span class="line"></span><br><span class="line">3、运行命令java -jar jenkins.war</span><br><span class="line"></span><br><span class="line">4、浏览http://localhost:8080并等到*Unlock Jenkins*页面出现。</span><br><span class="line"></span><br><span class="line">5、继续使用Post-installation setup wizard后面步骤设置向导。</span><br></pre></td></tr></table></figure>

<p><strong>解锁 Jenkins</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309174609.png" alt="image-20220309174609417"></p>
<p>获取并输入 admin 账户密码（我这里是 docker 安装的，目录是映射到指定位置的，密码实际存放路径以提示为主）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>

<p><strong>跳过插件安装</strong></p>
<p>因为 Jenkins 插件需要连接默认官网下载，速度非常慢，而且容易安装失败，所以我们暂时先跳过插件安装。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309174531.png" alt="image-20220309174531892"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309174831.png" alt="image-20220309174831016"></p>
<p><strong>添加一个管理员账户，并进入 Jenkins 后台</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309174954.png" alt="image-20220309174953956"></p>
<p><strong>保存并完成</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309175748.png" alt="image-20220309175748708"></p>
<p><strong>开始使用 Jenkins</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309175816.png" alt="image-20220309175816074"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309175908.png" alt="image-20220309175908276"></p>
<h3 id="安装-Jenkins-Slave"><a href="#安装-Jenkins-Slave" class="headerlink" title="安装 Jenkins Slave"></a>安装 Jenkins Slave</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统设置 &gt; 节点管理 &gt; 新建节点</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220315112501.png" alt="image-20220315112454277"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220315112942.png" alt="image-20220315112942218"></p>
<p>下载<code>agent.jar</code></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220315112649.png" alt="image-20220315112649284"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">## 创建agent目录</span><br><span class="line"></span><br><span class="line">mkdir -p /dev/jenkinsagent</span><br><span class="line">cd /dev/jenkinsagent</span><br><span class="line">wget http://192.168.88.230:8080/jnlpJars/agent.jar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 编写启动脚本</span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo 0bdf5bac23b7d4e66880934b25bda0f353509529b7f843ebb688614ba389680e &gt; secret-file</span><br><span class="line"></span><br><span class="line">nohup java -jar agent.jar -jnlpUrl http://192.168.88.230:8080/computer/build/jenkins-agent.jnlp -secret @secret-file -workDir &quot;/u01/jenkins-agent&quot; 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">## 启动agent</span><br><span class="line">sh -x start.sh</span><br><span class="line">ps aux | grep agent</span><br></pre></td></tr></table></figure>

<h3 id="Jenkins-插件管理"><a href="#Jenkins-插件管理" class="headerlink" title="Jenkins 插件管理"></a>Jenkins 插件管理</h3><p>Jenkins 本身不提供很多功能，我们可以通过使用插件来满足我们的使用。例如从 Gitlab 拉取代码，使用 Maven 构建项目等功能需要依靠插件完成。接下来演示如何下载插件。</p>
<p><strong>修改 Jenkins 插件下载地址</strong></p>
<p>Jenkins 国外官方插件地址下载速度非常慢，所以可以修改为国内插件地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins，点击Available</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309180153.png" alt="image-20220309180153473"></p>
<p>这样做是为了把 Jenkins 官方的插件列表下载到本地，接着修改地址文件，替换为国内插件地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JBOSS-CLI</span><br><span class="line"># 进入配置目录 （目录视情况而定，安装的jenkins_home下）</span><br><span class="line">cd /var/jenkins_home/updates</span><br><span class="line"></span><br><span class="line"># 执行命令</span><br><span class="line">sed -i &#x27;s/http:\/\/updates.jenkinsci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27; default.json &amp;&amp; sed -i &#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27; default.json</span><br></pre></td></tr></table></figure>

<p>最后，Manage Plugins 点击 Advanced，把 Update Site 改为国内插件下载地址</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309180807.png" alt="image-20220309180807037"></p>
<p>Sumbit 后，在浏览器输入： <a href="http://120.78.204.65:8180/restart">http://120.78.204.65:8180/restart</a> ，重启 Jenkins。</p>
<p><strong>下载中文汉化插件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins，点击Available，搜索&quot;Chinese&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181055.png" alt="image-20220309181055822"></p>
<p>完成后如下图所示：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181122.png" alt="image-20220309181122066"></p>
<p>重启 Jenkins 之后，就看到 Jenkins 汉化了！（PS：某些菜单可能会汉化失败）</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181408.png" alt="image-20220309181408200"></p>
<h3 id="Jenkins-用户权限管理"><a href="#Jenkins-用户权限管理" class="headerlink" title="Jenkins 用户权限管理"></a>Jenkins 用户权限管理</h3><p>我们可以利用<code>Role-based Authorization Strategy</code>插件来管理 Jenkins 用户权限</p>
<p><strong>安装 Role-based Authorization Strategy 插件</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181600.png" alt="image-20220309181600238"></p>
<p><strong>开启权限全局安全配置</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181914.png" alt="image-20220309181914873"></p>
<p>授权策略切换为”Role-Based Strategy”，保存</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309181940.png" alt="image-20220309181940124"></p>
<p><strong>创建角色</strong></p>
<p>在系统管理页面进入 Manage and Assign Roles</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182209.png" alt="image-20220309182209559"></p>
<p>点击”Manage Roles”</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182301.png" alt="image-20220309182301430"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182435.png" alt="image-20220309182435102"></p>
<p><code>Global roles（全局角色）</code>：管理员等高级用户可以创建基于全局的角色</p>
<p><code>Item roles（项目角色）</code>： 针对某个或者某些项目的角色</p>
<p><code>Node roles（节点角色）</code>：节点相关的权限</p>
<p>我们添加以下三个角色：</p>
<ul>
<li>baseRole：该角色为全局角色。这个角色需要绑定 Overall 下面的 Read 权限，是为了给所有用户绑定最基本的 Jenkins 访问权限。注意：如果不给后续用户绑定这个角色，会报错误：<code>用户名 is missing the Overall/Read permission</code></li>
<li>role1：该角色为项目角色。使用正则表达式绑定 <code>.vx-chx.\*</code>，意思是只能操作 vx-chx 开头的项目。</li>
<li>role2：该角色为项目角色。使用正则表达式绑定 <code>.vx-phm.\*</code>，意思是只能操作 vx-phm 开头的项目。</li>
</ul>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182812.png" alt="image-20220309182812353"></p>
<p>保存</p>
<p><strong>创建用户</strong></p>
<p>在系统管理页面进入 Manage Users</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309182917.png" alt="image-20220309182917026"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309183107.png" alt="image-20220309183107565"></p>
<p>分别创建两个用户：vxchx 和 vxphm</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309183223.png" alt="image-20220309183223041"></p>
<p><strong>给用户分配角色</strong></p>
<p>系统管理页面进入 Manage and Assign Roles，点击 Assign Roles</p>
<p>绑定规则如下：</p>
<ul>
<li><p>vxchx 用户分别绑定 baseRole 和 role1 角色</p>
</li>
<li><p>vxphm 用户分别绑定 baseRole 和 role2 角色</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309183455.png" alt="image-20220309183455591"></p>
</li>
</ul>
<p>保存</p>
<p><strong>创建项目测试权限</strong></p>
<p>以 admin 管理员账户创建两个项目，分别为 vx-chx-test 和 vx-phm-test</p>
<p>结果为： vxchx 用户登录，只能看到 vx-chx-test 项目 vxphm 用户登录，只能看到 vx-phm-test 项目</p>
<h3 id="Jenkins-凭证管理"><a href="#Jenkins-凭证管理" class="headerlink" title="Jenkins 凭证管理"></a>Jenkins 凭证管理</h3><p>凭据可以用来存储需要密文保护的数据库密码、Gitlab 密码信息、Docker 私有仓库密码等，以便 Jenkins 可以和这些第三方的应用进行交互。</p>
<p><strong>安装 Credentials Binding 插件</strong></p>
<p>要在 Jenkins 使用凭证管理功能，需要安装<code>Credentials Binding</code>插件</p>
<blockquote>
<p>注：新版本已经默认安装了此插件，这里无需另外再安装了</p>
</blockquote>
<p>系统管理中选择 <code>Manage Credentials</code></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309184117.png" alt="image-20220309184117479"></p>
<p>可以添加的凭证有 5 种：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220309184218.png" alt="image-20220309184218399"></p>
<ul>
<li>Username with password：用户名和密码</li>
<li>SSH Username with private key： 使用 SSH 用户和密钥</li>
<li>Secret file：需要保密的文本文件，使用时 Jenkins 会将文件复制到一个临时目录中，再将文件路径 设置到一个变量中，等构建结束后，所复制的 Secret file 就会被删除。</li>
<li>GitHub App：GitHub 的 API 令牌</li>
<li>Secret text：需要保存的一个加密的文本串，如钉钉机器人或 Github 的 api token</li>
<li>Certificate：通过上传证书文件的方式</li>
</ul>
<p>常用的凭证类型有：<strong>Username with password（用户密码）</strong>和 <strong>SSH Username with private key（SSH 密钥）</strong></p>
<p>接下来以使用 Git 工具到 Gitlab 拉取项目源码为例，演示 Jenkins 的如何管理 Gitlab 的凭证。</p>
<p><strong>安装 Git 插件和 Git 工具</strong></p>
<p>为了让 Jenkins 支持从 Gitlab 拉取源码，需要安装 Git 插件以及在服务器上安装 Git 工具。</p>
<p>Git 插件安装：</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310094719.png" alt="image-20220310094712046"></p>
<p>服务器上安装 Git 工具（以 CentOS7 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 安装</span><br><span class="line">yum install git -y</span><br><span class="line"># 安装后查看版本</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p><strong>用户密码类型</strong></p>
<p>1）创建凭据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; 凭证 -&gt; 系统 -&gt; 全局凭据 -&gt; 添加凭据</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310095750.png" alt="image-20220310095750604"></p>
<p>选择”Username with password”，输入 Gitlab 的用户名和密码，点击”确定”。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310100359.png" alt="image-20220310100359012"></p>
<p><strong>SSH 密钥类型</strong></p>
<p>SSH 免密登录示意图</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310100539.png" alt="image-20220310100539140"></p>
<p>1）使用 root 用户生成公钥和私钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>在&#x2F;root&#x2F;.ssh&#x2F;目录保存了公钥和使用</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310101013.png" alt="image-20220310101013313"></p>
<p>id_rsa：私钥文件</p>
<p>id_rsa.pub：公钥文件</p>
<p>2）把生成的公钥放在 Gitlab 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">登录gitlab -&gt; 点击头像 -&gt; Settings -&gt; SSH Keys</span><br></pre></td></tr></table></figure>

<p>复制刚才 id_rsa.pub 文件的内容到这里，点击”Add Key”</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310101538.png" alt="image-20220310101538008"></p>
<p>3）在 Jenkins 中添加凭证，配置私钥</p>
<p>在 Jenkins 添加一个新的凭证，类型为”SSH Username with private key”，把刚才生成私有文件内容复制过来</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310102203.png" alt="image-20220310102203814"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310102427.png" alt="image-20220310102427213"></p>
<h3 id="Jenkins-关联-JDK-和-Maven"><a href="#Jenkins-关联-JDK-和-Maven" class="headerlink" title="Jenkins 关联 JDK 和 Maven"></a>Jenkins 关联 JDK 和 Maven</h3><p><strong>关联 JDK</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; 系统管理 -&gt; 全局工具配置 -&gt; JDK -&gt; 新增JDK，配置如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310102744.png" alt="image-20220310102744563"></p>
<p><strong>关联 Maven</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; 系统管理 -&gt; 全局工具配置 -&gt; Maven -&gt; 新增Maven，配置如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310102836.png" alt="image-20220310102835922"></p>
<h3 id="Jenkins-关闭跨站请求伪造保护"><a href="#Jenkins-关闭跨站请求伪造保护" class="headerlink" title="Jenkins 关闭跨站请求伪造保护"></a>Jenkins 关闭跨站请求伪造保护</h3><ul>
<li>Docker 容器运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APPLESCRIPT</span><br><span class="line"># 1、进入运行的容器</span><br><span class="line">docker exec -u root -it 你的Jenkins容器名称或者容器id bash</span><br><span class="line"></span><br><span class="line"># 2、输入命令，编辑jenkins启动配置文件</span><br><span class="line">vi /usr/local/bin/jenkins.sh</span><br><span class="line"></span><br><span class="line"># 3、在图中标记处，加入以下配置</span><br><span class="line">-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true</span><br><span class="line"></span><br><span class="line"># 4、重启容器</span><br><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220312001027.png" alt="image-20220312001020531"></p>
<h3 id="添加-Jenkins-全局变量"><a href="#添加-Jenkins-全局变量" class="headerlink" title="添加 Jenkins 全局变量"></a><strong>添加 Jenkins 全局变量</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jenkins -&gt; 系统管理 -&gt; 全局属性 -&gt; 添加三个环境变量，配置如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310103242.png" alt="image-20220310103241974"></p>
<h3 id="Jenkins-数据迁移和备份"><a href="#Jenkins-数据迁移和备份" class="headerlink" title="Jenkins 数据迁移和备份"></a>Jenkins 数据迁移和备份</h3><p>将安装 Jenkins 的机器上的 <code>jenkins_home</code> 目录下的 config.xml 文件，jobs 文件夹，users 文件夹和 plugins 文件夹打包</p>
<ul>
<li>config.xml 是存放配置信息的</li>
<li>jobs 是存放创建的工程项目的</li>
<li>users 是存放用户账信息的</li>
<li>plugins 是存放插件的</li>
</ul>
<h3 id="Jenkins-删除构建历史"><a href="#Jenkins-删除构建历史" class="headerlink" title="Jenkins 删除构建历史"></a>Jenkins 删除构建历史</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROOVY</span><br><span class="line">//项目名称</span><br><span class="line">def jobName = &quot;xxx&quot;</span><br><span class="line">//删除小于等于maxNumber的构建历史</span><br><span class="line">def maxNumber = xxx</span><br><span class="line"></span><br><span class="line">Jenkins.instance.getItemByFullName(jobName).builds.findAll &#123;</span><br><span class="line">  it.number &lt;= maxNumber</span><br><span class="line">&#125;.each &#123;</span><br><span class="line">  it.delete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Jenkins-构建-Maven-项目"><a href="#Jenkins-构建-Maven-项目" class="headerlink" title="Jenkins 构建 Maven 项目"></a>Jenkins 构建 Maven 项目</h2><blockquote>
<p>构建方式均采用 Jar 包方式，War 方式参考<a href="http://doc.jeecg.com/2043887">WAR 部署方案 · JeecgBoot 开发文档</a></p>
</blockquote>
<h3 id="Jenkins-项目构建类型"><a href="#Jenkins-项目构建类型" class="headerlink" title="Jenkins 项目构建类型"></a>Jenkins 项目构建类型</h3><p>Jenkins 中自动构建项目的类型有很多，常用的有以下三种：</p>
<ul>
<li>自由风格软件项目（FreeStyle Project）</li>
<li>Maven 项目（Maven Project）</li>
<li>流水线项目（Pipeline Project）</li>
</ul>
<p>每种类型的构建其实都可以完成一样的构建过程与结果，只是在操作方式、灵活度等方面有所区别，在实际开发中可以根据自己的需求和习惯来选择。（PS：个人推荐使用流水线类型，因为灵活度非常高）</p>
<h3 id="自由风格项目构建"><a href="#自由风格项目构建" class="headerlink" title="自由风格项目构建"></a>自由风格项目构建</h3><p>下面演示创建一个自由风格项目来完成项目的集成过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拉取代码 -&gt; 编译 -&gt; 打包 -&gt; 部署</span><br></pre></td></tr></table></figure>

<p><strong>拉取代码</strong></p>
<p>1）创建项目</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310112707.png" alt="image-20220310112707895"></p>
<p>2）源码管理，从 Gitlab 拉取代码</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310112815.png" alt="image-20220310112815147"></p>
<p><strong>编译打包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构建 -&gt; 添加构建步骤 -&gt; 执行shell</span><br><span class="line">BASH</span><br><span class="line">echo &quot;开始编译和打包&quot;</span><br><span class="line">mvn clean package</span><br><span class="line">echo &quot;编译和打包结束&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310112952.png" alt="image-20220310112952936"></p>
<p><strong>部署</strong></p>
<p>把项目部署到远程的服务器上，并启动</p>
<p>1）安装<code>Publish Over SSH</code>插件</p>
<p>Jenkins 本身无法实现远程部署到服务器上的功能，需要安装<code>Publish Over SSH</code>插件实现</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310113332.png" alt="image-20220310113332137"></p>
<p>2）配置<code>Publish over SSH</code>，添加 SSH 服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开系统管理 -&gt; 系统配置 -&gt; 拉到底部，选择Publish over SSH区域选择新增</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310114012.png" alt="image-20220310114012322"></p>
<p><code>点击高级 -&gt; 填写服务器密码</code>（也可选择 ssh 验证，在 Jenkins 中配置本机私钥，将公钥发送到目标机器，即可完成无密码登录）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送命令：ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.xxx.xxx</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310114702.png" alt="image-20220310114702171"></p>
<ul>
<li>Passphrase： 密码（目标机器的密码）</li>
<li>Path to key：key 文件（私钥）的路径</li>
<li>SSH Server Name： 标识的名字（随便你取什么）</li>
<li>Hostname： 需要连接 ssh 的主机名或 ip 地址，此处填写应用服务器 IP（建议 ip）</li>
<li>Username： 用户名</li>
<li>Remote Directory： 远程目录(要发布的目录,比如&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;)</li>
</ul>
<p>3）添加构建步骤</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310115055.png" alt="image-20220310115055853"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310115245.png" alt="image-20220310115245384"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APACHE</span><br><span class="line"># 脚本参考</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">cd /apps</span><br><span class="line">ps -ef|grep jeecg-boot-module-system-3.1.0.jar|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -s 9</span><br><span class="line">BUILD_ID=dontKillMe</span><br><span class="line">nohup java -jar jeecg-boot-module-system-3.1.0.jar &gt; jeecg-boot-module-system-3.1.0.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>4）点击”立即构建”，开始构建过程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310115628.png" alt="image-20220310115628609"></p>
<p>5）构建成功，并自动化部署，访问测试！</p>
<h3 id="Maven-项目构建"><a href="#Maven-项目构建" class="headerlink" title="Maven 项目构建"></a>Maven 项目构建</h3><p>1）安装 Maven Integration Plugin（高版本的 Jenkins 已预装了此插件）</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310135008.png" alt="image-20220310135008339"></p>
<p>2）创建 Maven 项目</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310135103.png" alt="image-20220310135103444"></p>
<p>3）配置项目</p>
<p>拉取代码和远程部署的过程和自由风格项目一样，只是”构建”部分不同</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310135300.png" alt="image-20220310135300799"></p>
<h3 id="Pipeline-流水线项目构建"><a href="#Pipeline-流水线项目构建" class="headerlink" title="Pipeline 流水线项目构建(*)"></a>Pipeline 流水线项目构建(*)</h3><h4 id="Pipeline-简介"><a href="#Pipeline-简介" class="headerlink" title="Pipeline 简介"></a>Pipeline 简介</h4><p><strong>1）概念</strong></p>
<p>Pipeline，简单来说，就是一套运行在 Jenkins 上的工作流框架，将原来独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排和可视化的工作。</p>
<p><strong>2）使用 Pipeline 有以下好处（来自翻译自官方文档）：</strong></p>
<p>代码：Pipeline 以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流 程。持久：无论是计划内的还是计划外的服务器重启。Pipeline 都是可恢复的。可停止：Pipeline 可接 收交互式输入，以确定是否继续执行 Pipeline。多功能：Pipeline 支持现实世界中复杂的持续交付要求。它支持 fork&#x2F;join、循环执行，并行执行任务的功能。可扩展：Pipeline 插件支持其 DSL 的自定义扩展，以及与其他插件集成的多个选项。</p>
<p><strong>3）如何创建 Jenkins Pipeline 呢？</strong></p>
<ul>
<li>Pipeline 脚本是由<strong>Groovy</strong>语言实现的，但是我们没必要单独去学习 Groovy</li>
<li>Pipeline 支持两种语法：<strong>Declarative</strong>(声明式)和<strong>Scripted Pipeline</strong>(脚本式)语法</li>
<li>Pipeline 也有两种创建方法：可以直接在 Jenkins 的 Web UI 界面中输入脚本；也可以通过创建一个 Jenkinsfile 脚本文件放入项目源码库中（一般我们都推荐在 Jenkins 中直接从源代码控制(SCM)中直接载入 Jenkinsfile Pipeline 这种方法）。</li>
</ul>
<h4 id="Pipeline-语法快速入门"><a href="#Pipeline-语法快速入门" class="headerlink" title="Pipeline 语法快速入门"></a>Pipeline 语法快速入门</h4><p><strong>1）Declarative 声明式-Pipeline</strong></p>
<p>创建一个流水线项目</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310154144.png" alt="image-20220310154144897"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">流水线 -&gt; 选择HelloWorld模板</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310154618.png" alt="image-20220310154618000"></p>
<p>生成的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROOVY</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Hello&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Hello World&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>stages：</strong>代表整个流水线的所有执行阶段。通常 stages 只有 1 个，里面包含多个 stage</li>
<li><strong>stage：</strong>代表流水线中的某个阶段，可能出现 n 个。一般分为拉取代码，编译构建，部署等阶段。</li>
<li><strong>steps：</strong>代表一个阶段内需要执行的逻辑。steps 里面是 shell 脚本，git 拉取代码，ssh 远程发布等任意内容。</li>
</ul>
<p>编写一个简单声明式的 Pipeline：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROOVY</span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;拉取代码&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">            	echo &#x27;拉取代码&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;编译构建&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">            	echo &#x27;编译构建&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;项目部署&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">            	echo &#x27;项目部署&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击构建，进入<code>Blue Ocean</code>可以看到整个构建过程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310155756.png" alt="image-20220310155756052"></p>
<p><strong>2）Scripted Pipeline 脚本式-Pipeline</strong></p>
<p>创建项目</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310155938.png" alt="image-20220310155938728"></p>
<p>选择 <code>Scripted Pipeline&quot;</code></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310160044.png" alt="image-20220310160044398"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROOVY</span><br><span class="line">node &#123;</span><br><span class="line">    def mvnHome</span><br><span class="line">    stage(&#x27;Preparation&#x27;) &#123; // for display purposes</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    stage(&#x27;Build&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    stage(&#x27;Results&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Node：节点，一个 Node 就是一个 Jenkins 节点，Master 或者 Agent，是执行 Step 的具体运行环境，后续讲到 Jenkins 的 Master-Slave 架构的时候用到。</li>
<li>Stage：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作，比如： Build、Test、Deploy，Stage 是一个逻辑分组的概念。</li>
<li>Step：步骤，Step 是最基本的操作单元，可以是打印一句话，也可以是构建一个 Docker 镜像， 由各类 Jenkins 插件提供，比如命令：sh ‘make’，就相当于我们平时 shell 终端中执行 make 命令 一样。</li>
</ul>
<p>编写一个简单的脚本式 Pipeline</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVASCRIPT</span><br><span class="line">node &#123;</span><br><span class="line">    def mvnHome</span><br><span class="line">    stage(&#x27;拉取代码&#x27;) &#123; // for display purposes</span><br><span class="line">    	echo &#x27;拉取代码&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(&#x27;编译构建&#x27;) &#123;</span><br><span class="line">    	echo &#x27;编译构建&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(&#x27;项目部署&#x27;) &#123;</span><br><span class="line">    	echo &#x27;项目部署&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建结果和声明式一样！</p>
<p><strong>Pipeline Script from SCM</strong></p>
<p>刚才我们都是直接在 Jenkins 的 UI 界面编写 Pipeline 代码，这样不方便脚本维护，建议把 Pipeline 脚本放在项目中（一起进行版本控制）</p>
<p><strong>1）在项目根目录建立 Jenkinsfile 文件，把内容复制到该文件中</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310163924.png" alt="image-20220310163924603"></p>
<p>把 Jenkinsfile 上传到 Gitlab</p>
<p><strong>2）在项目中引用该文件</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310164207.png" alt="image-20220310164207097"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310164225.png" alt="image-20220310164225747"></p>
<h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><h4 id="Jenkinsfile-环境变量"><a href="#Jenkinsfile-环境变量" class="headerlink" title="Jenkinsfile 环境变量"></a>Jenkinsfile 环境变量</h4><table>
<thead>
<tr>
<th>环境变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BRANCH_NAME</td>
<td>在 multibranch 项目中，BRANCH_NAME 用于标明构建分支的名称。</td>
</tr>
<tr>
<td>CHANGE_ID</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明变更 ID，比如 Pull Request</td>
</tr>
<tr>
<td>CHANGE_URL</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明变更的 URL</td>
</tr>
<tr>
<td>CHANGE_TITLE</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明变更的标题</td>
</tr>
<tr>
<td>CHANGE_AUTHOR</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明提交变更的人员的名称</td>
</tr>
<tr>
<td>CHANGE_AUTHOR_DISPLAY_NAME</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明提交变更的人员的显示名称</td>
</tr>
<tr>
<td>CHANGE_AUTHOR_EMAIL</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于标明提交变更的人员的邮件地址</td>
</tr>
<tr>
<td>CHANGE_TARGET</td>
<td>在 multibranch 的项目中，相较于特定的变更请求，用于合并后的分支信息等</td>
</tr>
<tr>
<td>BUILD_NUMBER</td>
<td>当前的构建编号</td>
</tr>
<tr>
<td>BUILD_ID</td>
<td>在 1.597 版本后引进，表示当前构建 ID</td>
</tr>
<tr>
<td>BUILD_DISPLAY_NAME</td>
<td>当前构建的显示信息</td>
</tr>
<tr>
<td>JOB_NAME</td>
<td>构建 Job 的全称，包含项目信息</td>
</tr>
<tr>
<td>JOB_BASE_NAME</td>
<td>除去项目信息的 Job 名称</td>
</tr>
<tr>
<td>BUILD_TAG</td>
<td>构建标签</td>
</tr>
<tr>
<td>EXECUTOR_NUMBER</td>
<td>执行器编号，用于标识构建器的不同编号</td>
</tr>
<tr>
<td>NODE_NAME</td>
<td>构建节点的名称</td>
</tr>
<tr>
<td>NODE_LABELS</td>
<td>节点标签</td>
</tr>
<tr>
<td>WORKSPACE</td>
<td>构建时使用的工作空间的绝对路径</td>
</tr>
<tr>
<td>JENKINS_HOME</td>
<td>JENKINS 根目录的绝对路径</td>
</tr>
<tr>
<td>JENKINS_URL</td>
<td>Jenkins 的 URL 信息</td>
</tr>
<tr>
<td>BUILD_URL</td>
<td>构建的 URL 信息</td>
</tr>
<tr>
<td>JOB_URL</td>
<td>构建 Job 的 URL 信息</td>
</tr>
<tr>
<td>GIT_COMMIT</td>
<td>git 提交的 hash 码</td>
</tr>
<tr>
<td>GIT_PREVIOUS_COMMIT</td>
<td>当前分支上次提交的 hash 码</td>
</tr>
<tr>
<td>GIT_PREVIOUS_SUCCESSFUL_COMMIT</td>
<td>当前分支上次成功构建时提交的 hash 码</td>
</tr>
<tr>
<td>GIT_BRANCH</td>
<td>远程分支名称</td>
</tr>
<tr>
<td>GIT_LOCAL_BRANCH</td>
<td>本地分支名称</td>
</tr>
<tr>
<td>GIT_URL</td>
<td>远程 URL 地址</td>
</tr>
<tr>
<td>GIT_COMMITTER_NAME</td>
<td>Git 提交者的名称</td>
</tr>
<tr>
<td>GIT_AUTHOR_NAME</td>
<td>Git Author 的名称</td>
</tr>
<tr>
<td>GIT_COMMITTER_EMAIL</td>
<td>Git 提交者的 email 地址</td>
</tr>
<tr>
<td>GIT_AUTHOR_EMAIL</td>
<td>Git Author 的 email 地址</td>
</tr>
<tr>
<td>MERCURIAL_REVISION</td>
<td>Mercurial 的版本 ID 信息</td>
</tr>
<tr>
<td>MERCURIAL_REVISION_SHORT</td>
<td>Mercurial 的版本 ID 缩写</td>
</tr>
<tr>
<td>MERCURIAL_REVISION_NUMBER</td>
<td>Mercurial 的版本号信息</td>
</tr>
<tr>
<td>MERCURIAL_REVISION_BRANCH</td>
<td>分支版本信息</td>
</tr>
<tr>
<td>MERCURIAL_REPOSITORY_URL</td>
<td>仓库 URL 信息</td>
</tr>
<tr>
<td>SVN_REVISION</td>
<td>Subversion 的当前版本信息</td>
</tr>
<tr>
<td>SVN_URL</td>
<td>当前工作空间中被 checkout 的 Subversion 工程的 URL 地址信息</td>
</tr>
</tbody></table>
<h3 id="常用的构建触发器"><a href="#常用的构建触发器" class="headerlink" title="常用的构建触发器"></a>常用的构建触发器</h3><p>Jenkins 内置 4 种构建触发器：</p>
<ul>
<li>触发远程构建</li>
<li>其他工程构建后触发（Build after other projects are build）</li>
<li>定时构建（Build periodically）</li>
<li>轮询 SCM（Poll SCM）</li>
<li>GitHub 钩子触发的 GIT SCM 轮询（GitHub hook trigger for GITScm polling）</li>
</ul>
<p><strong>触发远程构建</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310164928.png" alt="image-20220310164928630"></p>
<p>触发构建 url：<a href="http://192.168.88.86:8180/job/vx-phm/build?token=abcabc">http://192.168.88.86:8180/job/vx-phm/build?token=abcabc</a></p>
<p><strong>其他工程构建后触发</strong></p>
<p>1）创建 pre_job 流水线工程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310170455.png" alt="image-20220310170454942"></p>
<p>2）配置需要触发的工程</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310170935.png" alt="image-20220310170935519"></p>
<p><strong>定时构建</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310171234.png" alt="image-20220310171234011"></p>
<p>定时字符串从左往右分别为： 分 时 日 月 周</p>
<p>一些定时表达式的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line"></span><br><span class="line">每30分钟构建一次：H代表形参 H/30 * * * * 10:02 10:32</span><br><span class="line"></span><br><span class="line">每2个小时构建一次: H H/2 * * *</span><br><span class="line"></span><br><span class="line">每天的8点，12点，22点，一天构建3次： (多个时间点中间用逗号隔开) 0 8,12,22 * * *</span><br><span class="line"></span><br><span class="line">每天中午12点定时构建一次 H 12 * * *</span><br><span class="line"></span><br><span class="line">每天下午18点定时构建一次 H 18 * * *</span><br><span class="line"></span><br><span class="line">在每个小时的前半个小时内的每10分钟 H(0-29)/10 * * * *</span><br><span class="line"></span><br><span class="line">每两小时一次，每个工作日上午9点到下午5点(也许是上午10:38，下午12:38，下午2:38，下午</span><br><span class="line">4:38) H H(9-16)/2 * * 1-5</span><br></pre></td></tr></table></figure>

<p><strong>轮询 SCM</strong></p>
<p>轮询 SCM，是指定时扫描本地代码仓库的代码是否有变更，如果代码有变更就触发项目构建。</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310171348.png" alt="image-20220310171348558"></p>
<p>注意：此构建触发器，Jenkins 会定时扫描本地整个项目的代码，增大系统的开销，不建议使用。</p>
<h3 id="Git-Hook-自动触发构建"><a href="#Git-Hook-自动触发构建" class="headerlink" title="Git Hook 自动触发构建(*)"></a>Git Hook 自动触发构建(*)</h3><p>刚才我们看到在 Jenkins 的内置构建触发器中，轮询 SCM 可以实现 Gitlab 代码更新，项目自动构建，但是该方案的性能不佳。那有没有更好的方案呢？有的。就是利用 Gitlab 的 webhook 实现代码 push 到仓库，立即触发项目自动构建。</p>
<p><strong>安装 Gitlab Hook 插件</strong></p>
<p>需要安装两个插件：</p>
<p>Gitlab Hook 和 Gitlab</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310172047.png" alt="image-20220310172047813"></p>
<p><strong>Jenkins 设置自动构建</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310172445.png" alt="image-20220310172445870"></p>
<p>等会需要把生成的 webhook URL 配置到 Gitlab 中。</p>
<p><strong>Gitlab 配置 webhook</strong></p>
<p>1）开启 webhook 功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用root账户登录到后台，点击Admin Area -&gt; Settings -&gt; Network</span><br><span class="line">勾选&quot;Allow requests to the local network from web hooks and services&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310172805.png" alt="image-20220310172805087"></p>
<p>2）在项目中添加 webhook</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击项目 -&gt; Settings -&gt; Webhooks</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310173325.png" alt="image-20220310173325550"></p>
<p>注意：以下设置必须完成，否则会报错！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统管理 -&gt; 系统配置</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220310173704.png" alt="image-20220310173704682"></p>
<h2 id="SonarQube-平台安装与配置"><a href="#SonarQube-平台安装与配置" class="headerlink" title="SonarQube 平台安装与配置"></a>SonarQube 平台安装与配置</h2><h3 id="认识-SonarQube"><a href="#认识-SonarQube" class="headerlink" title="认识 SonarQube"></a>认识 SonarQube</h3><p>SonarQube 是一款用于代码质量管理的开源工具，是静态代码检查工具，采用 B&#x2F;S 架构它主要用于管理源代码的质量，可以支持众多计算机语言，比如 php，java, C#, go，C&#x2F;C++, Cobol, JavaScrip, Groovy 等。sonar 可以通过 PMD，CheckStyle，Findbugs 等等代码规则检测工具来检测你的代码，帮助你发现代码的漏洞，Bug，异味等信息。</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul>
<li>一台 SonarQube Server 启动 3 个主要过程：<ul>
<li>Web 服务器，供开发人员，管理人员浏览高质量的快照并配置 SonarQube 实例</li>
<li>基于 Elasticsearch 的 Search Server 从 UI 进行后退搜索</li>
<li>Compute Engine 服务器，负责处理代码分析报告并将其保存在 SonarQube 数据库中</li>
</ul>
</li>
<li>一个 SonarQube 数据库要存储：<ul>
<li>SonarQube 实例的配置（安全性，插件设置等）</li>
<li>项目，视图等的质量快照。</li>
</ul>
</li>
<li>服务器上安装了多个 SonarQube 插件，可能包括语言，SCM，集成，身份验证和管理插件</li>
<li>在构建&#x2F;持续集成服务器上运行一个或多个 SonarScanner，以分析项目</li>
</ul>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314135315.png" alt="image-20220314135314928"></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>开发人员在 IDE 开发代码，可以安装 SonarLint 插件进行提交前代码扫描 当开发人员提交代码到版本控制系统中，自动触发 jenkins 进行代码扫描</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314135418.png" alt="image-20220314135418834"></p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>开源社区版、开发版、企业版、数据中心版</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314135630.png" alt="image-20220314135630641"></p>
<h3 id="Docker-安装-SonarQube"><a href="#Docker-安装-SonarQube" class="headerlink" title="Docker 安装 SonarQube"></a>Docker 安装 SonarQube</h3><p>这里采用 docker 容器进行安装，简单快捷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">## 创建数据目录</span><br><span class="line">mkdir -p /u01/sonarqube/&#123;data,extensions,logs&#125;</span><br><span class="line">chmod 777 -R /u01/cicd/sonarqube/</span><br><span class="line"></span><br><span class="line">## 调整</span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line">## 运行</span><br><span class="line">docker run -d -p 9000:9000 -p 9092:9092 --name sonarqube \</span><br><span class="line">	-v /u01/sonarqube/data:/opt/sonarqube/data \</span><br><span class="line">	-v /u01/sonarqube/extensions:/opt/sonarqube/extensions \</span><br><span class="line">	-v /u01/sonarqube/logs:/opt/sonarqube/logs \</span><br><span class="line">	-e SONAR_JDBC_USERNAME=sonar \</span><br><span class="line">	-e SONAR_JDBC_PASSWORD=sonar \</span><br><span class="line">	-e SONAR_JDBC_URL=&quot;jdbc:postgresql://192.168.88.236:5432/sonar&quot; \</span><br><span class="line">	--restart=always \</span><br><span class="line">	--privileged=true \</span><br><span class="line">    sonarqube:8.9.9-community</span><br><span class="line"></span><br><span class="line">## 验证</span><br><span class="line">docker logs -f sonarqube</span><br></pre></td></tr></table></figure>

<p>访问：<a href="http://192.168.88.235:9000/">http://192.168.88.235:9000/</a></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314134759.png" alt="image-20220314134752470"></p>
<p>默认账号：admin&#x2F;admin</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314134841.png" alt="image-20220314134841587"></p>
<h3 id="配置-Scanner"><a href="#配置-Scanner" class="headerlink" title="配置 Scanner"></a>配置 Scanner</h3><p><strong>安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line"></span><br><span class="line"># 获取安装包</span><br><span class="line">wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.6.0.2311-linux.zip</span><br><span class="line"></span><br><span class="line"># 解压到指定目录</span><br><span class="line">unzip -o -d  /usr/local/sonar-scanner /opt/sonar-scanner-cli-4.6.0.2311-linux.zip</span><br><span class="line"></span><br><span class="line"># 编辑环境变量</span><br><span class="line">vim /etc/profile</span><br><span class="line">export SCANNER_HOME=/usr/local/sonar-scanner/sonar-scanner-4.6.0.2311-linux</span><br><span class="line">export PATH=$PATH:$SCANNER_HOME/bin</span><br><span class="line"></span><br><span class="line"># 使环境变量生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"># 查看版本</span><br><span class="line">sonar-scanner -v</span><br><span class="line">INFO: Scanner configuration file: /usr/local/sonar-scanner-4.6.0.2311-linux/conf/sonar-scanner.properties</span><br><span class="line">INFO: Project root configuration file: NONE</span><br><span class="line">INFO: SonarScanner 4.6.0.2311</span><br><span class="line">INFO: Java 11.0.3 AdoptOpenJDK (64-bit)</span><br><span class="line">INFO: Linux 4.18.0-80.el8.x86_64 amd64</span><br><span class="line"></span><br><span class="line"># 修改使用的jdk</span><br><span class="line">vim /usr/local/sonar-scanner/sonar-scanner-4.6.0.2311-linux/bin/sonar-scanner</span><br></pre></td></tr></table></figure>

<h3 id="SonarQube-平台配置管理"><a href="#SonarQube-平台配置管理" class="headerlink" title="SonarQube 平台配置管理"></a>SonarQube 平台配置管理</h3><h4 id="安装中文插件"><a href="#安装中文插件" class="headerlink" title="安装中文插件"></a>安装中文插件</h4><p><strong>在线安装：操作如下图</strong></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314140021.png" alt="image-20220314140021697"></p>
<h4 id="配置强制登录"><a href="#配置强制登录" class="headerlink" title="配置强制登录"></a>配置强制登录</h4><p>默认所有的项目都可以公开的查看，在企业内肯定要配置成私有的。只有登录后才能查看</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314140634.png" alt="image-20220314140634628"></p>
<h3 id="Jenkins-配置-SonarScanner"><a href="#Jenkins-配置-SonarScanner" class="headerlink" title="Jenkins 配置 SonarScanner"></a>Jenkins 配置 SonarScanner</h3><p>创建 SonarQube 账户 token</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314143339.png" alt="image-20220314143339207"></p>
<p>将 token 保存到 Jenkins 凭据中</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314143433.png" alt="image-20220314143433728"></p>
<p>在 Jenkins 中安装<code>SonarQube Scanner</code>插件</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314143552.png" alt="image-20220314143552551"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统管理 -&gt; 系统配置 -&gt; 往下翻找到SonarQube servers -&gt; Add SonarQube -&gt; 添加服务器，选择凭据</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314143936.png" alt="image-20220314143936259"></p>
<h3 id="IDEA-配置-SonarLint-插件"><a href="#IDEA-配置-SonarLint-插件" class="headerlink" title="IDEA 配置 SonarLint 插件"></a>IDEA 配置 SonarLint 插件</h3><p>Token：a3268ff16b2d08b4582ff6a97342cc9d11b4e456</p>
<h2 id="Nexus-制品库安装与配置"><a href="#Nexus-制品库安装与配置" class="headerlink" title="Nexus 制品库安装与配置"></a>Nexus 制品库安装与配置</h2><h3 id="Docker-安装部署-Nexus-制品库"><a href="#Docker-安装部署-Nexus-制品库" class="headerlink" title="Docker 安装部署 Nexus 制品库"></a>Docker 安装部署 Nexus 制品库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">## 拉取镜像</span><br><span class="line">docker pull sonatype/nexus3:3.30.0</span><br><span class="line"></span><br><span class="line">## 创建数据目录</span><br><span class="line">mkdir -p /u01/cicd/nexus3/data</span><br><span class="line">chmod 777 -R /u01/cicd/nexus3/</span><br><span class="line"></span><br><span class="line">## 启动容器</span><br><span class="line">docker run -itd \</span><br><span class="line">--privileged=true --name=nexus3 \</span><br><span class="line">-p 8081:8081 \</span><br><span class="line">-v /u01/cicd/nexus3/data:/nexus-data \</span><br><span class="line">sonatype/nexus3:3.30.0</span><br><span class="line"></span><br><span class="line">## 验证</span><br><span class="line">docker logs nexus3 -f</span><br><span class="line"></span><br><span class="line">## 日志中出现 “Started Sonatype Nexus OSS 3.30.0-01” 为启动成功</span><br><span class="line">## http://your-ip-addr:8081 访问测试</span><br></pre></td></tr></table></figure>

<p>安装完成后，默认的 admin 密码存储在了数据目录，获取初始化密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -i nexus3 cat /nexus-data/admin.password</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314144935.png" alt="image-20220314144935748"></p>
<p>登录后更新密码</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314145010.png" alt="image-20220314145010632"></p>
<h3 id="Nexus-制品库搭建"><a href="#Nexus-制品库搭建" class="headerlink" title="Nexus 制品库搭建"></a>Nexus 制品库搭建</h3><h4 id="搭建-Maven-私服（代理仓库）"><a href="#搭建-Maven-私服（代理仓库）" class="headerlink" title="搭建 Maven 私服（代理仓库）"></a>搭建 Maven 私服（代理仓库）</h4><p>默认安装 nexus 后会自动创建的</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314145707.png" alt="img"></p>
<p>私服：将外网仓库代理到企业内部本地仓库中。图中的地址可以自定义修改</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314145907.png" alt="img"></p>
<h4 id="搭建制品库（本地仓库）"><a href="#搭建制品库（本地仓库）" class="headerlink" title="搭建制品库（本地仓库）"></a>搭建制品库（本地仓库）</h4><p>新建 raw 类型的仓库</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314145956.png" alt="img"></p>
<p>设置仓库的信息</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314150017.png" alt="img"></p>
<h3 id="上传制品"><a href="#上传制品" class="headerlink" title="上传制品"></a>上传制品</h3><p>在 nexus 中新建一个<code>maven-hostd</code>仓库，同时在 maven 的配置文件<code>settings.xml</code>中配置 maven-hostd 认证。具体配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;id&gt;maven-hosted&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;wx123!@#&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure>

<p>注意使用<code>mvn deploy</code>发布时，server.id&#x3D;repository.id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mvn deploy:deploy-file</span><br><span class="line">-DgroupId=xxxxxx pom中的groupId</span><br><span class="line">-DartifactId=xxxxxx pom中的artifactId</span><br><span class="line">-Dversion=xxxxxx pom中的版本号version</span><br><span class="line">-Dpackaging=xxxxxx pom中打包方式</span><br><span class="line">-Dfile=xxxxxx 本地文件</span><br><span class="line">-Durl=xxxxxx 仓库url</span><br><span class="line">-DrepositoryId=xxxxxx 对应的是setting.xml（认证）</span><br></pre></td></tr></table></figure>

<p>直接读取 pom 文件（方便）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mvn deploy:deploy-file \</span><br><span class="line">-DgeneratePom=false \</span><br><span class="line">-DrepositoryId=maven-hosted \</span><br><span class="line">-Durl=http://192.168.1.200:8081/repository/maven-hosted/ \</span><br><span class="line">-DpomFile=pom.xml \</span><br><span class="line">-Dfile=target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>自定义 pom 信息（灵活）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mvn deploy:deploy-file -Dmaven.test.skip=true  \</span><br><span class="line">-Dfile=target/demo-0.0.1-SNAPSHOT.jar \</span><br><span class="line">-DgroupId=com.example \</span><br><span class="line">-DartifactId=demo \</span><br><span class="line">-Dversion=1.1.1  \</span><br><span class="line">-Dpackaging=jar \</span><br><span class="line">-DrepositoryId=maven-hosted \</span><br><span class="line">-Durl=http://192.168.1.200:8081/repository/maven-hosted/</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314152655.png" alt="img"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314152725.png" alt="img"></p>
<h3 id="Jenkins-安装-Nexus-插件"><a href="#Jenkins-安装-Nexus-插件" class="headerlink" title="Jenkins 安装 Nexus 插件"></a>Jenkins 安装 Nexus 插件</h3><p>安装<code>Nexus Artifact Upload</code>插件，使用片段生成器生成 DSL</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314155314.png" alt="img"></p>
<p><strong>发布制品</strong></p>
<p>安装<code>Maven Artifact ChoiceListProvider (Nexus)</code>插件</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314155850.png" alt="images"></p>
<p>用户选择制品，在应用服务器通过 salt、ansible 下载制品并部署</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220314155911.png" alt="img"></p>
<h2 id="Ansible-安装与配置"><a href="#Ansible-安装与配置" class="headerlink" title="Ansible 安装与配置"></a>Ansible 安装与配置</h2><h3 id="基于-centos7-6-安装"><a href="#基于-centos7-6-安装" class="headerlink" title="基于 centos7.6 安装"></a>基于 centos7.6 安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APPLESCRIPT</span><br><span class="line"># 直接使用yum在线安装</span><br><span class="line">yum install ansible -y</span><br><span class="line"># 检查ansible版本</span><br><span class="line">ansible --version</span><br></pre></td></tr></table></figure>

<h3 id="添加-Ansible-主机列表"><a href="#添加-Ansible-主机列表" class="headerlink" title="添加 Ansible 主机列表"></a>添加 Ansible 主机列表</h3><h4 id="编辑-etc-ansible-hosts-文件"><a href="#编辑-etc-ansible-hosts-文件" class="headerlink" title="编辑 /etc/ansible/hosts 文件"></a>编辑 <code>/etc/ansible/hosts</code> 文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">vim /etc/hosts</span><br><span class="line">61.171.72.190 chxapp01.vansys.com</span><br><span class="line">61.171.72.190 chxapp02.vansys.com</span><br><span class="line">61.171.72.190 chxapp03.vansys.com</span><br><span class="line"></span><br><span class="line">vim /etc/ansible/hosts</span><br><span class="line">chxapp01.vansys.com ansible_ssh_user=root ansible_ssh_port=51722</span><br><span class="line">chxapp02.vansys.com ansible_ssh_user=root ansible_ssh_port=51822</span><br><span class="line">chxapp03.vansys.com ansible_ssh_user=root ansible_ssh_port=51522</span><br></pre></td></tr></table></figure>

<h4 id="发送公钥到目标主机"><a href="#发送公钥到目标主机" class="headerlink" title="发送公钥到目标主机"></a>发送公钥到目标主机</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 生成私钥和公钥（已有则忽略）</span><br><span class="line">cd ~/.ssh &amp;&amp; ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub -p SSH端口 IP</span><br></pre></td></tr></table></figure>

<h4 id="测试连通性"><a href="#测试连通性" class="headerlink" title="测试连通性"></a>测试连通性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">ansible host01,host02 -m ping -o</span><br></pre></td></tr></table></figure>

<h2 id="安装-Npm-包管理器"><a href="#安装-Npm-包管理器" class="headerlink" title="安装 Npm 包管理器"></a>安装 Npm 包管理器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line"></span><br><span class="line"># 下载node安装包</span><br><span class="line">wget https://nodejs.org/dist/v14.16.1/node-v14.16.1-linux-x64.tar.xz</span><br><span class="line">mkdir -p /usr/local/node</span><br><span class="line">tar xf node-v14.16.1-linux-x64.tar.xz -C /usr/local/node/</span><br><span class="line"></span><br><span class="line"># 编辑环境变量</span><br><span class="line">vim /etc/profile</span><br><span class="line">export NODE_HOME=/usr/local/node/node-v14.16.1-linux-x64</span><br><span class="line">export PATH=$NODE_HOME/bin:$PATH</span><br><span class="line"># 生效</span><br><span class="line">source /etc/profile</span><br><span class="line"># 查看是否安装成功</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"># 设置镜像</span><br><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br><span class="line"></span><br><span class="line"># 设置软链接</span><br><span class="line">unlink /usr/bin/node</span><br><span class="line">whereis node</span><br><span class="line">ln -s /usr/local/node/node-v14.16.1-linux-x64/bin/node /usr/bin/node</span><br></pre></td></tr></table></figure>

<h2 id="Centos6-配置-yum"><a href="#Centos6-配置-yum" class="headerlink" title="Centos6 配置 yum"></a>Centos6 配置 yum</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line"># centos6配置yum</span><br><span class="line">sed -i “s|enabled=1|enabled=0|g” /etc/yum/pluginconf.d/fastestmirror.conf</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://www.xmpan.com/Centos-6-Vault-Aliyun.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h2 id="Minio-文件服务安装与配置"><a href="#Minio-文件服务安装与配置" class="headerlink" title="Minio 文件服务安装与配置"></a>Minio 文件服务安装与配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line"></span><br><span class="line"># 二进制安装</span><br><span class="line">wget https://dl.min.io/server/minio/release/linux-amd64/minio</span><br><span class="line">chmod +x minio</span><br><span class="line">MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /mnt/data --console-address &quot;:9001&quot;</span><br><span class="line"></span><br><span class="line"># 后台启动</span><br><span class="line">MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=&#x27;wx123!@#&#x27; nohup /u01/minio-server/minio server /u01/minio-server/data --console-address &quot;:9001&quot; &gt; /u01/minio-server/minio.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"># docker安装</span><br><span class="line">mkdir -p /u01/minio/data</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">  -p 9000:9000 \</span><br><span class="line">  -p 9001:9001 \</span><br><span class="line">  --name minio \</span><br><span class="line">  -v /u01/minio/data:/data \</span><br><span class="line">  -v /u01/minio/config:/root/.minio \</span><br><span class="line">  -e &quot;MINIO_ROOT_USER=q5H0EO1pbv&quot; \</span><br><span class="line">  -e &quot;MINIO_ROOT_PASSWORD=Wyk1dkn4Xp&quot; \</span><br><span class="line">  -e MINIO_SERVER_URL=http://192.168.88.200:9000 \</span><br><span class="line">  -e MINIO_BROWSER_REDIRECT_URL=http://192.168.88.200:9001 \</span><br><span class="line">  quay.io/minio/minio server /data \</span><br><span class="line">  --address &quot;:9000&quot; --console-address &quot;:9001&quot;</span><br></pre></td></tr></table></figure>

<h2 id="GitStats-代码统计工具安装与配置"><a href="#GitStats-代码统计工具安装与配置" class="headerlink" title="GitStats 代码统计工具安装与配置"></a>GitStats 代码统计工具安装与配置</h2><h3 id="安装-Ruby-环境"><a href="#安装-Ruby-环境" class="headerlink" title="安装 Ruby 环境"></a>安装 Ruby 环境</h3><p>GitStats 需要 ruby-2.5 以上环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 下载：</span><br><span class="line">wget https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.0.tar.gz</span><br><span class="line"># 解压：</span><br><span class="line">tar -zxvf ruby-2.5.0.tar.gz</span><br><span class="line"># 进入目录：</span><br><span class="line">cd ruby-2.5.0</span><br><span class="line"># 创建安装目录：</span><br><span class="line">mkdir -p /usr/local/ruby</span><br><span class="line"># 安装必备依赖</span><br><span class="line">yum -y install gcc openssl-devel make</span><br><span class="line"># 配置并制定安装位置：</span><br><span class="line">./configure --prefix=/usr/local/ruby</span><br><span class="line"># 编译安装</span><br><span class="line">make  &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">安装完成输入  ruby -v 提示/usr/bin/ruby: No such file or directory</span><br><span class="line"></span><br><span class="line">解决问题之前，先确认一个情况，输入命令 /usr/local/ruby/bin/ruby --version</span><br><span class="line"></span><br><span class="line">如果有版本信息，那说明ruby被装到了该目录下，而非系统认为的 /usr/bin/ruby</span><br><span class="line"></span><br><span class="line">解决方法是在系统默认运行ruby的位置[/usr/bin/ruby]创建一个symlink（相当于win下的快捷方式），指向ruby的实际位置[/usr/local/ruby/bin/ruby]</span><br><span class="line"></span><br><span class="line">建立软链接</span><br><span class="line">命令是  ln -s /usr/local/ruby/bin/ruby /usr/bin/ruby</span><br><span class="line">再输入   ruby -v           OK完成</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">附赠：要是安装gem也出现这种情况[-bash: /usr/bin/gem: No such file or directory]也是同理</span><br><span class="line"></span><br><span class="line">ln -s /usr/local/ruby/bin/gem /usr/bin/gem</span><br><span class="line"></span><br><span class="line">#查看当前仓库地址</span><br><span class="line">gem sources -l</span><br><span class="line">#配置阿里云仓库源</span><br><span class="line">gem sources -a http://mirrors.aliyun.com/rubygems/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure>

<h3 id="安装-GitStats"><a href="#安装-GitStats" class="headerlink" title="安装 GitStats"></a>安装 GitStats</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line"></span><br><span class="line"># 安装 git_stats</span><br><span class="line">gem install git_stats</span><br><span class="line"># 安装locate</span><br><span class="line">yum install mlocate -y</span><br><span class="line">updatedb</span><br><span class="line"># find 命令查找 git_stats 目录</span><br><span class="line">find / -name &#x27;git_stats&#x27;</span><br><span class="line"># 进入到配置目录</span><br><span class="line">cd /usr/local/ruby/lib/ruby/gems/2.5.0/gems/git_stats-1.0.17/config/locales/</span><br><span class="line">cp zh_tw_default.yml zh_default.yml</span><br><span class="line">#修改以下2个yml,将最上边的zh_tw调整为zh_cn，其余不变</span><br><span class="line">vim zh_default.yml</span><br><span class="line">vim zh.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 若报以下错误</span><br><span class="line">ERROR:  Error installing git_stats:</span><br><span class="line">	The last version of nokogiri (~&gt; 1.6) to support your Ruby &amp; RubyGems was 1.12.5. Try installing it with `gem install nokogiri -v 1.12.5` and then running the current command again</span><br><span class="line"></span><br><span class="line"># 运行</span><br><span class="line">gem install nokogiri -v 1.12.5</span><br><span class="line"></span><br><span class="line"># 配置环境变量，放到末尾</span><br><span class="line">vim /etc/profile</span><br><span class="line">PATH=/usr/local/ruby/bin:$PATH</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line"># 使之生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="使用-GitStats-生成报告"><a href="#使用-GitStats-生成报告" class="headerlink" title="使用 GitStats 生成报告"></a>使用 GitStats 生成报告</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line"># 创建一个项目文件夹</span><br><span class="line">mkdir -p /u01/git-project</span><br><span class="line"># 创建一个报告生成文件夹</span><br><span class="line">mkdir -p /var/www/git-report</span><br><span class="line"></span><br><span class="line"># 使用 git 将项目 clone 到项目文件夹中</span><br><span class="line">git clone xxx.git</span><br><span class="line"># 切换到项目根目录，使用 git_stats 生成报告</span><br><span class="line">git_stats generate -o /var/www/git-report/xxx --language zh_cn</span><br></pre></td></tr></table></figure>

<h3 id="配置-nginx-访问"><a href="#配置-nginx-访问" class="headerlink" title="配置 nginx 访问"></a>配置 nginx 访问</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGINX</span><br><span class="line">server &#123;</span><br><span class="line">        listen       8098;</span><br><span class="line">        server_name  192.168.88.235;</span><br><span class="line"></span><br><span class="line">	    location /vansysboot &#123;</span><br><span class="line">            alias   /var/www/git-report/vansysboot;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安装-Prometheus-Grafana-监控平台"><a href="#安装-Prometheus-Grafana-监控平台" class="headerlink" title="安装 Prometheus + Grafana 监控平台"></a>安装 Prometheus + Grafana 监控平台</h2><blockquote>
<p>官网：<a href="https://prometheus.io/">https://prometheus.io/</a></p>
<p>下载地址：<a href="https://prometheus.io/download/">https://prometheus.io/download/</a></p>
</blockquote>
<h3 id="安装-Prometheus-Server"><a href="#安装-Prometheus-Server" class="headerlink" title="安装 Prometheus Server"></a>安装 Prometheus Server</h3><p><code>Prometheus</code> 基于 <code>Golang</code> 编写，编译后的软件包，不依赖于任何的第三方依赖。只需要下载对应平台的二进制包，解压并且添加基本的配置即可正常启动 <code>Prometheus Server</code>。</p>
<h4 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h4><p>上传 <code>prometheus-2.29.1.linux-amd64.tar.gz</code> 到虚拟机的 <code>/opt</code> 目录</p>
<h4 id="解压安装包-2"><a href="#解压安装包-2" class="headerlink" title="解压安装包"></a>解压安装包</h4><ol>
<li>解压到 <code>/u01/module</code> 目录下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">tar -zxvf prometheus-2.37.0.linux-amd64.tar.gz -C /u01/module</span><br></pre></td></tr></table></figure>

<ol>
<li>修改目录名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd /u01/module</span><br><span class="line">mv prometheus-2.37.0.linux-amd64.tar.gz prometheus-2.37.0</span><br></pre></td></tr></table></figure>

<h4 id="修改配置文件-prometheus-yml"><a href="#修改配置文件-prometheus-yml" class="headerlink" title="修改配置文件 prometheus.yml"></a>修改配置文件 prometheus.yml</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd prometheus-2.37.0</span><br><span class="line">vim prometheus.yml</span><br></pre></td></tr></table></figure>

<p>在 scrape_configs 配置项下添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line"># 添加 PushGateway 监控配置</span><br><span class="line">- job_name: &#x27;pushgateway&#x27;</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets: [&#x27;192.168.88.231:9091&#x27;]</span><br><span class="line">    labels:</span><br><span class="line">      instance: pushgateway</span><br><span class="line"></span><br><span class="line"># 添加 Node Exporter 监控配置</span><br><span class="line">- job_name: &#x27;node exporter&#x27;</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets: [&#x27;192.168.88.230:9100&#x27;, &#x27;192.168.88.231:9100&#x27;, &#x27;192.168.88.232:9100&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>配置说明：</strong></p>
<ol>
<li><strong>global 配置块</strong>：控制 Prometheus 服务器的全局配置<ul>
<li>scrape_interval：配置拉取数据的时间间隔，默认为 1 分钟。</li>
<li>evaluation_interval：规则验证（生成 alert）的时间间隔，默认为 1 分钟。</li>
</ul>
</li>
<li><strong>rule_files 配置块</strong>：规则配置文件</li>
<li><strong>scrape_configs 配置块</strong>：配置采集目标相关， prometheus 监视的目标。Prometheus 自身的运行信息可以通过 HTTP 访问，所以 Prometheus 可以监控自己的运行数据。<ul>
<li>job_name：监控作业的名称</li>
<li>static_configs：表示静态目标配置，就是固定从某个 target 拉取数据</li>
<li>targets ： 指 定 监 控 的 目 标 ， 其 实 就 是 从 哪 儿 拉 取 数 据 。 Prometheus 会从 <a href="http://ip:9090/metrics">http://ip:9090/metrics</a> 上拉取数据。</li>
</ul>
</li>
</ol>
<blockquote>
<p><em>Prometheus 是可以在运行时自动加载配置的。启动时需要添加：–web.enable-lifecycle</em></p>
<p><em>重载配置命令：<code>curl -X POST http://127.0.0.1:9090/-/reload</code></em></p>
</blockquote>
<h3 id="安装-Node-Exporter"><a href="#安装-Node-Exporter" class="headerlink" title="安装 Node Exporter"></a>安装 Node Exporter</h3><p>在 <code>Prometheus</code> 的架构设计中，<code>Prometheus Server</code> 主要负责数据的收集，存储并且对外提供数据查询支持，而实际的监控样本数据的收集则是由 <code>Exporter</code> 完成。因此为了能够监控到某些东西，如主机的 <code>CPU</code> 使用率，我们需要使用到 <code>Exporter</code>。<code>Prometheus</code> 周期性的从 <code>Exporter</code> 暴露的 HTTP 服务地址（通常是 <code>/metrics</code> ）拉取监控样本数据。</p>
<p><code>Exporter</code> 可以是一个相对开放的概念，其可以是一个独立运行的程序独立于监控目标以外，也可以是直接内置在监控目标中。只要能够向 <code>Prometheus</code> 提供标准格式的监控样本数据即可。</p>
<p>为了能够采集到主机的运行指标如 CPU, 内存，磁盘等信息。我们可以使用 <code>Node Exporter</code>。<code>Node Exporter</code> 同样采用 <code>Golang</code> 编写，并且不存在任何的第三方依赖，只需要下载，解压即可运行。</p>
<h4 id="上传安装包-1"><a href="#上传安装包-1" class="headerlink" title="上传安装包"></a>上传安装包</h4><p>上传 <code>node_exporter-1.4.0-rc.0.linux-amd64.tar.gz</code> 到虚拟机的 <code>/opt</code> 目录</p>
<h4 id="解压安装包-3"><a href="#解压安装包-3" class="headerlink" title="解压安装包"></a>解压安装包</h4><ol>
<li>解压到 <code>/u01/module</code> 目录下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">tar -zxvf node_exporter-1.4.0-rc.0.linux-amd64.tar.gz -C /u01/module</span><br></pre></td></tr></table></figure>

<ol>
<li>修改目录名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd /u01/module</span><br><span class="line">mv node_exporter-1.4.0-rc.0.linux-amd64.tar.gz node_exporter-1.4.0-rc</span><br></pre></td></tr></table></figure>

<ol>
<li>启动并访问端点查看是否成功</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 执行启动命令</span><br><span class="line">./node_exporter</span><br></pre></td></tr></table></figure>

<p>浏览器输入：<a href="http://ip:9100/metrics%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%BD%93%E5%89%8D">http://ip:9100/metrics，可以看到当前</a> node exporter 获取到的当前主机的所有监控数据。</p>
<h4 id="节点分发"><a href="#节点分发" class="headerlink" title="节点分发"></a>节点分发</h4><p>将解压的目录分发到要监控的节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">xsync node_exporter-1.4.0-rc</span><br></pre></td></tr></table></figure>

<p><strong>添加文件分发脚本</strong></p>
<p>创建脚本文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">vim /usr/bin/xsync</span><br></pre></td></tr></table></figure>

<p>脚本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"># 判断参数是否足够</span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line"> echo Not Enounh Arguement!</span><br><span class="line"> exit;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 遍历所有的机器</span><br><span class="line">for host in 192.168.88.230 192.168.88.231 192.168.88.232</span><br><span class="line">do</span><br><span class="line"> echo ============  $host ============</span><br><span class="line"> for file in $@</span><br><span class="line"> do</span><br><span class="line">  # 判断文件是否存在</span><br><span class="line">  if [ -e $file ]</span><br><span class="line">  then</span><br><span class="line">   # 获取父目录</span><br><span class="line">   pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line"></span><br><span class="line">   # 获取当前目录的名称</span><br><span class="line">   fname=$(basename $file)</span><br><span class="line">   ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">   rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">  else</span><br><span class="line">   echo $file does not exists!</span><br><span class="line">  fi</span><br><span class="line"> done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>若报错 <code>bash: rsync: command not found</code>，请在目标机器上安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># Centos</span><br><span class="line">yum install rsync -y</span><br></pre></td></tr></table></figure>

<p>赋予执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">chmod +x /usr/bin/xsync</span><br></pre></td></tr></table></figure>

<p><strong>运行条件</strong></p>
<p>使用 ssh 密钥验证登录，这样在传输文件时就不需要进行二次验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 生成ssh私钥（若有这忽略）</span><br><span class="line">ssh-keygen -f ~/.ssh/id_rsa -N &#x27;&#x27;</span><br><span class="line"># 循环把公钥传递到服务器上，免密登录</span><br><span class="line">for i in 192.168.88.230 192.168.88.231 192.168.88.232</span><br><span class="line">do</span><br><span class="line">  ssh-copy-id $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 根据提示输入密码</span><br></pre></td></tr></table></figure>

<h4 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h4><h5 id="centos6"><a href="#centos6" class="headerlink" title="centos6"></a>centos6</h5><ol>
<li>创建自启动脚本</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">vim /etc/init.d/node_exporter</span><br><span class="line">#!/bin/bash</span><br><span class="line">#	/etc/rc.d/init.d/node_exporter</span><br><span class="line"># chkconfig: 2345 80 80</span><br><span class="line">#</span><br><span class="line"># config: /etc/prometheus/node_exporter.conf</span><br><span class="line"># pidfile: /var/run/prometheus/node_exporter.pid</span><br><span class="line"></span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/init.d/functions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RETVAL=0</span><br><span class="line">PROG=&quot;node_exporter&quot;</span><br><span class="line">DAEMON_SYSCONFIG=/etc/sysconfig/$&#123;PROG&#125;</span><br><span class="line">DAEMON=/usr/bin/$&#123;PROG&#125; #要把安装目录下/u01/module/node_exporter/node_exporter可执行文件拷贝到/usr/bin目录下</span><br><span class="line">PID_FILE=/var/run/prometheus/$&#123;PROG&#125;.pid</span><br><span class="line">LOCK_FILE=/var/lock/subsys/$&#123;PROG&#125;</span><br><span class="line">LOG_FILE=/var/log/prometheus/node_exporter.log</span><br><span class="line">DAEMON_USER=&quot;prometheus&quot;</span><br><span class="line">FQDN=$(hostname)</span><br><span class="line">GOMAXPROCS=$(grep -c ^processor /proc/cpuinfo)</span><br><span class="line"></span><br><span class="line">. $&#123;DAEMON_SYSCONFIG&#125;</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">  if check_status &gt; /dev/null; then</span><br><span class="line">    echo &quot;node_exporter is already running&quot;</span><br><span class="line">    exit 0</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  echo -n $&quot;Starting node_exporter: &quot;</span><br><span class="line">  daemonize -u $&#123;DAEMON_USER&#125; -p $&#123;PID_FILE&#125; -l $&#123;LOCK_FILE&#125; -a -e $&#123;LOG_FILE&#125; -o $&#123;LOG_FILE&#125; $&#123;DAEMON&#125; $&#123;ARGS&#125;</span><br><span class="line">  RETVAL=$?</span><br><span class="line">  echo &quot;&quot;</span><br><span class="line">  return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    echo -n $&quot;Stopping node_exporter: &quot;</span><br><span class="line">    killproc -p $&#123;PID_FILE&#125; -d 10 $&#123;DAEMON&#125;</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">    [ $RETVAL = 0 ] &amp;&amp; rm -f $&#123;LOCK_FILE&#125; $&#123;PID_FILE&#125;</span><br><span class="line">    return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_status() &#123;</span><br><span class="line">    status -p $&#123;PID_FILE&#125; $&#123;DAEMON&#125;</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">	check_status</span><br><span class="line">        ;;</span><br><span class="line">    reload|force-reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        N=/etc/init.d/$&#123;NAME&#125;</span><br><span class="line">        echo &quot;Usage: $N &#123;start|stop|status|restart|force-reload&#125;&quot; &gt;&amp;2</span><br><span class="line">        RETVAL=2</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit $&#123;RETVAL&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>编辑 etc&#x2F;sysconfig&#x2F;node_exporter</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">vim /etc/sysconfig/node_exporter</span><br><span class="line">##添加如下内容</span><br><span class="line">ARGS=&quot;&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建启动脚本中对应文件和目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">##开机脚本赋权</span><br><span class="line">chmod 777 /etc/init.d/node_exporter</span><br><span class="line"></span><br><span class="line">##拷贝可执行文件到/usr/bin/</span><br><span class="line">cp /u01/node_exporter-1.4.0-rc/node_exporter /usr/bin/node_exporter</span><br><span class="line"></span><br><span class="line">## 添加用户组</span><br><span class="line">groupadd -r prometheus</span><br><span class="line"></span><br><span class="line">## 创建目录</span><br><span class="line">mkdir -p /usr/hostonnet/prometheus/</span><br><span class="line">useradd -r -g prometheus -s /sbin/nologin -d /usr/hostonnet/prometheus/ -c &quot;prometheus Daemons&quot; prometheus</span><br><span class="line"></span><br><span class="line">## 家目录修改属主</span><br><span class="line">chown -R prometheus:prometheus /usr/hostonnet/prometheus/</span><br><span class="line"></span><br><span class="line">## 创建运行目录</span><br><span class="line">mkdir -p /var/run/prometheus/</span><br><span class="line">chmod 777 /var/run/prometheus/</span><br><span class="line"></span><br><span class="line">## 创建pid文件，并赋权</span><br><span class="line">touch /var/run/prometheus/node_exporter.pid</span><br><span class="line">chmod 777 /var/run/prometheus/node_exporter.pid</span><br><span class="line"></span><br><span class="line">## 创建日志目录，并创建日志文件，赋权，修改属主</span><br><span class="line">mkdir -p /var/log/prometheus/</span><br><span class="line">touch /var/log/prometheus/node_exporter.log</span><br><span class="line">chmod 777 /var/log/prometheus</span><br><span class="line">chmod 777 /var/log/prometheus/node_exporter.log</span><br><span class="line">chown prometheus:prometheus /var/log/prometheus/node_exporter.log</span><br><span class="line"></span><br><span class="line"># 批量执行语句</span><br><span class="line">chmod 777 /etc/init.d/node_exporter &amp;&amp; cp /u01/node_exporter-1.4.0-rc/node_exporter /usr/bin/node_exporter &amp;&amp; groupadd -r prometheus &amp;&amp; mkdir -p /usr/hostonnet/prometheus/ &amp;&amp; useradd -r -g prometheus -s /sbin/nologin -d /usr/hostonnet/prometheus/ -c &quot;prometheus Daemons&quot; prometheus &amp;&amp; chown -R prometheus:prometheus /usr/hostonnet/prometheus/ &amp;&amp; mkdir -p /var/run/prometheus/ &amp;&amp; chmod 777 /var/run/prometheus/ &amp;&amp; touch /var/run/prometheus/node_exporter.pid &amp;&amp; chmod 777 /var/run/prometheus/node_exporter.pid &amp;&amp; mkdir -p /var/log/prometheus/ &amp;&amp; touch /var/log/prometheus/node_exporter.log &amp;&amp; chmod 777 /var/log/prometheus &amp;&amp; chmod 777 /var/log/prometheus/node_exporter.log &amp;&amp; chown prometheus:prometheus /var/log/prometheus/node_exporter.log</span><br></pre></td></tr></table></figure>

<ol>
<li>安装 daemonize</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">rpm -ivh daemonize-1.6.0-1.el6.rf.x86_64.rpm</span><br></pre></td></tr></table></figure>

<ol>
<li>运行 node_exporter</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWK</span><br><span class="line">#启动 node_exporter 并设置开机自启动</span><br><span class="line">cd /etc/init.d/ &amp;&amp; ./node_exporter start &amp;&amp; chkconfig node_exporter on</span><br></pre></td></tr></table></figure>

<h5 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h5><ol>
<li>创建 service 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo vim /usr/lib/systemd/system/node_exporter.service</span><br></pre></td></tr></table></figure>

<p>文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INI</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=node_export</span><br><span class="line">Documentation=https://github.com/prometheus/node_exporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart= /u01/node_exporter-1.4.0-rc/node_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<ol>
<li>分发文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">xsync /usr/lib/systemd/system/node_exporter.service</span><br></pre></td></tr></table></figure>

<ol>
<li>设置开机自启并启动（所有机器都执行）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 开机自启</span><br><span class="line">sudo systemctl enable node_exporter.service</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line">sudo systemctl start node_exporter.service</span><br></pre></td></tr></table></figure>

<h3 id="安装-Alertmanager"><a href="#安装-Alertmanager" class="headerlink" title="安装 Alertmanager"></a>安装 Alertmanager</h3><h4 id="上传安装包-2"><a href="#上传安装包-2" class="headerlink" title="上传安装包"></a>上传安装包</h4><p>上传 <code>alertmanager-0.24.0.linux-amd64.tar.gz</code> 到虚拟机的 <code>/opt</code> 目录</p>
<h4 id="解压安装包-4"><a href="#解压安装包-4" class="headerlink" title="解压安装包"></a>解压安装包</h4><ol>
<li>解压到 <code>/u01/module</code> 目录下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">tar -zxvf alertmanager-0.24.0.linux-amd64.tar.gz -C /u01/module</span><br></pre></td></tr></table></figure>

<ol>
<li>修改目录名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd /u01/module</span><br><span class="line">mv alertmanager-0.24.0.linux-amd64.tar.gz alertmanager-0.24.0</span><br></pre></td></tr></table></figure>

<h3 id="启动-Prometheus-Server-和-Alertmanager"><a href="#启动-Prometheus-Server-和-Alertmanager" class="headerlink" title="启动 Prometheus Server 和 Alertmanager"></a>启动 Prometheus Server 和 Alertmanager</h3><h4 id="在-Prometheus-Server-目录下执行启动命令"><a href="#在-Prometheus-Server-目录下执行启动命令" class="headerlink" title="在 Prometheus Server 目录下执行启动命令"></a>在 Prometheus Server 目录下执行启动命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">nohup ./prometheus --config.file=prometheus.yml --web.enable-lifecycle &gt; ./prometheus.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<h4 id="在-Alertmanager-目录下启动"><a href="#在-Alertmanager-目录下启动" class="headerlink" title="在 Alertmanager 目录下启动"></a>在 Alertmanager 目录下启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">nohup ./alertmanager --config.file=alertmanager.yml &gt; ./alertmanager.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<h3 id="安装-Grafana-数据展示"><a href="#安装-Grafana-数据展示" class="headerlink" title="安装 Grafana 数据展示"></a>安装 Grafana 数据展示</h3><p>grafana 是一款采用 Go 语言编写的开源应用，主要用于大规模指标数据的可视化展现，是网络架构和应用分析中最流行的时序数据展示工具，目前已经支持绝大部分常用的时序数据库。</p>
<blockquote>
<p>下载地址：<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p>
</blockquote>
<h4 id="上传安装包-3"><a href="#上传安装包-3" class="headerlink" title="上传安装包"></a>上传安装包</h4><p>将 <code>grafana-enterprise-9.0.6.linux-amd64.tar.gz</code> 上传至 <code>/opt</code> 目录下</p>
<h4 id="解压安装包-5"><a href="#解压安装包-5" class="headerlink" title="解压安装包"></a>解压安装包</h4><ol>
<li>解压到 <code>/u01/module</code> 目录下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">tar -zxvf grafana-enterprise-9.0.6.linux-amd64.tar.gz -C /u01/module</span><br></pre></td></tr></table></figure>

<ol>
<li>修改目录名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd /u01/module</span><br><span class="line">mv grafana-enterprise-9.0.6.linux-amd64.tar.gz grafana-enterprise-9.0.6</span><br></pre></td></tr></table></figure>

<ol>
<li>启动 grafana 服务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">nohup ./bin/grafana-server web &gt; ./grafana.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<ol>
<li>打开浏览器，访问：<a href="http://ip:3000，默认用户名/密码：admin">http://ip:3000，默认用户名/密码：admin</a></li>
</ol>
<h3 id="Grafana-与-Prometheus-数据对接"><a href="#Grafana-与-Prometheus-数据对接" class="headerlink" title="Grafana 与 Prometheus 数据对接"></a>Grafana 与 Prometheus 数据对接</h3><h4 id="添加-Prometheus-数据源"><a href="#添加-Prometheus-数据源" class="headerlink" title="添加 Prometheus 数据源"></a>添加 Prometheus 数据源</h4><ol>
<li><code>配置 -&gt; 数据源 -&gt; 添加数据源</code></li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804165746.png" alt="image-20220804165739264"></p>
<ol>
<li>选择 <code>Prometheus</code> 数据源</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804165940.png" alt="image-20220804165940226"></p>
<ol>
<li>配置 Prometheus Server 地址</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804170315.png" alt="image-20220804170315289"></p>
<ol>
<li>点击下方的 Save&amp;Test</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804170439.png" alt="image-20220804170439669"></p>
<ol>
<li>点击 Back 返回即可，可以看到 Data Sources 页面，出现了添加的 Prometheus：</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804171225.png" alt="image-20220804171224982"></p>
<h4 id="添加仪表盘-Dashboard"><a href="#添加仪表盘-Dashboard" class="headerlink" title="添加仪表盘 Dashboard"></a>添加仪表盘 Dashboard</h4><p>手动一个个添加 Dashboard 比较繁琐，Grafana 社区鼓励用户分享 Dashboard，通过 <a href="https://grafana.com/grafana/dashboards">https://grafana.com/grafana/dashboards</a> 网站，可以找到大量可直接使用的 Dashboard 模板。</p>
<p>Grafana 中所有的 Dashboard 通过 JSON 进行共享，下载并且导入这些 JSON 文件，就可以直接使用这些已经定义好的 Dashboard。</p>
<ol>
<li>选择一款中文版本的 <code>Node Exporter</code> 仪表板</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804173336.png" alt="image-20220804173336648"></p>
<ol>
<li>下载模板 json 文件</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804173609.png" alt="image-20220804173609120"></p>
<ol>
<li>在 Grafana 中导入模板</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804173822.png" alt="image-20220804173822051"></p>
<ol>
<li>导入之后选择 <code>Prometheus</code> 数据源即可</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804174154.png" alt="image-20220804174153940"></p>
<ol>
<li>导入成功之后就能看到炫酷的仪表板</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220804174504.png" alt="image-20220804174503814"></p>
<h3 id="安装-OracleDB-Exporter-监控-Oracle-数据库"><a href="#安装-OracleDB-Exporter-监控-Oracle-数据库" class="headerlink" title="安装 OracleDB Exporter 监控 Oracle 数据库"></a>安装 OracleDB Exporter 监控 Oracle 数据库</h3><blockquote>
<p>GitHub 仓库：<a href="https://github.com/iamseth/oracledb_exporter">iamseth&#x2F;oracledb_exporter: Prometheus Oracle database exporter. (github.com)</a></p>
<p>Grafana 面板：<a href="https://grafana.com/grafana/dashboards/11121-oracledb/">Oracledb 监控-性能与表空间 | Grafana Labs</a></p>
<p>以下步骤是采用 Docker 进行安装</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 1、拉取最新版本镜像</span><br><span class="line">docker pull ghcr.io/iamseth/oracledb_exporter:0.5.0</span><br><span class="line"># 2、使用 docker run 命令启动</span><br><span class="line"># 注意：1、--link 连接 oracle 数据库容器，这样在 oracledb_exporter 容器中可以直接使用容器名字代替 IP 地址进行通信</span><br><span class="line"># 	   2、若密码中含有 !@#$ 等特殊字符，可以使用 URLEncode 进行转义</span><br><span class="line">docker run -d --name oracledb_exporter --link=oracle11g -p 9161:9161 -e &#x27;DATA_SOURCE_NAME=oracle://sys:123456@oracle11g:1521/orcl&#x27; ghcr.io/iamseth/oracledb_exporter:0.5.0</span><br><span class="line"># 3、使用 culr 访问指标情况</span><br><span class="line">curl -l http://127.0.0.1:9161/metric</span><br><span class="line"># 4、接入 Prometheus</span><br><span class="line">在 prometheus.yml 中添加一段配置：</span><br><span class="line">  - job_name: oracledb_exporter</span><br><span class="line">    metrics_path: /metrics</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;chxdb21.vansys.com:15090&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="Docker-安装-ClickHouse-数据库-a"><a href="#Docker-安装-ClickHouse-数据库-a" class="headerlink" title="Docker 安装 ClickHouse 数据库 a"></a>Docker 安装 ClickHouse 数据库 a</h2><blockquote>
<p>前提：请先安装好 Docker 容器服务（<a href="https://blog.kyire.site/2022/04/02/2f74bb89.html#%E5%AE%89%E8%A3%85-Docker-%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1">安装 Docker 容器服务</a>）</p>
</blockquote>
<ol>
<li>创建目录并更改权限</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mkdir -p /u01/clickhouse/&#123;data,config,log&#125;</span><br><span class="line"></span><br><span class="line">chmod -R 777 /u01/clickhouse/&#123;data,config,log&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>拉取镜像</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker pull yandex/clickhouse-server</span><br></pre></td></tr></table></figure>

<ol>
<li>创建临时容器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker run --rm -d --name=clickhouse-server \</span><br><span class="line">--ulimit nofile=262144:262144 \</span><br><span class="line">-p 8123:8123 -p 9009:9009 -p 9000:9000 \</span><br><span class="line">yandex/clickhouse-server:latest</span><br></pre></td></tr></table></figure>

<ol>
<li>复制临时容器内配置文件到宿主机</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker cp clickhouse-server:/etc/clickhouse-server/config.xml /u01/clickhouse/config/config.xml</span><br><span class="line"></span><br><span class="line">docker cp clickhouse-server:/etc/clickhouse-server/users.xml /u01/clickhouse/config/users.xml</span><br></pre></td></tr></table></figure>

<ol>
<li>停掉临时容器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker rm -f clickhouse-server</span><br></pre></td></tr></table></figure>

<ol>
<li>default 用户配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 生成sha256sum密码</span><br><span class="line"></span><br><span class="line"># 随机生成密码</span><br><span class="line">PASSWORD=$(base64 &lt; /dev/urandom | head -c8); echo &quot;$PASSWORD&quot;; echo -n &quot;$PASSWORD&quot; | sha256sum | tr -d &#x27;-&#x27;</span><br><span class="line"></span><br><span class="line">会输出明码和SHA256密码（每个人生成的不一样）</span><br><span class="line">jQ+72k17</span><br><span class="line">a70b3173bfef01aff0d2472fd1f86a4be647aed4e0624f1b6c867a69072e1273</span><br><span class="line"></span><br><span class="line"># 生成指定密码wx123456</span><br><span class="line">echo &quot;wx123456&quot;; echo -n &quot;wx123456&quot; | sha256sum | tr -d &#x27;-&#x27;</span><br><span class="line">wx123456</span><br><span class="line">37acf78e288b1323fae2115749edcf696b6190d8c8ca1cbc66e39b10e22f2a86</span><br><span class="line"></span><br><span class="line"># 打开users.xml文件 default用户设置密码为123456</span><br><span class="line">vim /u01/clickhouse/config/users.xml</span><br><span class="line"></span><br><span class="line"># 将文件中&lt;password&gt;&lt;/password&gt;改为以下内容</span><br><span class="line">&lt;password_sha256_hex&gt;37acf78e288b1323fae2115749edcf696b6190d8c8ca1cbc66e39b10e22f2a86&lt;/password_sha256_hex&gt;</span><br><span class="line"></span><br><span class="line"># 将default用户改为只读</span><br><span class="line"># 将&lt;profile&gt;default&lt;/profile&gt;改为以下内容</span><br><span class="line">&lt;profile&gt;readonly&lt;/profile&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>新增 root 用户</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 生成root用户密码wx123456</span><br><span class="line">echo &quot;wx123456&quot;; echo -n &quot;wx123456&quot; | sha256sum | tr -d &#x27;-&#x27;</span><br><span class="line">wx123456</span><br><span class="line">37acf78e288b1323fae2115749edcf696b6190d8c8ca1cbc66e39b10e22f2a86</span><br><span class="line"></span><br><span class="line"># 打开users.xml文件</span><br><span class="line">vim /u01/clickhouse/config/users.xml</span><br><span class="line"># 在&lt;/default&gt;下一行添加以下内容</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;password_sha256_hex&gt;37acf78e288b1323fae2115749edcf696b6190d8c8ca1cbc66e39b10e22f2a86&lt;/password_sha256_hex&gt;</span><br><span class="line">    &lt;networks incl=&quot;networks&quot; replace=&quot;replace&quot;&gt;</span><br><span class="line">            &lt;ip&gt;::/0&lt;/ip&gt;</span><br><span class="line">    &lt;/networks&gt;</span><br><span class="line">    &lt;profile&gt;default&lt;/profile&gt;</span><br><span class="line">    &lt;quota&gt;default&lt;/quota&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>部署 clickhouse-server</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker run -d \</span><br><span class="line">--name clickhouse-server \</span><br><span class="line">--privileged=true --restart=always \</span><br><span class="line">--ulimit nofile=262144:262144 \</span><br><span class="line">-p 8123:8123 \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-p 9009:9009 \</span><br><span class="line">-v /u01/clickhouse/data:/var/lib/clickhouse:rw \</span><br><span class="line">-v /u01/clickhouse/log:/var/log/clickhouse-server:rw \</span><br><span class="line">-v /u01/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml \</span><br><span class="line">-v /u01/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml \</span><br><span class="line">yandex/clickhouse-server:latest</span><br></pre></td></tr></table></figure>

<h2 id="Docker-安装-ElasticSearch-搜索引擎"><a href="#Docker-安装-ElasticSearch-搜索引擎" class="headerlink" title="Docker 安装 ElasticSearch 搜索引擎"></a>Docker 安装 ElasticSearch 搜索引擎</h2><blockquote>
<p>前提：请先安装好 Docker 容器服务（<a href="https://blog.kyire.site/2022/04/02/2f74bb89.html#%E5%AE%89%E8%A3%85-Docker-%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1">安装 Docker 容器服务</a>）</p>
</blockquote>
<ol>
<li>创建目录、配置文件并修改权限</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># 创建es 相关挂载目录</span><br><span class="line">mkdir -p /hd/docker/es/&#123;config,data,plugins&#125;</span><br><span class="line"># 创建文件</span><br><span class="line">vi /hd/docker/es/config/elasticsearch.yml</span><br><span class="line">http.host: 0.0.0.0</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">http.cors.allow-headers: Authorization</span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line"></span><br><span class="line"># 设置目录权限，否则会报错</span><br><span class="line">chmod +x ./config/elasticsearch.yml</span><br><span class="line"># 设置为目录 777 权限</span><br><span class="line">chmod -R 777 /hd/docker/es</span><br></pre></td></tr></table></figure>

<ol>
<li>拉取镜像</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker pull elasticsearch:7.17.4</span><br></pre></td></tr></table></figure>

<ol>
<li>启动容器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker run --name es --restart=always -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx1024m&quot; \</span><br><span class="line">-v /hd/docker/es/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /hd/docker/es/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /hd/docker/es/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.17.4</span><br></pre></td></tr></table></figure>

<ol>
<li>配置 es 访问密码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 进入容器内部</span><br><span class="line">docker exec -it es /bin/bash</span><br><span class="line"></span><br><span class="line"># 配置密码命令</span><br><span class="line">./bin/elasticsearch-setup-passwords interactive</span><br></pre></td></tr></table></figure>

<ol>
<li>访问网页 <a href="http://localhost:9200（账号密码：`elastic`/`123456`）">http://localhost:9200（账号密码：`elastic`/`123456`）</a></li>
</ol>
<h2 id="Docker-安装-Nginx-Proxy-Manager-代理管理平台"><a href="#Docker-安装-Nginx-Proxy-Manager-代理管理平台" class="headerlink" title="Docker 安装 Nginx Proxy Manager 代理管理平台"></a>Docker 安装 Nginx Proxy Manager 代理管理平台</h2><blockquote>
<p>前提：请先安装好 Docker 容器服务（<a href="https://blog.kyire.site/2022/04/02/2f74bb89.html#%E5%AE%89%E8%A3%85-Docker-%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1">安装 Docker 容器服务</a>）</p>
</blockquote>
<ol>
<li>创建 <code>docker-compose.yml</code></li>
</ol>
<p><strong>使用 network_mode: host 与宿主机共享网络</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YML</span><br><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: &#x27;chishin/nginx-proxy-manager-zh:latest&#x27;</span><br><span class="line">    restart: always</span><br><span class="line">    network_mode: host</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data:/data</span><br><span class="line">      - ./letsencrypt:/etc/letsencrypt</span><br></pre></td></tr></table></figure>

<ol>
<li>部署运行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>

<ol>
<li>登录管理平台</li>
</ol>
<p>容器运行成功后，使用浏览器访问 <code>81</code> 端口。</p>
<p><a href="http://127.0.0.1:81/">http://127.0.0.1:81</a></p>
<p>默认管理员信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVRASM</span><br><span class="line">Email:    admin@example.com</span><br><span class="line">Password: changeme</span><br></pre></td></tr></table></figure>

<p>登录之后系统会要求修改详细信息和密码</p>
<ol>
<li>快速升级</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line">docker-compose down</span><br><span class="line">docker-compose pull</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="Docker-安装-Redis-服务"><a href="#Docker-安装-Redis-服务" class="headerlink" title="Docker 安装 Redis 服务"></a>Docker 安装 Redis 服务</h2><ol>
<li>拉取 <code>Redis</code> 镜像</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"># 拉取最新版本</span><br><span class="line">docker pull redis</span><br><span class="line"># 指定版本号</span><br><span class="line">docker pull redis:5.0.8</span><br></pre></td></tr></table></figure>

<ol>
<li>启动 <code>Redis</code> 容器</li>
</ol>
<blockquote>
<p>建议使用配置文件启动，先从 Redis 官网下载标准配置文件（也可以自己准备一个）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line"># 创建配置文件存放目录</span><br><span class="line">mkdir -p /u01/software/redis/conf</span><br><span class="line">cd /u01/software/redis/conf</span><br><span class="line"></span><br><span class="line"># 下载 redis.conf 配置文件</span><br><span class="line">wget http://download.redis.io/redis-stable/redis.conf</span><br><span class="line"></span><br><span class="line"># 给配置文件授权</span><br><span class="line">chmod 777 redis.conf</span><br><span class="line"></span><br><span class="line"># 修改配置文件</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>安装手册</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器高级篇</title>
    <url>/2023/05/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Docker%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<h2 id="Docker-复杂应用安装"><a href="#Docker-复杂应用安装" class="headerlink" title="Docker 复杂应用安装"></a>Docker 复杂应用安装</h2><h3 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h3><p>主从搭建步骤：</p>
<ul>
<li><h4 id="新建主服务器容器实例-3307"><a href="#新建主服务器容器实例-3307" class="headerlink" title="新建主服务器容器实例 3307"></a><strong>新建主服务器容器实例 3307</strong></h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf 目录下新建 my.cnf</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">[root@88231 conf]# vim my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id=101</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin=mall-mysql-bin</span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed</span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days=7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>修改完配置后重启 master 实例</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AUTOIT</span><br><span class="line">[root@88231 conf]# docker restart mysql-master</span><br><span class="line">mysql-master</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>进入 mysql-master 容器</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ELIXIR</span><br><span class="line">[root@88231 conf]# docker exec -it mysql-master /bin/bash</span><br><span class="line">root@c84fa378812d:/# mysql -uroot -p</span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>master 容器实例内创建数据同步用户</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mysql&gt; CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="新建从服务器容器实例-3308"><a href="#新建从服务器容器实例-3308" class="headerlink" title="新建从服务器容器实例 3308"></a>新建从服务器容器实例 3308</h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf 目录下新建 my.cnf</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">[root@88231 conf]# vim my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id=102</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span><br><span class="line">log-bin=mall-mysql-slave1-bin</span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed</span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days=7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=mall-mysql-relay-bin</span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates=1</span><br><span class="line">## slave设置为只读（具有super权限的用户除外）</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>修改完配置后重启 slave 实例</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@88231 conf]# docker restart mysql-slave</span><br><span class="line">mysql-slave</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>在主数据库中查看主从同步状态</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File                  | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mall-mysql-bin.000001 |      617 |              | mysql            |                   |</span><br><span class="line">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>进入 mysql-slave 容器</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@88231 conf]# docker exec -it mysql-slave /bin/bash</span><br><span class="line">root@820edd47f326:/# mysql -uroot -p</span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>在从数据库中配置主从复制</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">change master to master_host=&#x27;宿主机ip&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br><span class="line"></span><br><span class="line">mysql&gt; change master to master_host=&#x27;192.168.88.231&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.15 sec)</span><br><span class="line"></span><br><span class="line">#主从复制命令参数说明</span><br><span class="line">master_host：主数据库的IP地址；</span><br><span class="line">master_port：主数据库的运行端口；</span><br><span class="line">master_user：在主数据库创建的用于同步数据的用户账号；</span><br><span class="line">master_password：在主数据库创建的用于同步数据的用户密码；</span><br><span class="line">master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</span><br><span class="line">master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</span><br><span class="line">master_connect_retry：连接失败重试的时间间隔，单位为秒。</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>在从数据库中查看主从同步状态</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">mysql&gt; show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State:</span><br><span class="line">                  Master_Host: 192.168.88.231</span><br><span class="line">                  Master_User: slave</span><br><span class="line">                  Master_Port: 3307</span><br><span class="line">                Connect_Retry: 30</span><br><span class="line">              Master_Log_File: mall-mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 617</span><br><span class="line">               Relay_Log_File: mall-mysql-relay-bin.000001</span><br><span class="line">                Relay_Log_Pos: 4</span><br><span class="line">        Relay_Master_Log_File: mall-mysql-bin.000001</span><br><span class="line">         # NO -- 还没开始</span><br><span class="line">             Slave_IO_Running: No</span><br><span class="line">            Slave_SQL_Running: No</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 617</span><br><span class="line">              Relay_Log_Space: 154</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File:</span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File:</span><br><span class="line">           Master_SSL_CA_Path:</span><br><span class="line">              Master_SSL_Cert:</span><br><span class="line">            Master_SSL_Cipher:</span><br><span class="line">               Master_SSL_Key:</span><br><span class="line">        Seconds_Behind_Master: NULL</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error:</span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error:</span><br><span class="line">  Replicate_Ignore_Server_Ids:</span><br><span class="line">             Master_Server_Id: 0</span><br><span class="line">                  Master_UUID:</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State:</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind:</span><br><span class="line">      Last_IO_Error_Timestamp:</span><br><span class="line">     Last_SQL_Error_Timestamp:</span><br><span class="line">               Master_SSL_Crl:</span><br><span class="line">           Master_SSL_Crlpath:</span><br><span class="line">           Retrieved_Gtid_Set:</span><br><span class="line">            Executed_Gtid_Set:</span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB:</span><br><span class="line">                 Channel_Name:</span><br><span class="line">           Master_TLS_Version:</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>在从数据库中开启主从同步</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>查看从数据库状态发现已经同步</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">mysql&gt; show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.88.231</span><br><span class="line">                  Master_User: slave</span><br><span class="line">                  Master_Port: 3307</span><br><span class="line">                Connect_Retry: 30</span><br><span class="line">              Master_Log_File: mall-mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 617</span><br><span class="line">               Relay_Log_File: mall-mysql-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 325</span><br><span class="line">        Relay_Master_Log_File: mall-mysql-bin.000001</span><br><span class="line">           # Yes -- 已开始</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 617</span><br><span class="line">              Relay_Log_Space: 537</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File:</span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File:</span><br><span class="line">           Master_SSL_CA_Path:</span><br><span class="line">              Master_SSL_Cert:</span><br><span class="line">            Master_SSL_Cipher:</span><br><span class="line">               Master_SSL_Key:</span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error:</span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error:</span><br><span class="line">  Replicate_Ignore_Server_Ids:</span><br><span class="line">             Master_Server_Id: 101</span><br><span class="line">                  Master_UUID: 25cb5d93-e4df-11ec-86da-0242ac110003</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind:</span><br><span class="line">      Last_IO_Error_Timestamp:</span><br><span class="line">     Last_SQL_Error_Timestamp:</span><br><span class="line">               Master_SSL_Crl:</span><br><span class="line">           Master_SSL_Crlpath:</span><br><span class="line">           Retrieved_Gtid_Set:</span><br><span class="line">            Executed_Gtid_Set:</span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB:</span><br><span class="line">                 Channel_Name:</span><br><span class="line">           Master_TLS_Version:</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>主从复制测试</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASCIIDOC</span><br><span class="line">- 主机新建库-使用库-新建表-插入数据，ok</span><br><span class="line">- 从机使用库-查看记录，ok</span><br></pre></td></tr></table></figure>

<h3 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h3><h4 id="搭建-Redis-集群"><a href="#搭建-Redis-集群" class="headerlink" title="搭建 Redis 集群"></a>搭建 Redis 集群</h4><blockquote>
<p>3 主 3 从 redis 集群扩缩容配置案例架构说明</p>
<p><a href="https://www.processon.com/view/link/629e20255653bb03f2cc0a14">https://www.processon.com/view/link/629e20255653bb03f2cc0a14</a></p>
</blockquote>
<ol>
<li><strong>新建 6 个 docker 容器 redis 实例</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker run -d --name redis-node-1 --net host --privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged=true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged=true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged=true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</span><br></pre></td></tr></table></figure>

<p>如果运行成功，效果如下：<br><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606234533.png" alt="image-20220606234533562"></p>
<blockquote>
<p>命令分步解释：</p>
<ul>
<li>docker run：创建并运行 docker 容器实例</li>
<li>–name redis-node-6：容器名字</li>
<li>–net host：使用宿主机的 IP 和端口，默认</li>
<li>–privileged&#x3D;true：获取宿主机 root 用户权限</li>
<li>-v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-6:&#x2F;data：容器卷，宿主机地址:docker 内部地址</li>
<li>redis:6.0.8：redis 镜像和版本号</li>
<li>–cluster-enabled yes：开启 redis 集群</li>
<li>–appendonly yes：开启持久化</li>
<li>–port 6386：redis 端口号</li>
</ul>
</blockquote>
<ol>
<li><strong>进入容器 redis-node-1 并为 6 台机器构建集群关系</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 进入容器</span><br><span class="line">[root@88231 ~]# docker exec -it redis-node-1 /bin/bash</span><br><span class="line"></span><br><span class="line"># 构建主从关系</span><br><span class="line"># 注意，进入docker容器后才能执行一下命令，且注意自己的真实IP地址</span><br><span class="line">redis-cli --cluster create 192.168.88.231:6381 192.168.88.231:6382 192.168.88.231:6383 192.168.88.231:6384 192.168.88.231:6385 192.168.88.231:6386 --cluster-replicas 1</span><br><span class="line"># --cluster-replicas 1 表示为每个master创建一个slave节点</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606235150.png" alt="image-20220606235150386"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606235242.png" alt="image-20220606235242475"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220606235333.png" alt="image-20220606235332969"></p>
<p>一切 OK 的话，3 主 3 从搞定</p>
<ol>
<li><strong>链接进入 6381 作为切入点，查看集群状态</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACCESSLOG</span><br><span class="line">root@88231:/data# redis-cli -p 6381</span><br><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">127.0.0.1:6381&gt; cluster info</span><br><span class="line">127.0.0.1:6381&gt; cluster nodes</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220607000338.png" alt="image-20220607000338016"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220607000524.png" alt="image-20220607000524306"></p>
<h4 id="主从容错切换迁移"><a href="#主从容错切换迁移" class="headerlink" title="主从容错切换迁移"></a>主从容错切换迁移</h4><h5 id="数据读写存储"><a href="#数据读写存储" class="headerlink" title="数据读写存储"></a>数据读写存储</h5><ol>
<li>启动 6 个 redis 构成的集群并通过 exec 进入</li>
<li>对 6381 新增两个 key</li>
<li>防止路由失效加参数 -c 并新增两个 key</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609222235.png" alt="image-20220609222228049"><br><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609222420.png" alt="image-20220609222420357"></p>
<ol>
<li>查看集群信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis-cli --cluster check 192.168.88.231:6381</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609222613.png" alt="image-20220609222613143"></p>
<h5 id="容错切换迁移"><a href="#容错切换迁移" class="headerlink" title="容错切换迁移"></a>容错切换迁移</h5><ol>
<li>主 6381 和从机切换，先停止主机 6381</li>
<li>6381 主机停了，对应的真实从机上位</li>
<li>6381 作为 1 号主机分配的从机以实际情况为准，具体是几号机器就是几号</li>
<li>再次查看集群信息</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609223136.png" alt="image-20220609223136321"></p>
<blockquote>
<p>&#x3D;&#x3D;6381 宕机了，6385 上位成了新的 master&#x3D;&#x3D;</p>
<p>备注：本次操作 6381 为主节点，对应的从节点是 6385，对应关系是随机的，每次操作以实际情况为准</p>
</blockquote>
<ol>
<li>启动 6381 节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker start redis-node-1</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609224043.png" alt="image-20220609224042839"></p>
<ol>
<li>再停 6385 节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker stop redis-node-5</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609224750.png" alt="image-20220609224750744"></p>
<ol>
<li>再启 6385 节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker start redis-node-5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;发现主从节点又恢复之前的状态了&#x3D;&#x3D;</p>
</blockquote>
<ol>
<li>查看集群状态</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMALI</span><br><span class="line">redis-cli --cluster check 自己IP:6381</span><br><span class="line"></span><br><span class="line">可以看到主节点分配的</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609230337.png" alt="image-20220609230337692"></p>
<h5 id="主从扩容案例"><a href="#主从扩容案例" class="headerlink" title="主从扩容案例"></a>主从扩容案例</h5><ol>
<li>新建 6387、6388 两个节点+新建后启动+查看是否是 8 节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker run -d --name redis-node-7 --net host --privileged=true -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-8 --net host --privileged=true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</span><br><span class="line"></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<ol>
<li>进入 6387 容器实例内部</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">docker exec -it redis-node-7 /bin/bash</span><br></pre></td></tr></table></figure>

<ol>
<li>将新增的 6387 节点（空槽号）作为 master 节点加入集群</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMALI</span><br><span class="line">redis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381</span><br><span class="line">redis-cli --cluster add-node 192.168.88.231:6387 192.168.88.231:6381</span><br><span class="line">6387 就是将要作为master新增节点</span><br><span class="line">6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609231034.png" alt="image-20220609231034192"></p>
<ol>
<li>检查集群情况第 1 次</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMALI</span><br><span class="line">redis-cli --cluster check 真实ip地址:6381</span><br><span class="line"></span><br><span class="line">redis-cli --cluster check 192.168.88.231:6381</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609231423.png" alt="image-20220609231423755"></p>
<ol>
<li>重新分派槽号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STATA</span><br><span class="line">重新分派槽号</span><br><span class="line"></span><br><span class="line">命令:redis-cli --cluster reshard IP地址:端口号</span><br><span class="line"></span><br><span class="line">redis-cli --cluster reshard 192.168.88.231:6381</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609232741.png" alt="image-20220609232741435"></p>
<ol>
<li>检查集群情况第 2 次</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis-cli --cluster check 真实ip地址:6381</span><br><span class="line"></span><br><span class="line">redis-cli --cluster check 192.168.88.231:6381</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609233201.png" alt="image-20220609233201196"></p>
<blockquote>
<p>&#x3D;&#x3D;槽号分派说明&#x3D;&#x3D;</p>
<p>为什么 6387 是 3 个新的区间，以前的还是连续？</p>
<p>重新分配成本太高，所以前 3 家各自匀出来一部分，从 6381&#x2F;6382&#x2F;6383 三个旧节点分别匀出 1364 个坑位给新节点 6387</p>
</blockquote>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609233346.png" alt="image-20220609233346240"></p>
<ol>
<li>为主节点 6387 分配从节点 6388</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMALI</span><br><span class="line">命令：redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</span><br><span class="line"></span><br><span class="line">redis-cli --cluster add-node 192.168.88.231:6388 192.168.88.231:6387 --cluster-slave --cluster-master-id 7206137ce4e66c0464fa0fa00472202ce5b16792</span><br><span class="line">-------这个是6387的编号，按照自己实际情况</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609233720.png" alt="image-20220609233720722"></p>
<ol>
<li>检查集群第 3 次</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMALI</span><br><span class="line">redis-cli --cluster check 192.168.88.231:6382</span><br><span class="line"></span><br><span class="line">4 主 4 从</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220609233902.png" alt="image-20220609233902550"></p>
<h5 id="主从缩容案例"><a href="#主从缩容案例" class="headerlink" title="主从缩容案例"></a>主从缩容案例</h5><blockquote>
<p>目的：6387 和 6388 下线</p>
</blockquote>
<ol>
<li>检查集群情况 - 获得 6388 的节点 ID</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis-cli --cluster check 192.168.88.231:6382</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220610223609.png" alt="image-20220610223609176"></p>
<ol>
<li>将 6388 删除 从集群中将 4 号从节点 6388 删除</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">命令：redis-cli --cluster del-node ip:从机端口 从机6388节点ID</span><br><span class="line"></span><br><span class="line">redis-cli --cluster del-node 192.168.88.231:6388 1fedf6a6f9acfbdba6951a532cd2d68e4546898e</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220610223709.png" alt="image-20220610223709085"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis-cli --cluster check 192.168.88.231:6382</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;检查一下发现，6388 被删除了，只剩下七台机器了。&#x3D;&#x3D;</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220610223901.png" alt="image-20220610223900954"></p>
<ol>
<li>将 6387 的槽号清空，重新分配，本例将清出来的槽号都给 6381</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis-cli --cluster reshard 192.168.88.231:6381</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220610224116.png" alt="image-20220610224116496"></p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220610224735.png" alt="image-20220610224657149"></p>
<blockquote>
<p>将 6387 节点的槽号都分配给 6381</p>
</blockquote>
<ol>
<li>检查集群情况</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis-cli --cluster check 192.168.88.231 6382</span><br><span class="line"></span><br><span class="line">4096 个槽位都指给 6381，它变成了 8192 个槽位，相当于全部都给 6381了</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220610225027.png" alt="image-20220610225027291"></p>
<ol>
<li>删除 6387 节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">命令：redis-cli --cluster del-node ip:端口 6387节点ID</span><br><span class="line"></span><br><span class="line">redis-cli --cluster del-node 192.168.88.231:6387 7206137ce4e66c0464fa0fa00472202ce5b16792</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220610225145.png" alt="image-20220610225144956"></p>
<ol>
<li>再次检查集群情况</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis-cli --cluster check 192.168.88.231 6382</span><br><span class="line"></span><br><span class="line">恢复之前的 3 主 3 从，缩容成功！</span><br></pre></td></tr></table></figure>

<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220610225344.png" alt="image-20220610225344237"></p>
<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="Dockerfile-介绍"><a href="#Dockerfile-介绍" class="headerlink" title="Dockerfile 介绍"></a>Dockerfile 介绍</h3><p><code>Dockerfile</code> 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>
<blockquote>
<p>官网：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
</blockquote>
<p>构建步骤：</p>
<ol>
<li>编写一个 <code>Dockerfile</code> 文件</li>
<li><code>docker bulid</code> 构建为一个镜像</li>
<li><code>docker run</code> 运行镜像</li>
<li><code>docker push</code> 发布镜像（DockerHub. 阿里云镜像仓库）</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220611202748.png" alt="image-20220611202748238"></p>
<h3 id="Dockerfile-构建过程"><a href="#Dockerfile-构建过程" class="headerlink" title="Dockerfile 构建过程"></a>Dockerfile 构建过程</h3><h4 id="Dockerfile-基础知识"><a href="#Dockerfile-基础知识" class="headerlink" title="Dockerfile 基础知识"></a>Dockerfile 基础知识</h4><ol>
<li>每个保留关键字（指令）都&#x3D;&#x3D;必须是大写字母&#x3D;&#x3D;且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li><code>#</code> 表示注释</li>
<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>
</ol>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211230224706.png" alt="image-20211230224659329"></p>
<h4 id="Docker-执行-Dockerfile-的大致流程"><a href="#Docker-执行-Dockerfile-的大致流程" class="headerlink" title="Docker 执行 Dockerfile 的大致流程"></a>Docker 执行 Dockerfile 的大致流程</h4><ol>
<li>docker 从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出修改</li>
<li>docker 再基于刚提交的镜像运行一个新容器</li>
<li>执行 Dockerfile 中的下一条指令知道所有指令都执行完成</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从应用软件的角度看，<code>Dockerfile</code>、<code>Docker镜像</code>与<code>Docker容器</code>分别代表软件的三个不同阶段：</p>
<ul>
<li><code>Dockerfile</code>是软件的原材料</li>
<li><code>Docker镜像</code>是软件的交付品</li>
<li><code>Docker容器</code>则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li>
</ul>
<p>&#x3D;&#x3D;Dockerfile 面向开发，Docker 镜像成为交付标准，Docker 容器则涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石&#x3D;&#x3D;</p>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220611204149.png" alt="image-20220611204149366"></p>
<ol>
<li>Dockerfile，需要定义一个 Dockerfile，Dockerfile 定义了进程需要的一切东西。Dockerfile 涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace 的权限控制)等等;</li>
<li>Docker 镜像，在用 Dockerfile 定义一个文件之后，docker build 时会产生一个 Docker 镜像，当运行 Docker 镜像时会真正开始提供服务;</li>
<li>Docker 容器，容器是直接提供服务的。</li>
</ol>
<h3 id="DockerFile-的保留字指令"><a href="#DockerFile-的保留字指令" class="headerlink" title="DockerFile 的保留字指令"></a>DockerFile 的保留字指令</h3><ul>
<li><p><code>FROM</code>：基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 FROM</p>
</li>
<li><p><code>MAINTAINER</code>：镜像维护者的姓名和邮箱地址</p>
</li>
<li><p><code>RUN</code>：容器构建时需要运行的命令，包含两种格式：</p>
<ul>
<li>shell 格式：</li>
</ul>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220611204952.png" alt="image-20220611204952312"></p>
<ul>
<li>exec 格式：</li>
</ul>
<p><img src="https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220611205003.png" alt="image-20220611205003786"></p>
<ul>
<li><code>RUN</code> 是在 <code>docker build</code> 时运行</li>
</ul>
</li>
<li><p><code>EXPOSE</code>：当前容器对外暴露出的端口</p>
</li>
<li><p><code>WORKDIR</code>：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>
</li>
<li><p><code>USER</code>：指定该镜像以什么样的用户去执行，如果都不指定，默认是 root</p>
</li>
<li><p><code>ENV</code>：用来在构建镜像过程中设置环境变量</p>
<ul>
<li><p>`&#96;&#96;</p>
<p>ENV MY_PATH &#x2F;usr&#x2F;mytest</p>
<p>这个环境变量可以在后续的任何 RUN 指令中使用，这就如同在命令前面指定了环境变量前缀一样；</p>
<p>也可以在其它指令中直接使用这些环境变量，比如：WORKDIR $MY_PATH</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOCKERFILE</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ADD</code>：将宿主机目录下的文件拷贝进镜像且会自动处理 URL 和解压 tar 压缩包</p>
</li>
<li><p><code>COPY</code>：类似 ADD，拷贝文件和目录到镜像中</p>
<ul>
<li><pre><code class="dockerfile"># 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置

COPY src dest
COPY [&quot;src&quot;, &quot;dest&quot;]

# &lt;src源路径&gt;：源文件或者源目录
# &lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `VOLUME`：容器数据卷，用于数据保存和持久化工作</span><br><span class="line"></span><br><span class="line">- `CMD`：指定容器启动后的要干的事情</span><br><span class="line"></span><br><span class="line">  - ![image-20220611210408046](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220611210408.png)</span><br><span class="line"></span><br><span class="line">  - **注意：Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换**</span><br><span class="line"></span><br><span class="line">  - 它和前面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RUN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    命令的区别：</span><br><span class="line"></span><br><span class="line">    - `CMD` 是在 `docker run` 时运行</span><br><span class="line">    - `RUN` 是在 `docker build` 时运行</span><br><span class="line"></span><br><span class="line">- `ENTRYPOINT`：也是用来指定一个容器启动时要运行的命令</span><br><span class="line"></span><br><span class="line">  - 类似于 CMD 指令，**但是 ENTRYPOINT 不会被 docker run 后面的命令覆盖**， 而且这些命令行参数**会被当作参数送给 ENTRYPOINT 指令指定的程序**</span><br><span class="line">  - `ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;...]`</span><br><span class="line">  - ENTRYPOINT 可以和 CMD 一起用，一般是**变参**才会使用 CMD，这里的 CMD 等于是在给 ENTRYPOINT 传参。当指定了 ENTRYPOINT 后，CMD 的含义就发生了变化，不再是直接运行其命令而是将 CMD 的内容作为参数传递给 ENTRYPOINT 指令，他两个组合会变成 `&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;`</span><br><span class="line">  - **优点**：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数</span><br><span class="line">  - **注意**：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效</span><br><span class="line"></span><br><span class="line">- 小总结</span><br><span class="line"></span><br><span class="line">  - ![image-20220618230538863](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220618230538.png)</span><br><span class="line"></span><br><span class="line">### 实战案例</span><br><span class="line"></span><br><span class="line">自定义镜像 ==&gt; `mycentosjava8`</span><br><span class="line"></span><br><span class="line">**要求：**</span><br><span class="line"></span><br><span class="line">- Centos7 镜像具备 vim+ifconfig+jdk8</span><br><span class="line">- 准备 jdk8 的安装包（`jdk-8u251-linux-x64.tar.gz`）</span><br><span class="line"></span><br><span class="line">1. **准备编写 Dockerfile 文件**</span><br><span class="line"></span><br><span class="line">在 `/home` 目录下建一个 `myfile` 文件夹，并将 `jdk8` 的安装包放进去：</span><br><span class="line"></span><br><span class="line">![image-20220619202508648](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220619202515.png)</span><br><span class="line"></span><br><span class="line">`Dockerfile` 文件内容如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>DOCKERFILE</p>
<p>FROM centos:centos7<br>MAINTAINER Kyire6&lt;kyire666.outlook.com&gt;</p>
<p>ENV MYPATH &#x2F;usr&#x2F;local<br>WORKDIR $MYPATH</p>
<p>#安装vim编辑器<br>RUN yum -y install vim<br>#安装ifconfig命令查看网络IP<br>RUN yum -y install net-tools<br>#安装java8及lib库<br>RUN yum -y install glibc.i686<br>RUN mkdir &#x2F;usr&#x2F;local&#x2F;java<br>#ADD 是相对路径jar,把jdk-8u251-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置<br>ADD jdk-8u251-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;<br>#配置java环境变量<br>ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_251<br>ENV JRE_HOME $JAVA_HOME&#x2F;jre<br>ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATH<br>ENV PATH $JAVA_HOME&#x2F;bin:$PATH</p>
<p>EXPOSE 80</p>
<p>CMD echo $MYPATH<br>CMD echo “success————–ok”<br>CMD &#x2F;bin&#x2F;bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. **执行构建命令**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker build -t 新镜像名:TAG .</p>
<h1 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h1><p>docker build -t centosjava8:1.0 .</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; **注意：命令要在 `Dockerfile` 的同级目录下执行，不要忘了命令结尾的 `.`**</span><br><span class="line"></span><br><span class="line">![image-20220619203258616](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220619203258.png)</span><br><span class="line"></span><br><span class="line">![image-20220619204718396](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220619204718.png)</span><br><span class="line"></span><br><span class="line">1. **运行容器**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -it centosjava8:1.0 &#x2F;bin&#x2F;bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220619212100997](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220619212101.png)</span><br><span class="line"></span><br><span class="line">### 虚悬镜像</span><br><span class="line"></span><br><span class="line">虚悬镜像就是仓库名、标签都是 `&lt;none&gt;` 的镜像，也称为 `dangling image`</span><br><span class="line"></span><br><span class="line">**用 Dockerfile 生成一个**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DOCKERFILE</p>
<h1 id="编写-Dockerfile-文件"><a href="#编写-Dockerfile-文件" class="headerlink" title="编写 Dockerfile 文件"></a>编写 Dockerfile 文件</h1><p>vim Dockerfile<br>from ubuntu<br>CMD echo ‘action is success’</p>
<h1 id="build-镜像"><a href="#build-镜像" class="headerlink" title="build 镜像"></a>build 镜像</h1><p>docker build .</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220619214708171](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220619214708.png)</span><br><span class="line"></span><br><span class="line">**查看虚悬镜像**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker images -f dangling&#x3D;true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220619214819128](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220619214819.png)</span><br><span class="line"></span><br><span class="line">**删除所有虚悬镜像**</span><br><span class="line"></span><br><span class="line">虚悬镜像已经失去存在价值，可以删除</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker image prune</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220619215102621](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220619215102.png)</span><br><span class="line"></span><br><span class="line">### 发布自己的镜像</span><br><span class="line"></span><br><span class="line">&gt; DockerHub</span><br><span class="line"></span><br><span class="line">1. 地址 https://hub.docker.com/ 注册自己的账号！</span><br><span class="line"></span><br><span class="line">2. 确保这个账号可以登录</span><br><span class="line"></span><br><span class="line">3. 在服务器上提交自己的镜像</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   SHELL</p>
<p>   [root@ouwen ~]# docker login –help</p>
<p>   Usage:  docker login [OPTIONS] [SERVER]</p>
<p>   Log in to a Docker registry.<br>   If no server is specified, the default is defined by the daemon.</p>
<p>   Options:<br>     -p, –password string   Password<br>         –password-stdin    Take the password from stdin<br>     -u, –username string   Username<br>   [root@ouwen ~]# docker login -u ouwen666<br>   Password:<br>   WARNING! Your password will be stored unencrypted in &#x2F;root&#x2F;.docker&#x2F;config.json.<br>   Configure a credential helper to remove this warning. See<br>   <a href="https://docs.docker.com/engine/reference/commandline/login/#credentials-store">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</a></p>
<p>   Login Succeeded<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 使用 `docker login` 登录之后就可以提交镜像了</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   SHELL</p>
<h1 id="1-使用-docker-tag-命令修改镜像版本"><a href="#1-使用-docker-tag-命令修改镜像版本" class="headerlink" title="1. 使用 docker tag 命令修改镜像版本"></a>1. 使用 docker tag 命令修改镜像版本</h1><p>   [root@ouwen ~]# docker tag 352abc3918b1 ouwen666&#x2F;tomcat:1.0</p>
<h1 id="2-使用-docker-push-命令提交镜像到-DockerHub"><a href="#2-使用-docker-push-命令提交镜像到-DockerHub" class="headerlink" title="2. 使用 docker push 命令提交镜像到 DockerHub"></a>2. 使用 docker push 命令提交镜像到 DockerHub</h1><p>   [root@ouwen ~]# docker push ouwen666&#x2F;tomcat:1.0<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ![image-20220103135111272](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220103135111.png)</span><br><span class="line"></span><br><span class="line">   &gt; 发现：提交的时候也是按照镜像的层级来的！</span><br><span class="line"></span><br><span class="line">&gt; 阿里云镜像</span><br><span class="line"></span><br><span class="line">1. 登录阿里云</span><br><span class="line"></span><br><span class="line">2. 找到容器镜像服务</span><br><span class="line"></span><br><span class="line">3. 创建镜像仓库</span><br><span class="line"></span><br><span class="line">   ![image-20220103140835560](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220103140835.png)</span><br><span class="line"></span><br><span class="line">4. 浏览仓库信息</span><br><span class="line"></span><br><span class="line">   ![image-20220103140926596](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220103140926.png)</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">![image-20220103142038290](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220103142038.png)</span><br><span class="line"></span><br><span class="line">## Docker 网络</span><br><span class="line"></span><br><span class="line">### `docker0` 网卡</span><br><span class="line"></span><br><span class="line">docker 服务启动后，会产生一个名为 `docker0` 的虚拟网桥，使用 `ip addr` 查看本机 ip</span><br><span class="line"></span><br><span class="line">![image-20220103235821684](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220104001129.png)</span><br><span class="line"></span><br><span class="line">### docker 网络常用命令</span><br><span class="line"></span><br><span class="line">#### All 命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>BASH<br>docker network –help</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220625214854077](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220625214901.png)</span><br><span class="line"></span><br><span class="line">#### 查看网络</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker network ls</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220625215035376](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220625215035.png)</span><br><span class="line"></span><br><span class="line">#### 查看网络源数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker network inspect xxx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220626002156711](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626002156.png)</span><br><span class="line"></span><br><span class="line">#### 创建网络</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker network create xxx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 删除网络</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker network rm xxx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220626002407749](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626002407.png)</span><br><span class="line"></span><br><span class="line">&gt; **docker 网络能干嘛？**</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 容器间的互联和通信以及端口映射</span><br><span class="line">&gt; - 容器 IP 变动时可以通过服务名直接进行网络通信，进而不受到影响</span><br><span class="line"></span><br><span class="line">### 网络模式</span><br><span class="line"></span><br><span class="line">![image-20220626002547570](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626002547.png)</span><br><span class="line"></span><br><span class="line">- bridge 模式：使用 –network bridge 指定，默认使用 docker0</span><br><span class="line">- host 模式：使用 –network host 指定</span><br><span class="line">- none 模式：使用 –network none 指定</span><br><span class="line">- container 模式：使用 –network container:NAME 或者容器 ID 指定</span><br><span class="line"></span><br><span class="line">**容器实例内默认网络 IP 生产规则**</span><br><span class="line"></span><br><span class="line">1. 先启动两个 Ubuntu 容器实例</span><br><span class="line"></span><br><span class="line">![image-20220626002940194](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626002940.png)</span><br><span class="line"></span><br><span class="line">1. `docker inspect 容器 ID or 容器名字`</span><br><span class="line"></span><br><span class="line">![image-20220626003252589](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626003252.png)</span><br><span class="line"></span><br><span class="line">1. 关闭 u2 实例，新建 u3，查看 IP 变化</span><br><span class="line"></span><br><span class="line">![image-20220626003453087](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626003453.png)</span><br><span class="line"></span><br><span class="line">&gt; 结论：</span><br><span class="line">&gt;</span><br><span class="line">&gt; **docker 容器内部的 IP 是有可能会发生变化的**</span><br><span class="line"></span><br><span class="line">#### bridge</span><br><span class="line"></span><br><span class="line">Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为 docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GRADLE</p>
<h1 id="查看-bridge-网络的详细信息，并通过-grep-获取名称项"><a href="#查看-bridge-网络的详细信息，并通过-grep-获取名称项" class="headerlink" title="查看 bridge 网络的详细信息，并通过 grep 获取名称项"></a>查看 bridge 网络的详细信息，并通过 grep 获取名称项</h1><p>docker network inspect bridge | grep name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220626003931893](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626003931.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1C<br>ifconfig | grep docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220626004014292](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626004014.png)</span><br><span class="line"></span><br><span class="line">&gt; **说明：**</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. Docker 使用 Linux 桥接，在宿主机虚拟一个 Docker 容器网桥(docker0)，Docker 启动一个容器时会根据 Docker 网桥的网段分配给容器一个 IP 地址，称为 Container-IP，同时 Docker 网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信</span><br><span class="line">&gt; 2. docker run 的时候，没有指定 network 的话默认使用的网桥模式就是 bridge，使用的就是 docker0。在宿主机 ifconfig,就可以看到 docker0 和自己 create 的 network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo 代表 127.0.0.1，即 localhost，inet addr 用来表示网卡的 IP 地址</span><br><span class="line">&gt; 3. 网桥 docker0 创建一对对等虚拟设备接口一个叫 veth，另一个叫 eth0，成对匹配</span><br><span class="line">&gt;    1. 整个宿主机的网桥模式都是 docker0，类似一个交换机有一堆接口，每个接口叫 veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫 veth pair）</span><br><span class="line">&gt;    2. 每个容器实例内部也有一块网卡，每个接口叫 eth0</span><br><span class="line">&gt;    3. docker0 上面的每个 veth 匹配某个容器实例内部的 eth0，两两配对，一一匹配</span><br><span class="line">&gt;</span><br><span class="line">&gt; **通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的 ip，此时两个容器的网络是互通的。**</span><br><span class="line"></span><br><span class="line">![image-20220626004158705](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626004158.png)</span><br><span class="line">**两两匹配验证**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -d -p 8081:8080   –name tomcat81 billygoo&#x2F;tomcat8-jdk8</p>
<p>docker run -d -p 8082:8080   –name tomcat82 billygoo&#x2F;tomcat8-jdk8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220626004536998](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626004537.png)</span><br><span class="line"></span><br><span class="line">![image-20220626004743381](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626004743.png)</span><br><span class="line"></span><br><span class="line">#### host</span><br><span class="line"></span><br><span class="line">直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行 NAT 转换。</span><br><span class="line"></span><br><span class="line">&gt; **说明：**</span><br><span class="line">&gt;</span><br><span class="line">&gt; 容器将不会获得一个独立的 Network Namespace， 而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的 IP 和端口。</span><br><span class="line"></span><br><span class="line">![image-20220626004852511](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626004852.png)</span><br><span class="line"></span><br><span class="line">**验证**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -d -p 8083:8080 –network host –name tomcat83 billygoo&#x2F;tomcat8-jdk8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220626005212574](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626005212.png)</span><br><span class="line">**问题：**</span><br><span class="line"></span><br><span class="line">docker 容器启动时出现了警告</span><br><span class="line"></span><br><span class="line">**原因：**</span><br><span class="line"></span><br><span class="line">docker 启动时指定 –network=host 或 -net=host，如果还指定了 -p 映射端口，那这个时候就会有此警告，并且通过-p 设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。</span><br><span class="line"></span><br><span class="line">**解决:**</span><br><span class="line"></span><br><span class="line">解决的办法就是使用 docker 的其他网络模式，例如 –network=bridge，这样就可以解决问题，或者直接无视…</span><br><span class="line"></span><br><span class="line">**正确做法：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -d –network host –name tomcat83 billygoo&#x2F;tomcat8-jdk8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这样就不会出现之前的警告了，查看容器实例内部：</span><br><span class="line"></span><br><span class="line">![image-20220626005512017](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626005512.png)</span><br><span class="line"></span><br><span class="line">&gt; 没有设置-p 的端口映射了，如何访问启动的 tomcat83？</span><br><span class="line">&gt;</span><br><span class="line">&gt; http://宿主机 IP:8080/</span><br><span class="line">&gt;</span><br><span class="line">&gt; **在 CentOS 里面用默认的火狐浏览器访问容器内的 tomcat83 看到访问成功，因为此时容器的 IP 借用主机的，所以容器共享宿主机网络 IP，这样的好处是外部主机与容器可以直接通信。**</span><br><span class="line"></span><br><span class="line">#### none</span><br><span class="line"></span><br><span class="line">在 none 模式下，并不为 Docker 容器进行任何网络配置。 也就是说，这个 Docker 容器没有网卡、IP、路由等信息，只有一个 lo，需要我们自己为 Docker 容器添加网卡、配置 IP 等。禁用网络功能，只有 lo 标识(就是 127.0.0.1 表示本地回环)</span><br><span class="line"></span><br><span class="line">**验证**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -d -p 8084:8080 –network none –name tomcat84 billygoo&#x2F;tomcat8-jdk8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">进入容器内部查看</span><br><span class="line"></span><br><span class="line">![image-20220626005846474](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626005846.png)</span><br><span class="line">在容器外部查看</span><br><span class="line"></span><br><span class="line">![image-20220626005935898](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626005936.png)</span><br><span class="line"></span><br><span class="line">#### container</span><br><span class="line"></span><br><span class="line">新建的容器和已经存在的一个容器共享一个网络 IP 配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</span><br><span class="line"></span><br><span class="line">![image-20220626010017092](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626010017.png)</span><br><span class="line">**验证**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -d -p 8085:8080 –name tomcat85 billygoo&#x2F;tomcat8-jdk8</p>
<p>docker run -d -p 8086:8080 –network container:tomcat85 –name tomcat86 billygoo&#x2F;tomcat8-jdk8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">![image-20220626010148299](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626010148.png)</span><br><span class="line"></span><br><span class="line">相当于 tomcat86 和 tomcat85 公用同一个 ip 同一个端口，导致端口冲突！</span><br><span class="line"></span><br><span class="line">**换一个镜像进行验证**</span><br><span class="line"></span><br><span class="line">&gt; Alpine 操作系统是一个面向安全的轻型 Linux 发行版</span><br><span class="line">&gt;</span><br><span class="line">&gt; Alpine Linux 是一款独立的、非商业的通用 Linux 发行版，专为追求安全性、简单性和资源效率的用户而设计。 可能很多人没听说过这个 Linux 发行版本，但是经常用 Docker 的朋友可能都用过，因为他小，简单，安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到 6M 的大小，所以特别适合容器打包。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -it –name alpine1  alpine &#x2F;bin&#x2F;sh</p>
<p>docker run -it –network container:alpine1 –name alpine2  alpine &#x2F;bin&#x2F;sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220626010511330](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626010511.png)</span><br><span class="line"></span><br><span class="line">假如此时关闭 alpine1，再看看 alpin2</span><br><span class="line"></span><br><span class="line">![image-20220626010625716](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626010625.png)</span><br><span class="line"></span><br><span class="line">发现 `107: eth0@if108` 已经消失</span><br><span class="line"></span><br><span class="line">![image-20220626010751877](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626010751.png)</span><br><span class="line"></span><br><span class="line">### 自定义网络</span><br><span class="line"></span><br><span class="line">#### 过时的 link</span><br><span class="line"></span><br><span class="line">![image-20220626010828576](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626010828.png)</span><br><span class="line"></span><br><span class="line">#### 使用自定义网络的好处</span><br><span class="line"></span><br><span class="line">**before**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -d -p 8081:8080   –name tomcat81 billygoo&#x2F;tomcat8-jdk8<br>docker run -d -p 8082:8080   –name tomcat82 billygoo&#x2F;tomcat8-jdk8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">启动成功使用 docker exec 进入到容器内部</span><br><span class="line"></span><br><span class="line">**按照 IP 地址 ping 是 OK 的**</span><br><span class="line"></span><br><span class="line">![image-20220626011951406](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626011951.png)</span><br><span class="line"></span><br><span class="line">但是无法按照服务名 ping</span><br><span class="line"></span><br><span class="line">![image-20220626012135798](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626012135.png)</span><br><span class="line"></span><br><span class="line">**after**</span><br><span class="line"></span><br><span class="line">自定义桥接网络，自定义网络默认使用的就是桥接网络 – bridge</span><br><span class="line"></span><br><span class="line">1. 新建自定义网络</span><br><span class="line"></span><br><span class="line">![image-20220626012308361](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626012308.png)</span><br><span class="line"></span><br><span class="line">1. 新建容器并加入上一步新建的自定义网络</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker run -d -p 8081:8080 –network my_network  –name tomcat81 billygoo&#x2F;tomcat8-jdk8</p>
<p>docker run -d -p 8082:8080 –network my_network  –name tomcat82 billygoo&#x2F;tomcat8-jdk8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 互相 ping 测试</span><br><span class="line"></span><br><span class="line">![image-20220626012536459](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626012536.png)</span><br><span class="line"></span><br><span class="line">&gt; **结论**</span><br><span class="line">&gt;</span><br><span class="line">&gt; **\*自定义网络本身就维护好了主机名和 ip 的对应关系（ip 和域名都能通）\***</span><br><span class="line"></span><br><span class="line">## Docker 平台架构图解</span><br><span class="line"></span><br><span class="line">### 整体说明</span><br><span class="line"></span><br><span class="line">从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</span><br><span class="line"></span><br><span class="line">Docker 运行的基本流程为：</span><br><span class="line"></span><br><span class="line">1. 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</span><br><span class="line">2. Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</span><br><span class="line">3. Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</span><br><span class="line">4. Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver 将下载镜像以 Graph 的形式存储。</span><br><span class="line">5. 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</span><br><span class="line">6. 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</span><br><span class="line">7. Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作。</span><br><span class="line"></span><br><span class="line">### 整体架构</span><br><span class="line"></span><br><span class="line">![image-20220626012732507](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220626012732.png)</span><br><span class="line"></span><br><span class="line">## Docker Compose</span><br><span class="line"></span><br><span class="line">&gt; 官方文档：https://docs.docker.com/compose/</span><br><span class="line"></span><br><span class="line">### 什么是 Docker Compose</span><br><span class="line"></span><br><span class="line">`Docker Compose` 是一个用于定义和运行多容器 `Docker` 应用程序的工具。使用 `Compose`，您可以使用 `YAML` 文件来配置应用程序的服务。然后，使用单个命令，从配置创建并启动所有服务</span><br><span class="line"></span><br><span class="line">使用 `Docker Compose` 基本上有以下三步：</span><br><span class="line"></span><br><span class="line">1. 使用 定义应用的环境，以便可以在任何位置重现它。`Dockerfile`</span><br><span class="line">2. 定义构成应用的服务，以便它们可以在隔离的环境中一起运行。`docker-compose.yml`</span><br><span class="line">3. 运行[Docker Compose](https://docs.docker.com/compose/cli-command/)将启动并运行整个应用。您也可以使用 docker-compose 二进制文件运行。` docker compose up``docker-compose up `</span><br><span class="line"></span><br><span class="line">`docker-compose.yml` 示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>YAML</p>
<p>version: “3.9”  # optional since v1.27.0<br>services:<br>  web:<br>    build: .<br>    ports:<br>      - “8000:5000”<br>    volumes:<br>      - .:&#x2F;code<br>      - logvolume01:&#x2F;var&#x2F;log<br>    links:<br>      - redis<br>  redis:<br>    image: redis<br>volumes:<br>  logvolume01: {}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 安装 Docker Compose</span><br><span class="line"></span><br><span class="line">1. 下载</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH</p>
<h1 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h1><p>sudo curl -L “<a href="https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$">https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$</a>(uname -s)-$(uname -m)” -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</p>
<h1 id="国内镜像"><a href="#国内镜像" class="headerlink" title="国内镜像"></a>国内镜像</h1><p>sudo curl -L “<a href="https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-$">https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-$</a>(uname -s)-$(uname -m)” -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220404124103270](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220404124103.png)</span><br><span class="line"></span><br><span class="line">1. 给 `docker-compose` 文件授可执行权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 测试安装是否成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose –version</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 卸载 `docker-compose`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AWK<br>rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220404124418121](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220404124418.png)</span><br><span class="line"></span><br><span class="line">### Compose 核心概念</span><br><span class="line"></span><br><span class="line">**一文件**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>docker-compose.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**两要素**</span><br><span class="line"></span><br><span class="line">- 服务（service)</span><br><span class="line"></span><br><span class="line">一个个应用容器实例，比如订单微服务、库存微服务、mysql 容器、nginx 容器或者 redis 容器</span><br><span class="line"></span><br><span class="line">- 工程（project）</span><br><span class="line"></span><br><span class="line">由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义</span><br><span class="line"></span><br><span class="line">### Compose 使用的三个步骤</span><br><span class="line"></span><br><span class="line">1. 编写 Dockerfile 定义各个微服务应用并构建出对应的镜像文件</span><br><span class="line">2. 使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务</span><br><span class="line">3. 最后，执行 docker-compose up 命令 来启动并运行整个应用程序，完成一键部署上线</span><br><span class="line"></span><br><span class="line">### Compose 常用命令</span><br><span class="line"></span><br><span class="line">**查看帮助信息**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose -h|help</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**命令选项**</span><br><span class="line"></span><br><span class="line">- -f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定；</span><br><span class="line">- -p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名；</span><br><span class="line">- –x-networking 使用 Docker 的可拔插网络后端特性；</span><br><span class="line">- –x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge；</span><br><span class="line">- –verbose 输出更多调试信息；</span><br><span class="line">- -v, –version 打印版本并退出；</span><br><span class="line">- -H, –host HOST，远程操作 docker，被操作的 docker 需要开放 2375 端口</span><br><span class="line"></span><br><span class="line">**常用命令**</span><br><span class="line"></span><br><span class="line">- **up**：启动所有 docker-compose 服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose up</p>
<h1 id="启动所有docker-compose服务并后台运行"><a href="#启动所有docker-compose服务并后台运行" class="headerlink" title="启动所有docker-compose服务并后台运行"></a>启动所有docker-compose服务并后台运行</h1><p>docker-compose up -d</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **down**：停止并删除容器、网络、卷</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose down</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **exec**：进入容器实例内部</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose exec docker-compose.yml文件中写的服务id &#x2F;bin&#x2F;bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **ps**：展示当前 docker-compose 编排过的运行的所有容器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose ps</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **top**：展示当前 docker-compose 编排过的容器进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose top</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **logs**：查看容器输出日志</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose logs yml里面的服务id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **build**：构建或者重新构建服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose build</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **start**：启动服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose start yml里面的服务id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **stop**：停止服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose stop yml里面的服务id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **restart**：重启服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose restart yml里面的服务id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **config**：检查配置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker-compose config</p>
<h1 id="有问题才输出"><a href="#有问题才输出" class="headerlink" title="有问题才输出"></a>有问题才输出</h1><h2 id="docker-compose-config-qBASHdocker-compose-scale-yml里面的服务id-x3D-实例个数YAMLbuild-x2F-dir"><a href="#docker-compose-config-qBASHdocker-compose-scale-yml里面的服务id-x3D-实例个数YAMLbuild-x2F-dir" class="headerlink" title="docker-compose config -qBASHdocker-compose scale yml里面的服务id&#x3D;实例个数YAMLbuild: .&#x2F;dir"></a>docker-compose config -q<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **scale**：设置指定服务运行容器的个数，以 `service=num` 形式指定</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>BASH<br>docker-compose scale yml里面的服务id&#x3D;实例个数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### docker-compose.yml 文件规则</span><br><span class="line"></span><br><span class="line">官网地址：https://docs.docker.com/compose/compose-file/compose-file-v3/</span><br><span class="line"></span><br><span class="line">- **version**：指定 docker-compose.yml 文件的写法格式</span><br><span class="line">- **services**：服务，多个容器集合</span><br><span class="line">- **build**：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>YAML<br>build: .&#x2F;dir</h2><h2 id="build-context-x2F-dir-dockerfile-Dockerfile-args-buildno-1YAMLcommand-bundle-exec-thin-p-3000"><a href="#build-context-x2F-dir-dockerfile-Dockerfile-args-buildno-1YAMLcommand-bundle-exec-thin-p-3000" class="headerlink" title="build:    context: .&#x2F;dir    dockerfile: Dockerfile    args:        buildno: 1YAMLcommand: bundle exec thin -p 3000"></a>build:<br>    context: .&#x2F;dir<br>    dockerfile: Dockerfile<br>    args:<br>        buildno: 1<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **command**：覆盖容器启动后默认执行的命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>YAML<br>command: bundle exec thin -p 3000</h2><h2 id="command-bundle-exec-thin-p-3000-YAMLdns-8-8-8-8"><a href="#command-bundle-exec-thin-p-3000-YAMLdns-8-8-8-8" class="headerlink" title="command: [bundle,exec,thin,-p,3000]YAMLdns: 8.8.8.8"></a>command: [bundle,exec,thin,-p,3000]<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **dns**：配置 dns 服务器，可以是一个值或列表</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>YAML<br>dns: 8.8.8.8</h2><h2 id="dns-8-8-8-8-9-9-9-9YAMLdns-search-example-com"><a href="#dns-8-8-8-8-9-9-9-9YAMLdns-search-example-com" class="headerlink" title="dns:    - 8.8.8.8    - 9.9.9.9YAMLdns_search: example.com"></a>dns:<br>    - 8.8.8.8<br>    - 9.9.9.9<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **dns_search**：配置 DNS 搜索域，可以是一个值或列表</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>YAML<br>dns_search: example.com</h2><h2 id="dns-search-dc1-example-com-dc2-example-comYAMLenvironment-RACK-ENV-development-SHOW-‘ture’"><a href="#dns-search-dc1-example-com-dc2-example-comYAMLenvironment-RACK-ENV-development-SHOW-‘ture’" class="headerlink" title="dns_search:    - dc1.example.com    - dc2.example.comYAMLenvironment:    RACK_ENV: development    SHOW: ‘ture’"></a>dns_search:<br>    - dc1.example.com<br>    - dc2.example.com<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **environment**：环境变量配置，可以用数组或字典两种方式</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>YAML<br>environment:<br>    RACK_ENV: development<br>    SHOW: ‘ture’</h2><h2 id="environment-RACK-ENV-x3D-development-SHOW-x3D-tureYAMLenv-file-env"><a href="#environment-RACK-ENV-x3D-development-SHOW-x3D-tureYAMLenv-file-env" class="headerlink" title="environment:    - RACK_ENV&#x3D;development    - SHOW&#x3D;tureYAMLenv_file: .env"></a>environment:<br>    - RACK_ENV&#x3D;development<br>    - SHOW&#x3D;ture<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **env_file**：从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>YAML<br>env_file: .env</h2><p>env_file:<br>    - .&#x2F;common.env</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **expose**：暴露端口，只将端口暴露给连接的服务，而不暴露给主机</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>YAML<br>expose:<br>    - “3000”<br>    - “8000”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **image**：指定服务所使用的镜像</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>YAML<br>image: java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **network_mode**：设置网络模式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>YAML<br>network_mode: “bridge”<br>network_mode: “host”<br>network_mode: “none”<br>network_mode: “service:[service name]”<br>network_mode: “container:[container name&#x2F;id]”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **ports**：对外暴露的端口定义，和 expose 对应</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>YAML<br>ports:   # 暴露端口信息  - “宿主机端口:容器暴露端口”</p>
<ul>
<li>“8763:8763”</li>
<li>“8763:8763”<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **links**：将指定容器连接到当前连接，可以设置别名，避免 ip 方式导致的容器重启动态改变的无法连接情况</span><br><span class="line"></span><br></pre></td></tr></table></figure>
YAML<br>links:    # 指定服务名称:别名<ul>
<li>docker-compose-eureka-server:compose-eureka<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **volumes**：卷挂载路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>
YAML<br>volumes:</li>
<li>&#x2F;lib</li>
<li>&#x2F;var<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## Docker 轻量级可视化工具 Portainer</span><br><span class="line"></span><br><span class="line">Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理 Docker 环境，包括单机环境和集群环境。</span><br><span class="line"></span><br><span class="line">docker 命令安装</span><br><span class="line"></span><br></pre></td></tr></table></figure>
BASH</li>
</ul>
</li>
</ul>
<h1 id="官方版本"><a href="#官方版本" class="headerlink" title="官方版本"></a>官方版本</h1><p>docker run -d -p 8000:8000 -p 9010:9000 –name portainer –restart&#x3D;always -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data portainer&#x2F;portainer</p>
<h1 id="中文版本"><a href="#中文版本" class="headerlink" title="中文版本"></a>中文版本</h1><p>docker run -d –restart&#x3D;always –name&#x3D;”portainer” -p 9010:9000 -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data 6053537&#x2F;portainer-ce</p>
<h1 id="EE-商业版本（public-为中文汉化资源）"><a href="#EE-商业版本（public-为中文汉化资源）" class="headerlink" title="EE 商业版本（public 为中文汉化资源）"></a>EE 商业版本（public 为中文汉化资源）</h1><p>docker run -d -p 8000:8000 -p 9010:9000 -p 9443:9443 –name&#x3D;portainer –restart&#x3D;always -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v &#x2F;u01&#x2F;portainer&#x2F;portainer_data:&#x2F;data -v &#x2F;u01&#x2F;portainer&#x2F;public:&#x2F;public portainer&#x2F;portainer-ee:2.10.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一次登录需要创建 admin 用户，访问地址：`xxx.xxx.xxx.xxx:9010`</span><br><span class="line"></span><br><span class="line">![image-20211218203604987](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218203605.png)</span><br><span class="line"></span><br><span class="line">选择 local 选项卡后本地 docker 详细信息展示</span><br><span class="line"></span><br><span class="line">![image-20211218203652466](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218203652.png)</span><br><span class="line">管理本地环境</span><br><span class="line"></span><br><span class="line">![image-20211218203840461](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20211218203840.png)</span><br><span class="line"></span><br><span class="line">## Docker Swarm</span><br><span class="line"></span><br><span class="line">&gt; 官方文档：https://docs.docker.com/engine/swarm/</span><br><span class="line"></span><br><span class="line">### 什么是 Docker Swarm</span><br><span class="line"></span><br><span class="line">Swarm 是 [Docker](https://www.docker.com/) 官方提供的一款集群管理工具，其主要作用是把若干台 Docker 主机抽象为一个整体，并且通过一个入口统一管理这些 Docker 主机上的各种 Docker 资源。</span><br><span class="line"></span><br><span class="line">Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务。</span><br><span class="line"></span><br><span class="line">### Docker Swarm 架构图</span><br><span class="line"></span><br><span class="line">![image-20220405181654649](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220405181654.png)</span><br><span class="line"></span><br><span class="line">上图可以看出，Swarm 是典型的 master-slave 结构，通过发现服务来选举 manager。manager 是中心管理节点，各个 node 上运行 agent 接受 manager 的统一管理，集群会自动通过 Raft 协议分布式选举出 manager 节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了 DNS 的负载均衡和对外部负载均衡机制的集成支持。</span><br><span class="line"></span><br><span class="line">### Swarm 关键概念</span><br><span class="line"></span><br><span class="line">- **Swarm（群）**</span><br><span class="line"></span><br><span class="line">嵌入在 Docker 引擎中的集群管理和编排功能是使用[swarmkit 构建的](https://github.com/docker/swarmkit/)。`Swarmkit` 是一个单独的项目，它实现了 Docker 的编排层并直接在 Docker 中使用。</span><br><span class="line"></span><br><span class="line">一个 swarm 由多个 Docker 主机组成，它们以**swarm 模式**运行并充当管理器（管理成员资格和委托）和工作人员（运行 [swarm 服务](https://docs.docker.com/engine/swarm/key-concepts/#services-and-tasks)）。给定的 Docker 主机可以是管理员、工作人员或同时执行这两种角色。创建服务时，您需要定义其最佳状态（副本数量、可用的网络和存储资源、服务向外界公开的端口等等）。Docker 致力于维护所需的状态。例如，如果一个工作节点变得不可用，Docker 会将该节点的任务安排在其他节点上。*任务*是一个 正在运行的容器，它是一个集群服务的一部分，由一个集群管理器管理，而不是一个独立的容器。</span><br><span class="line"></span><br><span class="line">swarm 服务相对于独立容器的主要优势之一是您可以修改服务的配置，包括它所连接的网络和卷，而无需手动重新启动服务。Docker 将更新配置，停止具有过期配置的服务任务，并创建与所需配置匹配的新任务。</span><br><span class="line"></span><br><span class="line">当 Docker 在 swarm 模式下运行时，您仍然可以在任何参与 swarm 的 Docker 主机以及 swarm 服务上运行独立容器。独立容器和 swarm 服务之间的一个关键区别在于，只有 `swarm manager` 可以管理 swarm，而独立容器可以在任何守护进程上启动。Docker 守护进程可以作为管理者、工作者或两者兼而有之。</span><br><span class="line"></span><br><span class="line">就像您可以使用[Docker Compose](https://docs.docker.com/compose/)定义和运行容器一样，您可以定义和运行[Swarm 服务](https://docs.docker.com/engine/swarm/services/)堆栈。</span><br><span class="line"></span><br><span class="line">- **Node（节点）**</span><br><span class="line"></span><br><span class="line">**节点**是参与 swarm 的 Docker 引擎的一个实例。您也可以将其视为 Docker 节点。您可以在单个物理计算机或云服务器上运行一个或多个节点，但生产群部署通常包括分布在多个物理和云计算机上的 Docker 节点。</span><br><span class="line"></span><br><span class="line">要将应用程序部署到 swarm，您需要向 **管理器节点**提交服务定义。管理节点将称为 [任务](https://docs.docker.com/engine/swarm/key-concepts/#services-and-tasks)的工作单元分派给工作节点。</span><br><span class="line"></span><br><span class="line">管理器节点还执行维护集群所需状态所需的编排和集群管理功能。管理器节点选举一个领导者来执行编排任务。</span><br><span class="line"></span><br><span class="line">**工作节点**接收并执行从管理节点分派的任务。默认情况下，管理器节点也将服务作为工作节点运行，但您可以将它们配置为专门运行管理器任务并成为仅管理器节点。代理在每个工作节点上运行并报告分配给它的任务。`worker` 节点将其分配的任务的当前状态通知给 `manager` 节点，以便 `manager` 可以保持每个 `worker` 的期望状态。</span><br><span class="line"></span><br><span class="line">- **Service（服务）**</span><br><span class="line"></span><br><span class="line">**服务**是要在管理节点或工作节点上执行的任务的定义。它是 swarm 系统的**中心结构**，也是用户与 swarm 交互的主要根源。</span><br><span class="line"></span><br><span class="line">创建服务时，您需要指定要使用的容器映像以及在运行的容器中执行的命令。</span><br><span class="line"></span><br><span class="line">在**复制服务**模型中，群管理器根据您在所需状态中设置的规模在节点之间分配特定数量的副本任务。</span><br><span class="line"></span><br><span class="line">对于**全局服务**，swarm 在集群中的每个可用节点上为服务运行一个任务。</span><br><span class="line"></span><br><span class="line">- **Task（任务）**</span><br><span class="line"></span><br><span class="line">一个**任务**携带一个 Docker 容器和在容器内运行的命令。它是 swarm 的**原子调度单元**。Manager 节点根据服务规模中设置的副本数将任务分配给工作节点。一旦任务被分配给一个节点，它就不能移动到另一个节点。它只能在分配的节点上运行或失败。</span><br><span class="line"></span><br><span class="line">- **Load balancing（负载均衡）**</span><br><span class="line"></span><br><span class="line">swarm 管理器使用**入口负载平衡**将您希望在外部提供给 swarm 的服务公开。swarm manager 可以自动为服务分配一个**PublishedPort**，或者您可以为该服务配置一个 PublishedPort。您可以指定任何未使用的端口。如果不指定端口，swarm manager 会为服务分配一个 `30000-32767` 范围内的端口。</span><br><span class="line"></span><br><span class="line">外部组件（例如云负载均衡器）可以访问集群中任何节点的 PublishedPort 上的服务，无论该节点当前是否正在运行该服务的任务。swarm 中的所有节点将入口连接路由到正在运行的任务实例。</span><br><span class="line"></span><br><span class="line">Swarm 模式有一个内部 `DNS` 组件，它自动为 swarm 中的每个服务分配一个 DNS 条目。swarm manager 使用**内部负载平衡**根据服务的 DNS 名称在集群内的服务之间分配请求。</span><br><span class="line"></span><br><span class="line">### Swarm 工作原理</span><br><span class="line"></span><br><span class="line">#### 节点如何工作</span><br><span class="line"></span><br><span class="line">Swarm 集群由管理节点（Manager）和工作节点（Work）构成。</span><br><span class="line"></span><br><span class="line">![image-20220716220722605](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220716220722.png)</span><br><span class="line"></span><br><span class="line">##### 管理节点</span><br><span class="line"></span><br><span class="line">Manager 节点处理集群管理任务：</span><br><span class="line"></span><br><span class="line">- 维护集群状态</span><br><span class="line">- 调度服务</span><br><span class="line">- 服务群模式[HTTP API 端点](https://docs.docker.com/engine/api/)</span><br><span class="line"></span><br><span class="line">使用[Raft](https://raft.github.io/raft.pdf)实现，管理器维护整个 swarm 和在其上运行的所有服务的一致内部状态。出于测试目的，可以使用单个管理器运行 swarm。如果单管理器集群中的管理器发生故障，您的服务将继续运行，但您需要创建一个新集群才能恢复。</span><br><span class="line"></span><br><span class="line">为了利用 swarm 模式的容错特性，Docker 建议您根据组织的高可用性要求实现奇数个节点。当您有多个管理器时，您可以从管理器节点的故障中恢复而无需停机。</span><br><span class="line"></span><br><span class="line">- 一个三管理器群最多可以容忍一名管理器的损失。</span><br><span class="line">- 一个五管理器群最多可以同时丢失两个管理器节点。</span><br><span class="line">- 一个`N`管理器集群最多可以容忍丢失 `(N-1)/2`管理器。</span><br><span class="line">- Docker 建议一个 swarm 最多使用七个管理器节点。</span><br><span class="line"></span><br><span class="line">&gt; **重要提示**：添加更多管理器并不意味着增加可扩展性或提高性能。一般来说，情况正好相反。</span><br><span class="line"></span><br><span class="line">##### 工作节点</span><br><span class="line"></span><br><span class="line">工作节点也是 Docker 引擎的实例，其唯一目的是执行容器。Worker 节点不参与 Raft 分布式状态，不做调度决策，也不服务于 swarm 模式的 HTTP API。</span><br><span class="line"></span><br><span class="line">您可以创建一个由一个管理器节点组成的集群，但如果没有至少一个管理器节点，您就不能拥有一个工作程序节点。默认情况下，所有 manager 也是 worker。在单个管理节点集群中，您可以运行类似 `docker service create` 的命令，并且调度程序将所有任务放在本地引擎上。</span><br><span class="line"></span><br><span class="line">要防止调度程序将任务放置在多节点集群中的管理器节点上，请将管理器节点的可用性设置为 `Drain`。调度器优雅地停止 `Drain` 模式节点上的任务，并在一个 `Active` 节点上调度任务。调度程序不会将新任务分配给 `Drain` 可用的节点。</span><br><span class="line"></span><br><span class="line">请参阅[docker node update](https://docs.docker.com/engine/reference/commandline/node_update/) 命令行参考以了解如何更改节点可用性。</span><br><span class="line"></span><br><span class="line">#### 服务如何运作</span><br><span class="line"></span><br><span class="line">要在 Docker 引擎处于 swarm 模式时部署应用程序映像，您需要创建一个服务。通常，服务是某个更大应用程序上下文中微服务的映像。服务的示例可能包括 HTTP 服务器、数据库或您希望在分布式环境中运行的任何其他类型的可执行程序。</span><br><span class="line"></span><br><span class="line">创建服务时，您需要指定要使用的容器映像以及在运行的容器中执行的命令。您还可以定义服务的选项，包括：</span><br><span class="line"></span><br><span class="line">- swarm 使服务在 swarm 外部可用的端口</span><br><span class="line">- 服务连接到集群中的其他服务的覆盖网络</span><br><span class="line">- CPU 和内存限制和预留</span><br><span class="line">- 滚动更新策略</span><br><span class="line">- 在 swarm 中运行的图像的副本数</span><br><span class="line"></span><br><span class="line">##### 服务、任务和容器</span><br><span class="line"></span><br><span class="line">当您将服务部署到 swarm 时，swarm manager 接受您的服务定义作为服务的所需状态。然后，它将集群中的节点上的服务安排为一个或多个副本任务。这些任务在 swarm 中的节点上彼此独立运行。</span><br><span class="line"></span><br><span class="line">例如，假设您想在 nginx 的三个实例之间进行负载平衡。下图显示了具有三个副本的 nginx 服务。nginx 的三个实例中的每一个都是 swarm 中的一个任务。</span><br><span class="line"></span><br><span class="line">![image-20220717111642619](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220717111642.png)</span><br><span class="line"></span><br><span class="line">容器是一个独立的进程。在 swarm 模式模型中，每个任务只调用一个容器。任务类似于调度程序放置容器的“槽”。一旦容器处于活动状态，调度程序就会识别出任务处于运行状态。如果容器未通过健康检查或终止，则任务终止。</span><br><span class="line"></span><br><span class="line">##### 任务和调度</span><br><span class="line"></span><br><span class="line">任务是 swarm 中调度的原子单元。当您通过创建或更新服务来声明所需的服务状态时，编排器通过调度任务来实现所需的状态。例如，您定义了一个服务，该服务指示协调器始终保持三个 HTTP 侦听器实例运行。编排器通过创建三个任务来响应。每个任务都是调度程序通过生成容器来填充的槽。容器是任务的实例化。如果 HTTP 侦听器任务随后未能通过其健康检查或崩溃，编排器将创建一个新的副本任务来生成一个新容器。</span><br><span class="line"></span><br><span class="line">任务是一种单向机制。它通过一系列状态单调地进行：分配、准备、运行等。如果任务失败，编排器将删除任务及其容器，然后根据服务指定的所需状态创建一个新任务来替换它。</span><br><span class="line"></span><br><span class="line">Docker swarm 模式的底层逻辑是一个通用的调度器和编排器。服务和任务抽象本身并不知道它们实现的容器。假设您可以实现其他类型的任务，例如虚拟机任务或非容器化流程任务。调度器和编排器不知道任务的类型。但是，当前版本的 Docker 只支持容器任务。</span><br><span class="line"></span><br><span class="line">下图显示了 swarm 模式如何接受服务创建请求并将任务调度到工作节点。</span><br><span class="line"></span><br><span class="line">![image-20220717231629076](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220717231629.png)</span><br><span class="line"></span><br><span class="line">##### 待办服务（pending）</span><br><span class="line"></span><br><span class="line">一个服务可以这样配置，使得当前在 swarm 中的任何节点都不能运行它的任务。在这种情况下，服务保持状态`pending`。以下是服务可能保持状态的几个示例`pending`。</span><br><span class="line"></span><br><span class="line">&gt; **注意**：如果您的唯一目的是阻止部署服务，请将服务缩放到 0，而不是尝试将其配置为保留在`pending`.</span><br><span class="line"></span><br><span class="line">- 如果所有节点都已暂停或耗尽，并且您创建了一项服务，则该服务将处于挂起状态，直到节点可用为止。实际上，第一个可用的节点会获得所有任务，因此这在生产环境中不是一件好事。</span><br><span class="line">- 您可以为服务保留特定数量的内存。如果 swarm 中没有节点具有所需的内存量，则服务将保持挂起状态，直到可以运行其任务的节点可用。如果您指定一个非常大的值，例如 500 GB，则该任务将永远保持挂起状态，除非您确实有一个可以满足它的节点。</span><br><span class="line">- 您可以对服务施加放置约束，并且这些约束可能无法在给定时间得到遵守。</span><br><span class="line"></span><br><span class="line">这种行为说明您的任务的要求和配置与当前的 swarm 状态并没有紧密联系。作为 swarm 的管理员，您声明了您的 swarm 所需的状态，并且管理器与 swarm 中的节点一起创建该状态。您不需要对 swarm 上的任务进行微观管理。</span><br><span class="line"></span><br><span class="line">##### 部署模式</span><br><span class="line"></span><br><span class="line">有两种类型的服务部署，复制的（`replicated`）和全局的（`global`）。</span><br><span class="line"></span><br><span class="line">对于复制服务，您指定要运行的相同任务的数量。例如，您决定部署具有三个副本的 HTTP 服务，每个副本提供相同的内容。</span><br><span class="line"></span><br><span class="line">全局服务是在每个节点上运行一个任务的服务。没有预先指定的任务数量。每次将节点添加到 swarm 时，编排器都会创建一个任务，调度器会将任务分配给新节点。全局服务的良好候选者是监控代理、防病毒扫描程序或您希望在集群中的每个节点上运行的其他类型的容器。</span><br><span class="line"></span><br><span class="line">下图显示了黄色的三服务副本和灰色的全局服务。</span><br><span class="line"></span><br><span class="line">![image-20220717232121078](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220717232121.png)</span><br><span class="line"></span><br><span class="line">#### Swarm 任务状态</span><br><span class="line"></span><br><span class="line">Docker 允许创建可以启动任务的服务。服务是对所需状态的描述，而任务完成工作。工作按以下顺序安排在 swarm 节点上：</span><br><span class="line"></span><br><span class="line">1. 通过使用创建服务`docker service create`。</span><br><span class="line">2. 请求转到 Docker 管理器节点。</span><br><span class="line">3. Docker 管理器节点安排服务在特定节点上运行。</span><br><span class="line">4. 每个服务可以启动多个任务。</span><br><span class="line">5. 每个任务都有一个生命周期，其状态包括 `NEW`、`PENDING` 和 `COMPLETE`。</span><br><span class="line"></span><br><span class="line">任务是运行一次即可完成的执行单元。当一个任务停止时，它不会再次执行，但一个新的任务可能会取代它。</span><br><span class="line"></span><br><span class="line">任务通过多个状态前进，直到它们完成或失败。任务在 `NEW` 状态中初始化。任务通过多个状态向前推进，并且其状态不会后退。例如，任务永远不会从 `COMPLETE` 到 `RUNNING`。</span><br><span class="line"></span><br><span class="line">任务按以下顺序通过状态：</span><br><span class="line"></span><br><span class="line">| 任务状态    | 描述                                                                   |</span><br><span class="line">| ----------- | ---------------------------------------------------------------------- |</span><br><span class="line">| `NEW`       | 任务已初始化。                                                         |</span><br><span class="line">| `PENDING`   | 分配了任务的资源。                                                     |</span><br><span class="line">| `ASSIGNED`  | Docker 将任务分配给节点。                                              |</span><br><span class="line">| `ACCEPTED`  | 该任务已被工作节点接受。如果工作节点拒绝任务，则状态更改为`REJECTED`。 |</span><br><span class="line">| `PREPARING` | Docker 正在准备任务。                                                  |</span><br><span class="line">| `STARTING`  | Docker 正在启动任务。                                                  |</span><br><span class="line">| `RUNNING`   | 任务正在执行。                                                         |</span><br><span class="line">| `COMPLETE`  | 任务退出，没有错误代码。                                               |</span><br><span class="line">| `FAILED`    | 任务以错误代码退出。                                                   |</span><br><span class="line">| `SHUTDOWN`  | Docker 请求关闭任务。                                                  |</span><br><span class="line">| `REJECTED`  | 工作节点拒绝了该任务。                                                 |</span><br><span class="line">| `ORPHANED`  | 节点关闭时间过长。                                                     |</span><br><span class="line">| `REMOVE`    | 该任务不是终端，但相关服务已被删除或缩小。                             |</span><br><span class="line"></span><br><span class="line">&gt; **查看任务状态**</span><br><span class="line">&gt;</span><br><span class="line">&gt; 运行 docker service ps 以获取任务的状态。该 `CURRENT STATE` 字段显示任务的状态以及它在那里的时间。</span><br><span class="line"></span><br><span class="line">### 常用命令</span><br><span class="line"></span><br><span class="line">#### 创建 Swarm</span><br><span class="line"></span><br><span class="line">1. 运行以下命令来创建一个新的 swarm：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker swarm init –advertise-addr <MANAGER-IP></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker swarm init –advertise-addr 192.168.88.230<br>Swarm initialized: current node (uo7m7w01d5wfdjt0qn9m3aau4) is now a manager.</p>
<p>To add a worker to this swarm, run the following command:</p>
<pre><code>docker swarm join --token SWMTKN-1-63d99h3uln0k8qfne7w39qt6f1tv4yddvevyzwh3uzhhfl73wf-3abelxhlyvhm54klavpbr06r5 192.168.88.230:2377
</code></pre>
<p>To add a manager to this swarm, run ‘docker swarm join-token manager’ and follow the instructions.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 该 `--advertise-addr` 标志将管理节点配置为将其地址发布为 `192.168.88.230`。 swarm 中的其他节点必须能够访问该 IP 地址的 manager。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 输出包括将新节点加入 swarm 的命令。根据 `--token` 标志的值，节点将作为 manager 或 worker 加入。</span><br><span class="line"></span><br><span class="line">1. 运行`docker info`查看 swarm 的当前状态：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH</p>
<p>$ docker info<br> Containers: 3<br>  Running: 3<br>  Paused: 0<br>  Stopped: 0<br> Images: 4<br> …snip…<br> Swarm: active<br>  NodeID: uo7m7w01d5wfdjt0qn9m3aau4<br>  Is Manager: true<br>  ClusterID: ym3kr78wgx258lawn3iclgxwq<br>  Managers: 1<br>  Nodes: 3<br>  …snip…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 运行`docker node ls`命令查看节点信息：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker node ls<br>ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION<br>uo7m7w01d5wfdjt0qn9m3aau4 *   88230      Ready     Active         Leader           20.10.13<br>p4tlkfxa4d2ne1diq0mtlifs9     88233      Ready     Active                          20.10.17<br>oawv9cs597brq8h5hzis3ynlc     88237      Ready     Active                          20.10.17</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 将节点添加到 Swarm</span><br><span class="line"></span><br><span class="line">当你创建了一个带有管理节点的 swarm 时，你就可以添加工作节点了。</span><br><span class="line"></span><br><span class="line">1. 运行创建 Swarm 中 `docker swarm init` 步骤生成的命令，以创建一个加入现有 swarm 的工作节点：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker swarm join –token SWMTKN-1-63d99h3uln0k8qfne7w39qt6f1tv4yddvevyzwh3uzhhfl73wf-3abelxhlyvhm54klavpbr06r5 192.168.88.230:2377</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 如果没有可用的命令，可以在管理节点上运行以下命令来生成工作节点的加入命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker swarm join-token worker<br>To add a worker to this swarm, run the following command:</p>
<pre><code>docker swarm join --token SWMTKN-1-63d99h3uln0k8qfne7w39qt6f1tv4yddvevyzwh3uzhhfl73wf-3abelxhlyvhm54klavpbr06r5 192.168.88.230:2377
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 生成管理节点的加入命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker swarm join-token manager<br>To add a manager to this swarm, run the following command:</p>
<pre><code>docker swarm join --token SWMTKN-1-63d99h3uln0k8qfne7w39qt6f1tv4yddvevyzwh3uzhhfl73wf-0so9mhkgy8btr579ho4pfza9n 192.168.88.230:2377
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 删除节点</span><br><span class="line"></span><br><span class="line">先在要删除的节点上运行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker swarm leave</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在 `manage` 节点上运行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker node rm NODE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 节点提升</span><br><span class="line"></span><br><span class="line">**用法**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker node promote NODE [NODE…]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**说明**</span><br><span class="line"></span><br><span class="line">将节点提升为 `manager`。该命令只能在 `manage node` 上执行。</span><br><span class="line"></span><br><span class="line">&gt; **笔记**</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这是一个集群管理命令，必须在 swarm manager 节点上执行。</span><br><span class="line"></span><br><span class="line">#### 节点降级</span><br><span class="line"></span><br><span class="line">**用法**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>docker node demote NODE [NODE…]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**说明**</span><br><span class="line"></span><br><span class="line">降级现有 `manager`，使其不再是 `manager`。</span><br><span class="line"></span><br><span class="line">&gt; **笔记**</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这是一个集群管理命令，必须在 swarm manager 节点上执行。</span><br><span class="line"></span><br><span class="line">#### 部署服务</span><br><span class="line"></span><br><span class="line">1. 在管理节点上运行以下命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service create –replicas 1 –name helloworld alpine ping docker.com<br>ktcjndh4nj4nbwp461idnob0y</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 该 `docker service create` 命令创建服务。</span><br><span class="line">- 该 `--name` 标志命名服务 `helloworld`。</span><br><span class="line">- 该 `--replicas` 标志指定 1 个正在运行的实例的所需状态。</span><br><span class="line">- 参数 `alpine ping docker.com` 将服务定义为执行命令的 Alpine Linux 容器 `ping docker.com`。</span><br><span class="line"></span><br><span class="line">1. 运行 `docker service ls` 查看正在运行的服务列表：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service ls<br>ID             NAME         MODE         REPLICAS   IMAGE           PORTS<br>ktcjndh4nj4n   helloworld   replicated   1&#x2F;1        alpine:latest</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 检查服务</span><br><span class="line"></span><br><span class="line">将服务部署到 swarm 后，可以使用 `Docker CLI` 查看有关在 swarm 中运行的服务的详细信息。</span><br><span class="line"></span><br><span class="line">1. 运行 `docker service inspect --pretty &lt;SERVICE-ID&gt;` 以易于阅读的格式显示有关服务的详细信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>YAML</p>
<p>$ docker service inspect –pretty helloworld</p>
<p>ID:		ktcjndh4nj4nbwp461idnob0y<br>Name:		helloworld<br>Service Mode:	Replicated<br> Replicas:	1<br>Placement:<br>ContainerSpec:<br> Image:		alpine<br> Args:		ping docker.com<br> Init:		false<br>Resources:<br>Endpoint Mode:	vip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; **提示**：要以 json 格式返回服务详细信息，请运行不带 `--pretty` 标志的相同命令。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH</p>
<p>$ docker service inspect helloworld<br>[<br>    {<br>        “ID”: “ktcjndh4nj4nbwp461idnob0y”,<br>        “Version”: {<br>            “Index”: 28<br>        },<br>        “CreatedAt”: “2022-04-05T15:00:31.72873489Z”,<br>        “UpdatedAt”: “2022-04-05T15:00:31.72873489Z”,<br>        “Spec”: {<br>            “Name”: “helloworld”,<br>            “Labels”: {},<br>            “TaskTemplate”: {<br>                “ContainerSpec”: {<br>                    “Image”: “alpine”,<br>                    “Args”: [<br>                        “ping”,<br>                        “docker.com”<br>                    ],<br>                    “Init”: false,<br>                    “StopGracePeriod”: 10000000000,<br>                    “DNSConfig”: {},<br>                    “Isolation”: “default”<br>                },<br>                “Resources”: {<br>                    “Limits”: {},<br>                    “Reservations”: {}<br>                },<br>                “RestartPolicy”: {<br>                    “Condition”: “any”,<br>                    “Delay”: 5000000000,<br>                    “MaxAttempts”: 0<br>                },<br>                “Placement”: {},<br>                “ForceUpdate”: 0,<br>                “Runtime”: “container”<br>            },<br>            “Mode”: {<br>                “Replicated”: {<br>                    “Replicas”: 1<br>                }<br>            },<br>            “EndpointSpec”: {<br>                “Mode”: “vip”<br>            }<br>        },<br>        “Endpoint”: {<br>            “Spec”: {}<br>        }<br>    }<br>]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 运行 `docker service ps &lt;SERVICE-ID&gt;` 查看哪些节点正在运行该服务：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service ps helloworld<br>ID             NAME           IMAGE           NODE      DESIRED STATE   CURRENT STATE            ERROR     PORTS<br>3s1myvuaoc0k   helloworld.1.3s1myvuaoc0kdvlaz4fgz3usk   alpine:latest   8886      Running         Running 31 minutes ago</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在这种情况下，服务的一个实例正在节点 `helloworld` 上运行 。`8886` 您可能会看到该服务在您的管理器节点上运行。默认情况下，swarm 中的管理节点可以像工作节点一样执行任务。</span><br><span class="line"></span><br><span class="line">Swarm 还向您显示服务任务的 `DESIRED STATE` 和 `CURRENT STATE`，以便您可以查看任务是否根据服务定义运行。</span><br><span class="line"></span><br><span class="line">1. 在运行 `docker ps` 任务的节点上运行以查看有关任务容器的详细信息。</span><br><span class="line"></span><br><span class="line">&gt; **提示**：如果`helloworld`在管理节点以外的节点上运行，则必须 ssh 到该节点。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker ps<br>CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS     NAMES<br>3128610843c3   alpine:latest   “ping docker.com”   38 minutes ago   Up 38 minutes    helloworld.1.3s1myvuaoc0kdvlaz4fgz3usk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 扩展服务</span><br><span class="line"></span><br><span class="line">将服务部署到 swarm 后，您就可以使用 `Docker CLI` 扩展服务中的容器数量了。在服务中运行的容器称为“任务”。</span><br><span class="line"></span><br><span class="line">1. 运行以下命令以更改在 swarm 中运行的服务的所需状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service scale <SERVICE-ID>&#x3D;<NUMBER-OF-TASKS></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service scale helloworld&#x3D;5<br>hellworld scaled to 5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 运行 `docker service ps &lt;SERVICE-ID&gt;` 查看更新的任务列表：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service ps helloworld<br>ID             NAME           IMAGE           NODE      DESIRED STATE   CURRENT STATE                ERROR     PORTS<br>3s1myvuaoc0k   helloworld.1   alpine:latest   8886      Running         Running 43 minutes ago<br>sub0vfkz17t1   helloworld.2   alpine:latest   88235     Running         Running 53 seconds ago<br>qiiwkq8eaw4c   helloworld.3   alpine:latest   88236     Running         Running about a minute ago<br>272jo44c63qd   helloworld.4   alpine:latest   88236     Running         Running about a minute ago<br>vx61pv6vzm9y   helloworld.5   alpine:latest   8886      Running         Running 2 minutes ago</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">您可以看到 swarm 创建了 4 个新任务以扩展到总共 5 个正在运行的 Alpine Linux 实例。任务分布在 swarm 的三个节点之间。</span><br><span class="line"></span><br><span class="line">#### 删除服务</span><br><span class="line"></span><br><span class="line">1. 运行 `docker service rm helloworld` 以删除 `helloworld` 服务。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service rm helloworld<br>helloworld</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 应用滚动更新</span><br><span class="line"></span><br><span class="line">1. 将您的 Redis 标签部署到 swarm 并为 swarm 配置 10 秒的更新延迟。请注意，以下示例显示了较旧的 Redis 标记：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service create <br>  –replicas 3 <br>  –name redis <br>  –update-delay 10s <br>  redis:3.0.6<br>pvud31bgvl7e5ljf6xuxcn7dh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">您在服务部署时配置滚动更新策略。</span><br><span class="line"></span><br><span class="line">该 `--update-delay` 标志配置更新服务任务或任务集之间的时间延迟。您可以将时间描述 `T` 为秒数 `Ts`、分钟数 `Tm` 或小时数的组合 `Th`。所以 `10m30s` 表示延迟 10 分 30 秒。</span><br><span class="line"></span><br><span class="line">默认情况下，调度程序一次更新 1 个任务。您可以传递该 `--update-parallelism` 标志来配置调度程序同时更新的最大服务任务数。</span><br><span class="line"></span><br><span class="line">默认情况下，当单个任务的更新返回状态为 时 `RUNNING`，调度程序会安排另一个任务进行更新，直到所有任务都更新完毕。如果在更新期间的任何时间任务返回 `FAILED`，调度程序会暂停更新。您可以使用或 的 `--update-failure-action` 标志来控制行为 。`docker service create` `docker service update`</span><br><span class="line"></span><br><span class="line">1. 检查`redis`服务：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH</p>
<p>$ docker service inspect –pretty redis</p>
<p>ID:		pvud31bgvl7e5ljf6xuxcn7dh<br>Name:		redis<br>Service Mode:	Replicated<br> Replicas:	3<br>Placement:<br>UpdateConfig:<br> Parallelism:	1<br> Delay:		10s<br>ContainerSpec:<br> Image:		redis:3.0.6<br> Init:		false<br>Resources:<br>Endpoint Mode:	vip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 现在您可以更新 `redis`， swarm manager 根据 `UpdateConfig` 策略将更新应用到节点：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service update –image redis:3.0.7 redis<br>redis</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">默认情况下，调度程序按如下方式应用滚动更新：</span><br><span class="line"></span><br><span class="line">- 停止第一个任务。</span><br><span class="line">- 为已停止的任务安排更新。</span><br><span class="line">- 启动更新任务的容器。</span><br><span class="line">- 如果一个任务的更新返回`RUNNING`，等待指定的延迟时间然后开始下一个任务。</span><br><span class="line">- 如果在更新期间的任何时间，任务返回`FAILED`，则暂停更新。</span><br><span class="line"></span><br><span class="line">1. 运行 `docker service inspect --pretty redis` 以查看处于所需状态的新图像：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH</p>
<p>$ docker service inspect –pretty redis</p>
<p>ID:		pvud31bgvl7e5ljf6xuxcn7dh<br>Name:		redis<br>Service Mode:	Replicated<br> Replicas:	3<br>Placement:<br>UpdateConfig:<br> Parallelism:	1<br> Delay:		10s<br>ContainerSpec:<br> Image:		redis:3.0.7<br> Init:		false<br>Resources:<br>Endpoint Mode:	vip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 运行 `docker service ps &lt;SERVICE-ID&gt;` 以观看滚动更新：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker service ps redis<br>ID             NAME          IMAGE         NODE      DESIRED STATE   CURRENT STATE            ERROR     PORTS<br>s3uwdrtssguv   redis.1       redis:3.0.7   88236     Running         Running 3 minutes ago<br>9nav9b094si0    _ redis.1   redis:3.0.6   88236     Shutdown        Shutdown 5 minutes ago<br>tdy6tqfhweo4   redis.2       redis:3.0.7   88235     Running         Running 2 minutes ago<br>t9vr0kt1h8av    _ redis.2   redis:3.0.6   88235     Shutdown        Shutdown 3 minutes ago<br>xjc6v95dayhv   redis.3       redis:3.0.7   8886      Running         Running 3 minutes ago<br>biy701m9tvat    _ redis.3   redis:3.0.6   8886      Shutdown        Shutdown 4 minutes ago</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 排空一个节点</span><br><span class="line"></span><br><span class="line">有时，例如计划的维护时间，您需要将节点设置为 `DRAIN` 可用。`DRAIN` 可用性阻止节点从集群管理器接收新任务。这也意味着管理器停止在节点上运行的任务，并在可用的节点上启动副本任务 `ACTIVE`。</span><br><span class="line"></span><br><span class="line">&gt; **重要**：将节点设置为 `DRAIN` 不会从该节点删除独立容器，例如使用 Docker 引擎 API 创建的 `docker run` 容器 `docker-compose up`。一个节点的状态，包括 `DRAIN`，只影响节点调度 swarm 服务工作负载的能力。</span><br><span class="line"></span><br><span class="line">1. 运行 `docker node update --availability drain &lt;NODE-ID&gt;` 以排空已分配任务的节点：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker node update –availability drain worker1<br>work1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 检查节点其可用性：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>$ docker node inspect –pretty worker1<br>AVAILABILITY<code>属性值为</code>Drain</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## Docker Stack</span><br><span class="line"></span><br><span class="line">### deploy</span><br><span class="line"></span><br><span class="line">指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NESTEDTEXT</p>
<p>version: “3.7”<br>services:<br>  redis:<br>    image: redis:alpine<br>    deploy:<br>sssssssss<br>      endpoint_mode: dnsrr<br>      labels:<br>        description: “This redis service label”<br>      resources:<br>        limits:<br>          cpus: ‘0.50’<br>          memory: 50M<br>        reservations:<br>          cpus: ‘0.25’<br>          memory: 20M<br>      restart_policy:<br>        condition: on-failure<br>        delay: 5s<br>        max_attempts: 3<br>        window: 120s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">可以选参数：</span><br><span class="line"></span><br><span class="line">**endpoint_mode**：访问集群服务的方式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AVRASM<br>endpoint_mode: vip</p>
<h1 id="Docker-集群服务一个对外的虚拟-ip。所有的请求都会通过这个虚拟-ip-到达集群服务内部的机器。"><a href="#Docker-集群服务一个对外的虚拟-ip。所有的请求都会通过这个虚拟-ip-到达集群服务内部的机器。" class="headerlink" title="Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。"></a>Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</h1><p>endpoint_mode: dnsrr</p>
<h1 id="DNS-轮询（DNSRR）。所有的请求会自动轮询获取到集群-ip-列表中的一个-ip-地址。"><a href="#DNS-轮询（DNSRR）。所有的请求会自动轮询获取到集群-ip-列表中的一个-ip-地址。" class="headerlink" title="DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。"></a>DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</h1><pre><code>
**labels**：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。

**mode**：指定服务提供的模式。

- **replicated**：复制服务，复制指定服务到集群的机器上。

- **global**：全局服务，服务将部署至集群的每个节点。

- 图解：下图中黄色的方块是 replicated 模式的运行情况，灰色方块是 global 模式的运行情况。

  ![img](https://itboy-blog-image.oss-cn-hangzhou.aliyuncs.com/20220713152904.png)

**replicas：mode** 为 replicated 时，需要使用此参数配置具体运行的节点数量。

**resources**：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。

**restart_policy**：配置如何在退出容器时重新启动容器。

- condition：可选 none，on-failure 或者 any（默认值：any）。
- delay：设置多久之后重启（默认值：0）。
- max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。
- window：设置容器重启超时时间（默认值：0）。

**rollback_config**：配置在更新失败的情况下应如何回滚服务。

- parallelism：一次要回滚的容器数。如果设置为 0，则所有容器将同时回滚。
- delay：每个容器组回滚之间等待的时间（默认为 0s）。
- failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认 pause）。
- monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为 0s）。
- max_failure_ratio：在回滚期间可以容忍的故障率（默认为 0）。
- order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。

**update_config**：配置应如何更新服务，对于配置滚动更新很有用。

- parallelism：一次更新的容器数。
- delay：在更新一组容器之间等待的时间。
- failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者 pause （默认：pause）。
- monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为 0s）。
- max_failure_ratio：在更新过程中可以容忍的故障率。
- order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first）。

**注**：仅支持 V3.4 及更高版本。
</code></pre>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据库</title>
    <url>/2021/07/11/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Redis%20%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="为什么要用-Nosql"><a href="#为什么要用-Nosql" class="headerlink" title="为什么要用 Nosql"></a>为什么要用 Nosql</h2><blockquote>
<p>1、单机 MySQL 的年代！</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210420135521.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210420135521.png" alt="img"></a></p>
<p>90 年代，一个基本的网站访问量一般不会太大，单个数据库完全足够！</p>
<p>那个时候，更多的去使用静态网页 HTML &#x3D;&#x3D;&gt; 服务器根本没有太大的压力！</p>
<p>思考一下，这种情况下：整个网站的瓶颈是什么？</p>
<ol>
<li>数据量如果太大，一个机器放不下了！</li>
<li>数据的索引（ B + Tree），一个机器内存也放不下</li>
<li>访问量（读写混合），一个服务器承受不了</li>
</ol>
<p>只要你开始出现以上的三种情况之一，那么你就必须晋级！</p>
<blockquote>
<p>2、Memcached（缓存）+ MySQL + 垂直拆分（读写分离）</p>
</blockquote>
<p>网站 80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p>
<p>发展过程：优化数据结构和索引 –&gt; 文件缓存（IO）–&gt; Memcached（当时最热门的技术！）</p>
<blockquote>
<p>3、分库分表 + 水平拆分 + MySQL 集群</p>
</blockquote>
<p>技术和业务在发展的同时，对人的要求也越来越高！</p>
<p>&#x3D;&#x3D;本质：数据库（读、写）&#x3D;&#x3D;</p>
<p>早些年 MyISAM：表锁，十分影响效率！高并发下就会出现严重的锁问题</p>
<p>转战 Innodb：行锁</p>
<p>慢慢的就开始使用分库分表来解决写的压力！MySQL 在那个年代就推出了 表分区！这个并没有多少公司使用！</p>
<p>MySQL 的集群，很好的满足那个年代的需求！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210420134715.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210420134715.png" alt="img"></a></p>
<blockquote>
<p>4、最近的年代</p>
</blockquote>
<p>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql 数据库就能轻松解决这些问题。目前一个基本的互联网项目：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210420134812.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210420134812.png" alt="img"></a></p>
<blockquote>
<p>为什么要用 NoSQL！</p>
</blockquote>
<p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！这时候我们就需要使用 NoSQL 数据库的，Nosql 可以很好的处理以上的情况！</p>
<h2 id="什么是-NoSQL"><a href="#什么是-NoSQL" class="headerlink" title="什么是 NoSQL"></a>什么是 NoSQL</h2><blockquote>
<p>NoSQL</p>
</blockquote>
<p>NoSQL &#x3D; Not Only SQL（不仅仅是 SQL）</p>
<p>Not Only Structured Query Language</p>
<p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p>
<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p>
<p>NoSQL 泛指非关系型数据库，随着 web2.0 互联网的诞生，传统的关系型数据库很难对付 web2.0 时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL 在当今大数据环境下发展的十分迅速，Redis 是发展最快的。</p>
<blockquote>
<p>NoSQL 特点</p>
</blockquote>
<ol>
<li>方便扩展（数据之间没有关系，很好扩展！）</li>
<li>大数据量高性能（Redis 一秒可以写 8 万次，读 11 万次，NoSQL 的缓存记录级，是一种细粒度的缓存，性能会比较高！）</li>
<li>数据类型是多样型的！（不需要事先设计数据库，随取随用）</li>
<li>传统的 RDBMS 和 NoSQL</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASCIIDOC</span><br><span class="line">传统的 RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中 row col</span><br><span class="line">- 操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 严格的事务</span><br><span class="line">- ...</span><br><span class="line">ASCIIDOC</span><br><span class="line">NoSQL</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE</span><br><span class="line">- 高性能，高可用，高可扩</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>了解：3V+3 高</p>
</blockquote>
<ul>
<li>大数据时代的 3V ：主要是描述问题的<ul>
<li>海量 Velume</li>
<li>多样 Variety</li>
<li>实时 Velocity</li>
</ul>
</li>
<li>大数据时代的 3 高 ： 主要是对程序的要求<ul>
<li>高并发</li>
<li>高可扩</li>
<li>高性能</li>
</ul>
</li>
</ul>
<p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p>
<h2 id="NoSQL-的四大分类"><a href="#NoSQL-的四大分类" class="headerlink" title="NoSQL 的四大分类"></a>NoSQL 的四大分类</h2><p><strong>KV 键值对</strong></p>
<ul>
<li>新浪：Redis</li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + memecache</li>
</ul>
<p><strong>文档型数据库（bson 格式 和 json 一样）</strong></p>
<ul>
<li>mongoDB<ul>
<li>MongoDB 是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档！</li>
<li>MongoDB 是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB 是非关系型数据库汇总功能最丰富的，最像关系型数据库的！</li>
</ul>
</li>
<li>CouchDB</li>
</ul>
<p><strong>列存储数据库</strong></p>
<ul>
<li>HBase</li>
<li>分布式文件系统</li>
</ul>
<p><strong>图关系数据库</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210420211847.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210420211847.png" alt="image-20210420211847626"></a></p>
<ul>
<li>他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐！</li>
<li><strong>Neo4j</strong>，infoGrid</li>
</ul>
<h1 id="Redis-入门"><a href="#Redis-入门" class="headerlink" title="Redis 入门"></a>Redis 入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Redis 是什么？</p>
</blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务。</p>
<p>是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。</p>
<p>与 memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave(主从)同步。</p>
<blockquote>
<p>Redis 能干嘛？</p>
</blockquote>
<ol>
<li>内存存储、持久化，内存中是断电即失、所以说持久化很重要（RDB、AOF）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量！）</li>
<li>……</li>
</ol>
<blockquote>
<p>特性</p>
</blockquote>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
<li>…</li>
</ol>
<h2 id="环境搭建（省略）"><a href="#环境搭建（省略）" class="headerlink" title="环境搭建（省略）"></a>环境搭建（省略）</h2><p><a href="https://www.runoob.com/redis/redis-install.html">Redis 安装 | 菜鸟教程 (runoob.com)</a></p>
<h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p><strong>redis-benchmark</strong> 是一个压力测试工具！</p>
<p>官方自带的性能测试工具！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502131730.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502131730.png" alt="image-20210502131730085"></a></p>
<p>我们来简单测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 测试100个并发连接 100000个请求</span><br><span class="line">redis-benchmark localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502132313.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502132313.png" alt="image-20210502132313424"></a></p>
<p>如何查看这些分析呢？</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502132426.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502132426.png" alt="image-20210502132426480"></a></p>
<h2 id="基础的知识"><a href="#基础的知识" class="headerlink" title="基础的知识"></a>基础的知识</h2><p><strong>redis 默认有 16 个数据库</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502132621.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502132621.png" alt="image-20210502132621114"></a></p>
<p>默认使用的是第 0 个</p>
<p>可以使用<code>select</code>进行切换数据库！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; select 3 #切换数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE #查看db大小</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; set name ouwen #设置key-value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE #查看db大小</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; get name #获取value</span><br><span class="line">&quot;ouwen&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; keys * #获取所有key</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; FLUSHDB #清除当前数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379[3]&gt; FLUSHALL #清除全部数据库</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Redis 是单线程的！</p>
</blockquote>
<p><strong>Redis 到底有多快？</strong></p>
<p>Redis 采用的是基于内存的采用的是<strong>单进程单线程</strong>模型的 <strong>KV 数据库</strong>，<strong>由 C 语言编写</strong>，官方提供的数据是可以达到 100000+的 QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差！</p>
<p><strong>Redis 为什么这么快？</strong></p>
<ol>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)；</li>
<li>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>使用多路 I&#x2F;O 复用模型，非阻塞 IO；</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ol>
<p>以上几点都比较好理解，下边我们针对多路 I&#x2F;O 复用模型进行简单的探讨：</p>
<p><strong>多路 I&#x2F;O 复用模型</strong></p>
<p>多路 I&#x2F;O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I&#x2F;O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I&#x2F;O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>
<p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响 Redis 性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>
<p><strong>那么为什么 Redis 是单线程的？</strong></p>
<p>我们首先要明白，上边的种种分析，都是为了营造一个 Redis 很快的氛围！官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><blockquote>
<p>官方文档</p>
</blockquote>
<p>Redis 是一个开源（BSD 许可）的，内存中的数据结构存储系统，它可以用作&#x3D;&#x3D;数据库、缓存和消息中间 件 MQ&#x3D;&#x3D;。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合 （sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间 （geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA 脚本（Lua scripting）， LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>
<h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="https://www.runoob.com/redis/keys-del.html">DEL key</a> 该命令用于在 key 存在时删除 key。</td>
</tr>
<tr>
<td>2</td>
<td><a href="https://www.runoob.com/redis/keys-dump.html">DUMP key</a> 序列化给定 key ，并返回被序列化的值。</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/redis/keys-exists.html">EXISTS key</a> 检查给定 key 是否存在。</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.runoob.com/redis/keys-expire.html">EXPIRE key seconds</a> 为给定 key 设置过期时间，以秒计。</td>
</tr>
<tr>
<td>5</td>
<td><a href="https://www.runoob.com/redis/keys-expireat.html">EXPIREAT key timestamp</a> EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td>
</tr>
<tr>
<td>6</td>
<td><a href="https://www.runoob.com/redis/keys-pexpire.html">PEXPIRE key milliseconds</a> 设置 key 的过期时间以毫秒计。</td>
</tr>
<tr>
<td>7</td>
<td><a href="https://www.runoob.com/redis/keys-pexpireat.html">PEXPIREAT key milliseconds-timestamp</a> 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr>
<td>8</td>
<td><a href="https://www.runoob.com/redis/keys-keys.html">KEYS pattern</a> 查找所有符合给定模式( pattern)的 key 。</td>
</tr>
<tr>
<td>9</td>
<td><a href="https://www.runoob.com/redis/keys-move.html">MOVE key db</a> 将当前数据库的 key 移动到给定的数据库 db 当中。</td>
</tr>
<tr>
<td>10</td>
<td><a href="https://www.runoob.com/redis/keys-persist.html">PERSIST key</a> 移除 key 的过期时间，key 将持久保持。</td>
</tr>
<tr>
<td>11</td>
<td><a href="https://www.runoob.com/redis/keys-pttl.html">PTTL key</a> 以毫秒为单位返回 key 的剩余的过期时间。</td>
</tr>
<tr>
<td>12</td>
<td><a href="https://www.runoob.com/redis/keys-ttl.html">TTL key</a> 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td>
</tr>
<tr>
<td>13</td>
<td><a href="https://www.runoob.com/redis/keys-randomkey.html">RANDOMKEY </a>从当前数据库中随机返回一个 key 。</td>
</tr>
<tr>
<td>14</td>
<td><a href="https://www.runoob.com/redis/keys-rename.html">RENAME key newkey</a> 修改 key 的名称</td>
</tr>
<tr>
<td>15</td>
<td><a href="https://www.runoob.com/redis/keys-renamenx.html">RENAMENX key newkey</a> 仅当 newkey 不存在时，将 key 改名为 newkey 。</td>
</tr>
<tr>
<td>16</td>
<td>[SCAN cursor <a href="https://www.runoob.com/redis/keys-scan.html">MATCH pattern] [COUNT count]</a> 迭代数据库中的数据库键。</td>
</tr>
<tr>
<td>17</td>
<td><a href="https://www.runoob.com/redis/keys-type.html">TYPE key</a> 返回 key 所储存的值的类型。</td>
</tr>
</tbody></table>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="https://www.runoob.com/redis/strings-set.html">SET key value</a> 设置指定 key 的值</td>
</tr>
<tr>
<td>2</td>
<td><a href="https://www.runoob.com/redis/strings-get.html">GET key</a> 获取指定 key 的值。</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/redis/strings-getrange.html">GETRANGE key start end</a> 返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.runoob.com/redis/strings-getset.html">GETSET key value</a> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td>5</td>
<td><a href="https://www.runoob.com/redis/strings-getbit.html">GETBIT key offset</a> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>6</td>
<td>[MGET key1 <a href="https://www.runoob.com/redis/strings-mget.html">key2..]</a> 获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td>7</td>
<td><a href="https://www.runoob.com/redis/strings-setbit.html">SETBIT key offset value</a> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>8</td>
<td><a href="https://www.runoob.com/redis/strings-setex.html">SETEX key seconds value</a> 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td>9</td>
<td><a href="https://www.runoob.com/redis/strings-setnx.html">SETNX key value</a> 只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td>10</td>
<td><a href="https://www.runoob.com/redis/strings-setrange.html">SETRANGE key offset value</a> 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td>11</td>
<td><a href="https://www.runoob.com/redis/strings-strlen.html">STRLEN key</a> 返回 key 所储存的字符串值的长度。</td>
</tr>
<tr>
<td>12</td>
<td>[MSET key value <a href="https://www.runoob.com/redis/strings-mset.html">key value …]</a> 同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td>13</td>
<td>[MSETNX key value<a href="https://www.runoob.com/redis/strings-msetnx.html">key value …]</a> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td>14</td>
<td><a href="https://www.runoob.com/redis/strings-psetex.html">PSETEX key milliseconds value</a> 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td>15</td>
<td><a href="https://www.runoob.com/redis/strings-incr.html">INCR key</a> 将 key 中储存的数字值增一。</td>
</tr>
<tr>
<td>16</td>
<td><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a> 将 key 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td>17</td>
<td><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a> 将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td>18</td>
<td><a href="https://www.runoob.com/redis/strings-decr.html">DECR key</a> 将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td>19</td>
<td><a href="https://www.runoob.com/redis/strings-decrby.html">DECRBY key decrement</a> key 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td>20</td>
<td><a href="https://www.runoob.com/redis/strings-append.html">APPEND key value</a> 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line">127.0.0.1:6379&gt; set key1 v1 # 设置值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1 # 获得值</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys * # 获得所有的key</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">127.0.0.1:6379&gt; EXISTS key1 # 判断某一个key是否存在</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 &quot;hello&quot; # 追加字符串，如果当前key不存在，就相当于setkey</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;v1hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1 # 获取字符串的长度！</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 &quot;,kaungshen&quot;</span><br><span class="line">(integer) 17</span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1</span><br><span class="line">(integer) 17</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;v1hello,kaungshen&quot;</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line"># i++</span><br><span class="line"># 步长 i+=</span><br><span class="line">127.0.0.1:6379&gt; set views 0 # 初始浏览量为0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr views # 自增1 浏览量变为1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr views # 自减1 浏览量-1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; INCRBY views 10 # 可以设置步长，指定增量！</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; INCRBY views 10</span><br><span class="line">(integer) 19</span><br><span class="line">127.0.0.1:6379&gt; DECRBY views 5</span><br><span class="line">bilibili：狂神说Java(integer) 14</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line"># 字符串范围 range</span><br><span class="line">127.0.0.1:6379&gt; set key1 &quot;hello,kuangshen&quot; # 设置 key1 的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;hello,kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 3 # 截取字符串 [0,3]</span><br><span class="line">&quot;hell&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的</span><br><span class="line">&quot;hello,kuangshen&quot;</span><br><span class="line"># 替换！</span><br><span class="line">127.0.0.1:6379&gt; set key2 abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;abcdefg&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换指定位置开始的字符串！</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;axxdefg&quot;</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line"># setex (set with expire) # 设置过期时间</span><br><span class="line"># setnx (set if not exist) # 不存在在设置 （在分布式锁中会常常使用！）</span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot; # 设置key3 的值为 hello,30秒后过期</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) 26</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果mykey 不存在，创建mykey</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key2&quot;</span><br><span class="line">2) &quot;mykey&quot;</span><br><span class="line">3) &quot;key1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot; # 如果mykey存在，创建失败！</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line">&quot;redis&quot;</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line">mset</span><br><span class="line">mget</span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line">3) &quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获取多个值</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">bilibili：狂神说Java数据结构是相同的！</span><br><span class="line">String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</span><br><span class="line">计数器</span><br><span class="line">统计多单位的数量</span><br><span class="line">粉丝数</span><br><span class="line">对象缓存存储！</span><br><span class="line">List（列表）</span><br><span class="line">基本的数据类型，列表</span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起</span><br><span class="line">失败！</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br><span class="line"># 对象</span><br><span class="line">set user:1 &#123;name:zhangsan,age:3&#125; # 设置一个user:1 对象 值为 json字符来保存一个对象！</span><br><span class="line"># 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line">getset # 先get然后在set</span><br><span class="line">127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回 nil</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;redis</span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb # 如果存在值，获取原来的值，并设置新的值</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;mongodb&quot;</span><br></pre></td></tr></table></figure>

<p>数据结构是相同的！</p>
<p>String 类似的使用场景：value 除了是我们的字符串还可以是我们的数字！</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量</li>
<li>粉丝数</li>
<li>对象缓存存储！</li>
</ul>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过 40 亿个元素)。</p>
<p>基本的数据类型，列表</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502143650.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502143650.png" alt="image-20210502143650744"></a></p>
<p>在 redis 里面，我们可以把 list 玩成 ，栈、队列、阻塞队列！</p>
<p>所有的 list 命令都是用 l 开头的，Redis 不区分大小命令</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[BLPOP key1 <a href="https://www.runoob.com/redis/lists-blpop.html">key2] timeout</a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>2</td>
<td>[BRPOP key1 <a href="https://www.runoob.com/redis/lists-brpop.html">key2] timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a> 通过索引获取列表中的元素</td>
</tr>
<tr>
<td>5</td>
<td><a href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>6</td>
<td><a href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a> 获取列表长度</td>
</tr>
<tr>
<td>7</td>
<td><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a> 移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>8</td>
<td>[LPUSH key value1 <a href="https://www.runoob.com/redis/lists-lpush.html">value2]</a> 将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>9</td>
<td><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>10</td>
<td><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a> 获取列表指定范围内的元素</td>
</tr>
<tr>
<td>11</td>
<td><a href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a> 移除列表元素</td>
</tr>
<tr>
<td>12</td>
<td><a href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a> 通过索引设置列表元素的值</td>
</tr>
<tr>
<td>13</td>
<td><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>14</td>
<td><a href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a> 移除列表的最后一个元素，返回值为移除的元素。</td>
</tr>
<tr>
<td>15</td>
<td><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>16</td>
<td>[RPUSH key value1 <a href="https://www.runoob.com/redis/lists-rpush.html">value2]</a> 在列表中添加一个或多个值</td>
</tr>
<tr>
<td>17</td>
<td><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a> 为已存在的列表添加值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one # 将一个值或者多个值，插入到列表头部 （左）</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1 # 获取list中值！</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1 # 通过区间获取具体的值！</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">127.0.0.1:6379&gt; Rpush list righr # 将一个值或者多个值，插入到列表位部 （右）</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;righr&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">LPOP</span><br><span class="line">RPOP</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;righr&quot;</span><br><span class="line">127.0.0.1:6379&gt; Lpop list # 移除list的第一个元素</span><br><span class="line">&quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; Rpop list # 移除list的最后一个元素</span><br><span class="line">&quot;righr&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">Lindex</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 1 # 通过下标获得 list 中的某一个值！</span><br><span class="line">&quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line">&quot;two&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">Llen</span><br><span class="line">127.0.0.1:6379&gt; Lpush list one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; Lpush list two</span><br><span class="line">bilibili：狂神说Java(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; Lpush list three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; Llen list # 返回列表的长度</span><br><span class="line">(integer) 3</span><br><span class="line">##########################################################################</span><br><span class="line">移除指定的值！</span><br><span class="line">取关 uid</span><br><span class="line">Lrem</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;three&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 one # 移除list集合中指定个数的value，精确匹配</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;three&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 three</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">127.0.0.1:6379&gt; Lpush list three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 three</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">trim 修剪。； list 截断!</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist &quot;hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist &quot;hello1&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist &quot;hello2&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist &quot;hello3&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了</span><br><span class="line">只剩下截取的元素！</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;hello1&quot;</span><br><span class="line">2) &quot;hello2&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中！</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;</span><br><span class="line">bilibili：狂神说Java小结</span><br><span class="line">他实际上是一个链表，before Node after ， left，right 都可以插入值</span><br><span class="line">如果key 不存在，创建新的链表</span><br><span class="line">如果key存在，新增内容</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist &quot;hello1&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist &quot;hello2&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的</span><br><span class="line">列表中！</span><br><span class="line">&quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1 # 查看原来的列表</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！</span><br><span class="line">1) &quot;hello2&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">lset 将列表中指定下标的值替换为另外一个值，更新操作</span><br><span class="line">127.0.0.1:6379&gt; EXISTS list # 判断这个列表是否存在</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item # 如果不存在列表我们去更新就会报错</span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 0</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item # 如果存在，更新当前下标的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 0</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list 1 other # 如果不存在，则会报错！</span><br><span class="line">(error) ERR index out of range</span><br><span class="line">##########################################################################</span><br><span class="line">linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面！</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist &quot;hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist &quot;world&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist before &quot;world&quot; &quot;other&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;other&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after world new</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;other&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">4) &quot;new&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>它实际上是一个链表，before Node after ，left right 都可以插入值</li>
<li>如果 key 不存在，创建新的链表</li>
<li>如果 key 存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在！</li>
<li>在两边插入或者改动值，效率最高！中间元素，相对来说效率会低一点~</li>
<li>消息排队！消息队列（LPUSH RPOP），栈（LPUSH LPOP）</li>
</ul>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>set 中的值是不能重复的！</p>
<p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储 40 多亿个成员)。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[SADD key member1 <a href="https://www.runoob.com/redis/sets-sadd.html">member2]</a> 向集合添加一个或多个成员</td>
</tr>
<tr>
<td>2</td>
<td><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a> 获取集合的成员数</td>
</tr>
<tr>
<td>3</td>
<td>[SDIFF key1 <a href="https://www.runoob.com/redis/sets-sdiff.html">key2]</a> 返回第一个集合与其他集合之间的差异。</td>
</tr>
<tr>
<td>4</td>
<td>[SDIFFSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sdiffstore.html">key2]</a> 返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td>5</td>
<td>[SINTER key1 <a href="https://www.runoob.com/redis/sets-sinter.html">key2]</a> 返回给定所有集合的交集</td>
</tr>
<tr>
<td>6</td>
<td>[SINTERSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sinterstore.html">key2]</a> 返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td>7</td>
<td><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td>8</td>
<td><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a> 返回集合中的所有成员</td>
</tr>
<tr>
<td>9</td>
<td><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td>10</td>
<td><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a> 移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td>11</td>
<td>[SRANDMEMBER key <a href="https://www.runoob.com/redis/sets-srandmember.html">count]</a> 返回集合中一个或多个随机数</td>
</tr>
<tr>
<td>12</td>
<td>[SREM key member1 <a href="https://www.runoob.com/redis/sets-srem.html">member2]</a> 移除集合中一个或多个成员</td>
</tr>
<tr>
<td>13</td>
<td>[SUNION key1 <a href="https://www.runoob.com/redis/sets-sunion.html">key2]</a> 返回所有给定集合的并集</td>
</tr>
<tr>
<td>14</td>
<td>[SUNIONSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sunionstore.html">key2]</a> 所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td>15</td>
<td>[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;hello&quot; # set集合中添加匀速</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;lovekuangshen&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset # 查看指定set的所有值</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;lovekuangshen&quot;</span><br><span class="line">3) &quot;kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hello # 判断某一个值是不是在set集合中！</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset world</span><br><span class="line">(integer) 0</span><br><span class="line">##########################################################################</span><br><span class="line">127.0.0.1:6379&gt; scard myset # 获取set集合中的内容元素个数！</span><br><span class="line">(integer) 4</span><br><span class="line">##########################################################################</span><br><span class="line">rem</span><br><span class="line">127.0.0.1:6379&gt; srem myset hello # 移除set集合中的指定元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;lovekuangshen2&quot;</span><br><span class="line">2) &quot;lovekuangshen&quot;</span><br><span class="line">3) &quot;kuangshen&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">set 无序不重复集合。抽随机！</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;lovekuangshen2&quot;</span><br><span class="line">2) &quot;lovekuangshen&quot;</span><br><span class="line">3) &quot;kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽选出一个元素</span><br><span class="line">&quot;kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line">&quot;kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line">&quot;kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line">&quot;kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2 # 随机抽选出指定个数的元素</span><br><span class="line">bilibili：狂神说Java1) &quot;lovekuangshen&quot;</span><br><span class="line">2) &quot;lovekuangshen2&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class="line">1) &quot;lovekuangshen&quot;</span><br><span class="line">2) &quot;lovekuangshen2&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽选出一个元素</span><br><span class="line">&quot;lovekuangshen2&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">删除定的key，随机删除key！</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;lovekuangshen2&quot;</span><br><span class="line">2) &quot;lovekuangshen&quot;</span><br><span class="line">3) &quot;kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset # 随机删除一些set集合中的元素！</span><br><span class="line">&quot;lovekuangshen2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line">&quot;lovekuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;kuangshen&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">将一个指定的值，移动到另外一个set集合！</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;world&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 &quot;set2&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 &quot;kuangshen&quot; # 将一个指定的值，移动到另外一个set集</span><br><span class="line">合！</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) &quot;kuangshen&quot;</span><br><span class="line">2) &quot;set2&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">微博，B站，共同关注！(并集)</span><br><span class="line">数字集合类：</span><br><span class="line">- 差集 SDIFF</span><br><span class="line">- 交集</span><br><span class="line">- 并集</span><br><span class="line">127.0.0.1:6379&gt; SDIFF key1 key2 # 差集</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; SINTER key1 key2 # 交集 共同好友就可以这样实现</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2 # 并集</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;e&quot;</span><br><span class="line">4) &quot;a&quot;</span><br><span class="line">5) &quot;d&quot;</span><br></pre></td></tr></table></figure>

<p>bilibili：狂神说 Java 微博，A 用户将所有关注的人放在一个 set 集合中！将它的粉丝也放在一个集合中！<br>共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）</p>
<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 232 - 1 键值对（40 多亿）。</p>
<p>Map 集合，key-map! 时候这个值是一个 map 集合！ 本质和 String 类型没有太大区别，还是一个简单的 key-vlaue！</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[HDEL key field1 <a href="https://www.runoob.com/redis/hashes-hdel.html">field2]</a> 删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>2</td>
<td><a href="https://www.runoob.com/redis/hashes-hexists.html">HEXISTS key field</a> 查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/redis/hashes-hget.html">HGET key field</a> 获取存储在哈希表中指定字段的值。</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a> 获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>5</td>
<td><a href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY key field increment</a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td>6</td>
<td><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td>7</td>
<td><a href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS key</a> 获取所有哈希表中的字段</td>
</tr>
<tr>
<td>8</td>
<td><a href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a> 获取哈希表中字段的数量</td>
</tr>
<tr>
<td>9</td>
<td>[HMGET key field1 <a href="https://www.runoob.com/redis/hashes-hmget.html">field2]</a> 获取所有给定字段的值</td>
</tr>
<tr>
<td>10</td>
<td>[HMSET key field1 value1 <a href="https://www.runoob.com/redis/hashes-hmset.html">field2 value2 ]</a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td>11</td>
<td><a href="https://www.runoob.com/redis/hashes-hset.html">HSET key field value</a> 将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td>12</td>
<td><a href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX key field value</a> 只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td>13</td>
<td><a href="https://www.runoob.com/redis/hashes-hvals.html">HVALS key</a> 获取哈希表中所有值。</td>
</tr>
<tr>
<td>14</td>
<td>[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html">MATCH pattern] [COUNT count]</a> 迭代哈希表中的键值对。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line">127.0.0.1:6379&gt; hset myhash field1 kuangshen # set一个具体 key-vlaue</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1 # 获取一个字段值</span><br><span class="line">&quot;kuangshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world # set多个 key-vlaue</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2 # 获取多个字段值</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash # 获取全部的数据，</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;field2&quot;</span><br><span class="line">4) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field1 # 删除hash指定key字段！对应的value值也就消失了！</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">hlen</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;field1&quot;</span><br><span class="line">4) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash # 获取hash表的字段数量！</span><br><span class="line">(integer) 2</span><br><span class="line">##########################################################################</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field1 # 判断hash中指定字段是否存在！</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field3</span><br><span class="line">(integer) 0</span><br><span class="line">##########################################################################</span><br><span class="line"># 只获得所有field</span><br><span class="line"># 只获得所有value</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash # 只获得所有field</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">2) &quot;field1&quot;</span><br><span class="line">bilibili：狂神说Javahash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的</span><br><span class="line">存储，String更加适合字符串存储！</span><br><span class="line">Zset（有序集合）</span><br><span class="line">在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash # 只获得所有value</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">incr decr</span><br><span class="line">127.0.0.1:6379&gt; hset myhash field3 5 #指定增量！</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field3 1</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field3 -1</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 hello # 如果不存在则可以设置</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 world # 如果存在则不能设置</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>hash 变更的数据 user name age，尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的 存储，String 更加适合字符串存储！</p>
<h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储 40 多亿个成员)。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[ZADD key score1 member1 <a href="https://www.runoob.com/redis/sorted-sets-zadd.html">score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>2</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a> 获取有序集合的成员数</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>5</td>
<td>[ZINTERSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">key …]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td>
</tr>
<tr>
<td>6</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>7</td>
<td>[ZRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrange.html">WITHSCORES]</a> 通过索引区间返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>8</td>
<td>[ZRANGEBYLEX key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">LIMIT offset count]</a> 通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>9</td>
<td>[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT]</a> 通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>10</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a> 返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>11</td>
<td>[ZREM key member <a href="https://www.runoob.com/redis/sorted-sets-zrem.html">member …]</a> 移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>12</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>13</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>14</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>15</td>
<td>[ZREVRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</td>
</tr>
<tr>
<td>16</td>
<td>[ZREVRANGEBYSCORE key max min <a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">WITHSCORES]</a> 返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>17</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>18</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a> 返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>19</td>
<td>[ZUNIONSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">key …]</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>20</td>
<td>[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 one # 添加一个值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three # 添加多个值</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">##########################################################################</span><br><span class="line">排序如何实现</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaohong # 添加三个用户</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 kaungshen</span><br><span class="line">(integer) 1</span><br><span class="line"># ZRANGEBYSCORE key min max</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf # 显示全部的用户 从小到大！</span><br><span class="line">1) &quot;kaungshen&quot;</span><br><span class="line">2) &quot;xiaohong&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 # 从大到进行排序！</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;kaungshen&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成</span><br><span class="line">绩</span><br><span class="line">1) &quot;kaungshen&quot;</span><br><span class="line">2) &quot;500&quot;</span><br><span class="line">3) &quot;xiaohong&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;zhangsan&quot;</span><br><span class="line">6) &quot;5000&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于2500员工的升</span><br><span class="line">序排序！</span><br><span class="line">1) &quot;kaungshen&quot;</span><br><span class="line">2) &quot;500&quot;</span><br><span class="line">3) &quot;xiaohong&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">##########################################################################</span><br><span class="line"># 移除rem中的元素</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;kaungshen&quot;</span><br><span class="line">2) &quot;xiaohong&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem salary xiaohong # 移除有序集合中的指定元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;kaungshen&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcard salary # 获取有序集合中的个数</span><br><span class="line">(integer) 2</span><br><span class="line">##########################################################################</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 world 3 kuangshen</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3 # 获取指定区间的成员数量！</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>其与的一些 API，通过我们的学习吗，你们剩下的如果工作中有需要，这个时候你可以去查查看官方文 档！</p>
<p>案例思路：set 排序 存储班级成绩表，工资表排序！</p>
<p>普通消息，1， 重要消息 2，带权重进行判断！</p>
<p>排行榜应用实现，取 Top N 测试！</p>
<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h2><p>朋友的定位，附近的人，打车距离计算？</p>
<p>Redis 的 Geo 在 Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆 几里的人！</p>
<p>可以查询一些测试数据：<a href="http://www.jsons.cn/lngcode/">城市经纬度查询-国内城市经度纬度在线查询工具 (jsons.cn)</a></p>
<p>Redis GEO 操作方法有：</p>
<ul>
<li>geoadd：添加地理位置的坐标。</li>
<li>geopos：获取地理位置的坐标。</li>
<li>geodist：计算两个位置之间的距离。</li>
<li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li>
<li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li>
<li>geohash：返回一个或多个位置对象的 geohash 值。</li>
</ul>
<blockquote>
<p>geoadd</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># getadd 添加地理位置</span><br><span class="line"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</span><br><span class="line"># 有效的经度从-180度到180度。</span><br><span class="line"># 有效的纬度从-85.05112878度到85.05112878度。</span><br><span class="line"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span><br><span class="line"># 127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin</span><br><span class="line">(error) ERR invalid longitude,latitude pair 39.900000,116.400000</span><br><span class="line"># 参数 key 值（）</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>geopos</p>
</blockquote>
<p>获得当前定位：一定是一个坐标值！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing # 获取指定的城市的经度和纬度！</span><br><span class="line">1) 1) &quot;116.39999896287918091&quot;</span><br><span class="line">2) &quot;39.90000009167092543&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing chongqi</span><br><span class="line">1) 1) &quot;116.39999896287918091&quot;</span><br><span class="line">2) &quot;39.90000009167092543&quot;</span><br><span class="line">2) 1) &quot;106.49999767541885376&quot;</span><br><span class="line">2) &quot;29.52999957900659211&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEODIST</p>
</blockquote>
<p>两人之间的距离！</p>
<p>单位：</p>
<ul>
<li>m 表示单位为米</li>
<li>km 表示单位为千米</li>
<li>mi 表示单位为英里</li>
<li>ft 表示单位为英尺</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km # 查看上海到北京的直线距离</span><br><span class="line">&quot;1067.3788&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing chongqi km # 查看重庆到北京的直线距离</span><br><span class="line">&quot;1464.0708&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadius 以给定的经纬度为中心， 找出某一半径内的元素</p>
</blockquote>
<p>我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！</p>
<p>获得指定数量的人，200</p>
<p>所有数据应该都录入：china:city ，才会让结果更加清晰！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻</span><br><span class="line">找方圆1000km内的城市</span><br><span class="line">1) &quot;chongqi&quot;</span><br><span class="line">2) &quot;xian&quot;</span><br><span class="line">3) &quot;shengzhen&quot;</span><br><span class="line">4) &quot;hangzhou&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km</span><br><span class="line">1) &quot;chongqi&quot;</span><br><span class="line">2) &quot;xian&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist # 显示到中间距离的位置</span><br><span class="line">1) 1) &quot;chongqi&quot;</span><br><span class="line">   2) &quot;341.9374&quot;</span><br><span class="line">2) 1) &quot;xian&quot;</span><br><span class="line">   2) &quot;483.8340&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息</span><br><span class="line">1) 1) &quot;chongqi&quot;</span><br><span class="line">   2) 1) &quot;106.49999767541885376&quot;</span><br><span class="line">      2) &quot;29.52999957900659211&quot;</span><br><span class="line">2) 1) &quot;xian&quot;</span><br><span class="line">   2) 1) &quot;108.96000176668167114&quot;</span><br><span class="line">      2) &quot;34.25999964418929977&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 1 #</span><br><span class="line">筛选出指定的结果！</span><br><span class="line">1) 1) &quot;chongqi&quot;</span><br><span class="line">   2) &quot;341.9374&quot;</span><br><span class="line">   3) 1) &quot;106.49999767541885376&quot;</span><br><span class="line">      2) &quot;29.52999957900659211&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 2</span><br><span class="line">1) 1) &quot;chongqi&quot;</span><br><span class="line">   2) &quot;341.9374&quot;</span><br><span class="line">   3) 1) &quot;106.49999767541885376&quot;</span><br><span class="line">      2) &quot;29.52999957900659211&quot;</span><br><span class="line">2) 1) &quot;xian&quot;</span><br><span class="line">   2) &quot;483.8340&quot;</span><br><span class="line">   3) 1) &quot;108.96000176668167114&quot;</span><br><span class="line">      2) &quot;34.25999964418929977&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEORADIUSBYMEMBER</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 找出位于指定元素周围的其他元素！</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km</span><br><span class="line">1) &quot;beijing&quot;</span><br><span class="line">2) &quot;xian&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km</span><br><span class="line">1) &quot;hangzhou&quot;</span><br><span class="line">2) &quot;shanghai&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示</p>
</blockquote>
<p>该命令将返回 11 个字符的 Geohash 字符串~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing chongqi</span><br><span class="line">1) &quot;wx4fbxxfke0&quot;</span><br><span class="line">2) &quot;wm5xzrybty0&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEO 底层的实现原理其实就是 Zset！我们可以使用过 Zset 命令来操作 geo！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 # 查看地图中全部的元素</span><br><span class="line">1) &quot;chongqi&quot;</span><br><span class="line">2) &quot;xian&quot;</span><br><span class="line">3) &quot;shengzhen&quot;</span><br><span class="line">4) &quot;hangzhou&quot;</span><br><span class="line">5) &quot;shanghai&quot;</span><br><span class="line">6) &quot;beijing&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing # 移除指定元素！</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE china:city 0 -1</span><br><span class="line">1) &quot;chongqi&quot;</span><br><span class="line">2) &quot;xian&quot;</span><br><span class="line">3) &quot;shengzhen&quot;</span><br><span class="line">4) &quot;hangzhou&quot;</span><br><span class="line">5) &quot;shanghai&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<blockquote>
<p>什么是基数？</p>
</blockquote>
<p>A {1,3,5,7,8,7}</p>
<p>B{1,3,5,7,8}</p>
<p>基数（不重复的元素） &#x3D; 5，可以接受误差！</p>
<p>优点：占用的内存是固定，2^64 不同的元素的基数，只需要废 12KB 内存！如果要从内存角度来比较的 话 Hyperloglog 首选！</p>
<p><strong>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</strong></p>
<p>传统的方式， set 保存用户的 id，然后就可以统计 set 中的元素数量作为标准判断 !</p>
<p>这个方式如果保存大量的用户 id，就会比较麻烦！我们的目的是为了计数，而不是保存用户 id；</p>
<p>0.81% 错误率！ 统计 UV 任务，可以忽略不计的！</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[PFADD key element <a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">element …]</a> 添加指定元素到 HyperLogLog 中。</td>
</tr>
<tr>
<td>2</td>
<td>[PFCOUNT key <a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">key …]</a> 返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td>3</td>
<td>[PFMERGE destkey sourcekey <a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">sourcekey …]</a> 将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody></table>
<blockquote>
<p>测试使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey # 统计 mykey 元素的基数数量</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey2</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey3 # 看并集的数量！</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>

<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>为什么其他教程都不喜欢讲这些？这些在生活中或者开发中，都有十分多的应用场景，学习了，就是就 是多一个思路！</p>
<p>技多不压身！</p>
<blockquote>
<p>位储存</p>
</blockquote>
<p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365 打卡！ 两个状态的，都可以使用 Bitmaps！</p>
<p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有 0 和 1 两个状态！</p>
<p>365 天 &#x3D; 365 bit 1 字节 &#x3D; 8bit 46 个字节左右！</p>
<blockquote>
<p>测试</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502234526.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502234526.png" alt="image-20210502234525977"></a></p>
<p>使用 bitmap 来记录 周一到周日的打卡！</p>
<p>周一：1 周二：0 周三：0 周四：1 ……</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502234703.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502234703.png" alt="image-20210502234703108"></a></p>
<p>查看某一天是否有打卡！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按 照顺序执行！</p>
<p>一次性、顺序性、排他性！执行一系列的命令！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------ 队列 set set set 执行------</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;Redis 事务没有没有隔离级别的概念！&#x3D;&#x3D;</p>
<p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec</p>
<p>&#x3D;&#x3D;Redis 单条命令式保存原子性的，但是事务不保证原子性！&#x3D;&#x3D;</p>
<p>redis 的事务：</p>
<ul>
<li>开启事务（multi）</li>
<li>命令入队（……）</li>
<li>执行事务（exec）</li>
</ul>
<blockquote>
<p>正常执行事务！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi # 开启事务</span><br><span class="line">OK</span><br><span class="line"># 命令入队</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec # 执行事务</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>放弃事务</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; multi # 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD # 取消事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4 # 事务队列中命令都不会被执行！</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译型异常（代码有问题！命令有错！），事务中所有的命令都不会执行！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k3 # 错误的命令</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;getset&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec # 执行事务报错！</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k5 # 所有的命令都不会被执行！</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行时异常（1&#x2F;0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行 的，错误命令抛出异常！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set k1 &quot;v1&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k1 # 会执行的时候失败！</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;v3&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>监控！ Watch （面试常问！）</p>
</blockquote>
<p>悲观锁：</p>
<ul>
<li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</li>
</ul>
<p>乐观锁：</p>
<ul>
<li>很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否 有人修改过这个数据</li>
<li>获取 version</li>
<li>更新的时候比较 version</li>
</ul>
<blockquote>
<p>Redis 监视测试</p>
</blockquote>
<p>正常执行成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money # 监视 money 对象</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br></pre></td></tr></table></figure>

<p>测试多线程修改值 , 使用 watch 可以当做 redis 的乐观锁操作！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; watch money # 监视 money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>如果修改失败，获取最新的值就好</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503001012.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503001012.png" alt="image-20210503001012808"></a></p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>我们要使用 Java 来操作 Redis，知其然并知其所以然，授人以渔！ 学习不能急躁，慢慢来会很快！</p>
<blockquote>
<p>什么是 Jedis 是 Redis 官方推荐的 java 连接开发工具！ 使用 Java 操作 Redis 中间件！如果你要使用 java 操作 redis，那么一定要对 jedis 十分熟悉！</p>
</blockquote>
<blockquote>
<p>测试</p>
</blockquote>
<p>1、导入对应的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line"></span><br><span class="line">&lt;!--导入jedis的包--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--fastjson--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>2、编码测试</p>
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-05-03 0:20</span><br><span class="line"> */</span><br><span class="line">public class TestPing &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 1、 new Jedis 对象即可</span><br><span class="line">        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);</span><br><span class="line">        jedis.auth(&quot;123456&quot;);</span><br><span class="line">        // 2、jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503002524.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503002524.png" alt="image-20210503002523989"></a></p>
<h2 id="常用的-API"><a href="#常用的-API" class="headerlink" title="常用的 API"></a>常用的 API</h2><ul>
<li>string</li>
<li>list</li>
<li>set</li>
<li>hash</li>
<li>zset</li>
<li>geo</li>
<li>bitmap</li>
<li>hyperloglog</li>
</ul>
<blockquote>
<p>所有的 api 命令，就是我们对应的上面学习的指令，一个都没有变化！</p>
</blockquote>
<blockquote>
<p>事务</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-05-03 0:31</span><br><span class="line"> */</span><br><span class="line">public class TestTX &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 1、 new Jedis 对象即可</span><br><span class="line">        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);</span><br><span class="line">        jedis.auth(&quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line"></span><br><span class="line">        JSONObject jsonObject = new JSONObject();</span><br><span class="line">        jsonObject.put(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line">        jsonObject.put(&quot;name&quot;,&quot;ouwen&quot;);</span><br><span class="line"></span><br><span class="line">        //开启事务</span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            multi.set(&quot;user1&quot;,result);</span><br><span class="line">            int i = 1/0;</span><br><span class="line">            multi.set(&quot;user2&quot;,result);</span><br><span class="line">            //执行事务</span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //放弃事务</span><br><span class="line">            multi.discard();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(jedis.get(&quot;user1&quot;));</span><br><span class="line">            System.out.println(jedis.get(&quot;user2&quot;));</span><br><span class="line">            //关闭连接</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SpringBoot-整合"><a href="#SpringBoot-整合" class="headerlink" title="SpringBoot 整合"></a>SpringBoot 整合</h1><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p>
<p>SpringData 也是和 SpringBoot 齐名的项目！</p>
<p>说明： 在 SpringBoot2.x 之后，原来使用的 jedis 被替换为了 lettuce?</p>
<p>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接 池！ 更像 BIO 模式</p>
<p>lettuce : 采用 netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据 了，更像 NIO 模式</p>
<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) // 我们可以自己定义一个</span><br><span class="line">redisTemplate来替换这个默认的！</span><br><span class="line">public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)</span><br><span class="line">    throws UnknownHostException &#123;</span><br><span class="line">    // 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span><br><span class="line">    // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    return template;</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean // 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span><br><span class="line">public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)</span><br><span class="line">	throws UnknownHostException &#123;</span><br><span class="line">    StringRedisTemplate template = new StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    return template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>整合测试一下</p>
</blockquote>
<p>1、导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、配置连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML</span><br><span class="line">spring:</span><br><span class="line">    redis:</span><br><span class="line">        host: 127.0.0.1</span><br><span class="line">        port: 6379</span><br><span class="line">        password: 123456</span><br></pre></td></tr></table></figure>

<p>3、测试！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.luojunjie;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class Redis02SpringbootApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        // redisTemplate 操作不同的类型，api和我们的指令是一样的</span><br><span class="line">        // opsForValue 操作字符串 类似string</span><br><span class="line">        // opsForList</span><br><span class="line">        // opsForSet</span><br><span class="line">        // opsForZSet</span><br><span class="line">        // opsForHash</span><br><span class="line">        // opsForGeo</span><br><span class="line">        // opsForHyperLogLog</span><br><span class="line">        //redisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">        //除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span><br><span class="line"></span><br><span class="line">        // 获取redis连接对象</span><br><span class="line">        //RedisConnection conn = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        //conn.flushAll();</span><br><span class="line">        //conn.flushDb();</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;湖南长沙&quot;);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503102342.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503102342.png" alt="image-20210503102342174"></a></p>
<p>我们来编写一个自己的 RedisTemplete</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">package com.luojunjie.config;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line">import com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author IRVING</span><br><span class="line"> * @create 2021-05-03 10:24</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    // 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！</span><br><span class="line">    // 自己定义了一个 RedisTemplate</span><br><span class="line">    @Bean</span><br><span class="line">    @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory</span><br><span class="line">                                                               factory) &#123;</span><br><span class="line">        // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String,</span><br><span class="line">                Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        // Json序列化配置</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new</span><br><span class="line">                Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        // String 的序列化</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = new</span><br><span class="line">                StringRedisSerializer();</span><br><span class="line">        // key采用String的序列化方式</span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        // hash的key也采用String的序列化方式</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        // value序列化方式采用jackson</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        // hash的value序列化方式采用jackson</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 redis 操作，其实对于 java 开发人员来说，十分的简单，更重要是要去理解 redis 的思想和每一种数 据结构的用处和作用场景！</p>
<h1 id="Redis-conf-详解"><a href="#Redis-conf-详解" class="headerlink" title="Redis.conf 详解"></a>Redis.conf 详解</h1><p>启动的时候，就通过配置文件来启动！</p>
<p>工作中，一些小小的配置，可以让你脱颖而出！</p>
<blockquote>
<p>单位</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503105120.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503105120.png" alt="image-20210503105120545"></a></p>
<p>配置文件对大小写不敏感！</p>
<blockquote>
<p>包含</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503105216.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503105216.png" alt="image-20210503105216614"></a></p>
<p>就是好比我们学习 Spring、Improt， include</p>
<blockquote>
<p>网络</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">bind 127.0.0.1 # 绑定的ip</span><br><span class="line">protected-mode yes # 保护模式</span><br><span class="line">port 6379 # 端口设置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通用 GENERAL</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">daemonize yes # 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！</span><br><span class="line">pidfile /var/run/redis_6379.pid # 如果以后台的方式运行，我们就需要指定一个 pid 文件！</span><br><span class="line"># 日志</span><br><span class="line"># Specify the server verbosity level.</span><br><span class="line"># This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development/testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably) 生产环境</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;&quot; # 日志的文件位置名</span><br><span class="line">databases 16 # 数据库的数量，默认是 16 个数据库</span><br><span class="line">always-show-logo yes # 是否总是显示LOGO</span><br></pre></td></tr></table></figure>

<blockquote>
<p>快照</p>
</blockquote>
<p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof</p>
<p>redis 是内存数据库，如果没有持久化，那么数据断电就会丢失！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span><br><span class="line">save 900 1</span><br><span class="line"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span><br><span class="line">save 300 10</span><br><span class="line"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span><br><span class="line">save 60 10000</span><br><span class="line"># 我们之后学习持久化，会自己定义这个测试！</span><br><span class="line">stop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作！</span><br><span class="line">rdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！</span><br><span class="line">rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！</span><br><span class="line">dir ./ # rdb 文件保存的目录！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SECURITY 安全</p>
</blockquote>
<p>可以设置 redis 密码，默认是没有密码的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass # 获取redis的密码</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录！</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;123456&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>限制 CLIENTS</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">maxclients 10000 # 设置能连接上redis的最大客户端的数量</span><br><span class="line"></span><br><span class="line">maxmemory &lt;bytes&gt; # redis 配置最大的内存容量</span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction # 内存到达上限之后的处理策略</span><br><span class="line">    1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）</span><br><span class="line">    2、allkeys-lru ： 删除lru算法的key</span><br><span class="line">    3、volatile-random：随机删除即将过期key</span><br><span class="line">    4、allkeys-random：随机删除</span><br><span class="line">    5、volatile-ttl ： 删除即将过期的</span><br><span class="line">    6、noeviction ： 永不过期，返回错误</span><br></pre></td></tr></table></figure>

<blockquote>
<p>APPEND ONLY 模式 aof 配置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字</span><br><span class="line"></span><br><span class="line"># appendfsync always # 每次修改都会 sync。消耗性能</span><br><span class="line">appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！</span><br><span class="line"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span><br></pre></td></tr></table></figure>

<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>面试和工作，持久化都是重点！</p>
<p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘 ，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p>
<h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote>
<p>什么是 RDB？</p>
</blockquote>
<p>在主从复制中，rdb 就是备用了，放在从机上。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503143056.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503143056.png" alt="image-20210503143056239"></a></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot 快照，它恢复时是将快 照文件直接读到内存里。</p>
<p>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程 都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何 IO 操作的。 这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。我们默认的就是 RDB，一般情况下不需要修改这个配置！</p>
<p>&#x3D;&#x3D;rdb 保存的文件是 dump.rdb&#x3D;&#x3D; 都是在我们的配置文件中快照中进行配置的！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503143817.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503143817.png" alt="image-20210503143817471"></a></p>
<blockquote>
<p>触发机制</p>
</blockquote>
<p>1、save 的规则满足的情况下，会自动触发 rdb 规则</p>
<p>2、执行 flushall 命令，也会触发我们的 rdb 规则！</p>
<p>3、退出 redis，也会产生 rdb 文件！ 备份就自动生成一个 dump.rdb</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503143857.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503143857.png" alt="image-20210503143856958"></a></p>
<blockquote>
<p>如何恢复 rdb 文件！</p>
</blockquote>
<p>1、只需要将 rdb 文件放在我们 redis 启动目录就可以，redis 启动的时候会自动检查 dump.rdb 恢复其中 的数据！</p>
<p>2、查看需要存在的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/usr/local/bin&quot; # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<p>1、适合大规模的数据恢复！</p>
<p>2、对数据的完整性要不高！</p>
<p><strong>缺点：</strong></p>
<p>1、需要一定的时间间隔进程操作！如果 redis 意外宕机了，这个最后一次修改数据就没有的了！</p>
<p>2、fork 进程的时候，会占用一定的内容空间！</p>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！</p>
<blockquote>
<p>是什么？</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503144252.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503144252.png" alt="img"></a></p>
<p>以日志的形式来记录每个写操作，将 Redis 执行过的所有指令记录下来（读操作不记录），只许追加文件 但不可以改写文件，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件 的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p>&#x3D;&#x3D;AOF 保存的是<code>appendonly.aof</code>文件&#x3D;&#x3D;</p>
<blockquote>
<p>append</p>
</blockquote>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503144546.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503144546.png" alt="image-20210503144546005"></a></p>
<p>默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为 yes 就开启了 aof！ 重启，redis 就可以生效了！</p>
<p>如果这个 aof 文件有错误，这时候 redis 是启动不起来的，我们需要修复这个 aof 文件</p>
<p>redis 给我们提供了一个工具 <code>redis-check-aof --fix</code></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503144822.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503144822.png" alt="image-20210503144822428"></a></p>
<p>如果文件正常，重启就可以直接恢复了！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503144919.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503144919.png" alt="image-20210503144919410"></a></p>
<blockquote>
<p>重写规则说明</p>
</blockquote>
<p>aof 默认就是文件的无限追加，文件会越来越大！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503145247.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503145247.png" alt="image-20210503145247104"></a></p>
<p>如果 aof 文件大于 64m，太大了！ fork 一个新的进程来将我们的文件进行重写！</p>
<blockquote>
<p>优点和缺点！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字</span><br><span class="line"></span><br><span class="line"># appendfsync always # 每次修改都会 sync。消耗性能</span><br><span class="line">appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！</span><br><span class="line"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<p>1、每一次修改都同步，文件的完整会更加好！</p>
<p>2、每秒同步一次，可能会丢失一秒的数据</p>
<p>3、从不同步，效率最高的！</p>
<p><strong>缺点：</strong></p>
<p>1、相对于数据文件来说，aof 远远大于 rdb，修复的速度也比 rdb 慢！</p>
<p>2、Aof 运行效率也要比 rdb 慢，所以我们 redis 默认的配置就是 rdb 持久化！</p>
<p><strong>扩展：</strong></p>
<p>1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>
<p>2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始 的数据，AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾，Redis 还能对 AOF 文件进行后台重 写，使得 AOF 文件的体积不至于过大。</p>
<p>3、&#x3D;&#x3D;只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化&#x3D;&#x3D;</p>
<p>4、同时开启两种持久化方式</p>
<ul>
<li>在这种情况下，当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li>
<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件，那要不要只使用 AOF 呢？作者 建议不要，因为 RDB 更适合用于备份数据库（AOF 在不断变化不好备份），快速重启，而且不会有 AOF 可能潜在的 Bug，留着作为一个万一的手段。</li>
</ul>
<p>5、性能建议</p>
<ul>
<li>因为 RDB 文件只用作后备用途，建议只在 Slave 上持久化 RDB 文件，而且只要 15 分钟备份一次就够 了，只保留 save 900 1 这条规则。</li>
<li>如果 Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只 load 自 己的 AOF 文件就可以了，代价一是带来了持续的 IO，二是 AOF rewrite 的最后将 rewrite 过程中产 生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值 64M 太小了，可以设到 5G 以上，默认超过原大小 100%大小重 写可以改到适当的数值。</li>
<li>如果不 Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔 IO，也 减少了 rewrite 时带来的系统波动。代价是如果 Master&#x2F;Slave 同时倒掉，会丢失十几分钟的数据， 启动脚本也要比较两个 Master&#x2F;Slave 中的 RDB 文件，载入较新的那个，微博就是这种架构。</li>
</ul>
<h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、 微博、关注系统！</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>订阅&#x2F;发布消息图：</p>
<p>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503153104.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503153104.png" alt="image-20210503153104671"></a></p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的 关系：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503153133.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503153133.png" alt="image-20210503153133504"></a></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503153155.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503153155.png" alt="image-20210503153155660"></a></p>
<blockquote>
<p>命令</p>
</blockquote>
<p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[PSUBSCRIBE pattern <a href="https://www.runoob.com/redis/pub-sub-psubscribe.html">pattern …]</a> 订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td>2</td>
<td>[PUBSUB subcommand [argument <a href="https://www.runoob.com/redis/pub-sub-pubsub.html">argument …]</a> 查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/redis/pub-sub-publish.html">PUBLISH channel message</a> 将信息发送到指定的频道。</td>
</tr>
<tr>
<td>4</td>
<td>[PUNSUBSCRIBE [pattern <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html">pattern …]</a> 退订所有给定模式的频道。</td>
</tr>
<tr>
<td>5</td>
<td>[SUBSCRIBE channel <a href="https://www.runoob.com/redis/pub-sub-subscribe.html">channel …]</a> 订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>6</td>
<td>[UNSUBSCRIBE [channel <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html">channel …]</a> 指退订给定的频道。</td>
</tr>
</tbody></table>
<blockquote>
<p>测试</p>
</blockquote>
<p><strong>订阅端：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">[root@ouwen owconfig]# ../</span><br><span class="line">-bash: ../: Is a directory</span><br><span class="line">[root@ouwen owconfig]# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE ouwenshuo</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;ouwenshuo&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot; #消息</span><br><span class="line">2) &quot;ouwenshuo&quot; #哪个频道的消息</span><br><span class="line">3) &quot;hello redis&quot; #消息内容</span><br></pre></td></tr></table></figure>

<p><strong>发送端：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH ouwenshuo &quot;hello redis&quot; #发布者发布消息到频道！</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p>Redis 是使用 C 实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，借此加深对 Redis 的理解。</p>
<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p>
<p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！， 而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键， 就是将客户端添加到给定 channel 的订阅链表中。</p>
<p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>Pub&#x2F;Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在 Redis 中，你可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应 的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<p><strong>使用场景：</strong></p>
<p>1、实时消息系统！</p>
<p>2、实时聊天！（频道当做聊天室，将信息回显给所有人即可！）</p>
<p>3、订阅，关注系统都是可以的！ 稍微复杂的场景我们就会使用 消息中间件 MQ （）</p>
<h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点 (master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；数据的复制是单向的，只能由主节点到从节点。 Master 以写为主，Slave 以读为主。</p>
<p>&#x3D;&#x3D;默认情况下，每台 Redis 服务器都是主节点；&#x3D;&#x3D;</p>
<p>且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用主要包括：</strong></p>
<p>1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
<p>2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务 的冗余。</p>
<p>3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写 少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</p>
<p>4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。</p>
<p><strong>一般来说，要将 Redis 运用于工程项目中，只使用一台 Redis 是万万不能的（宕机），原因如下：</strong></p>
<p>1、从结构上，单个 Redis 服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较 大；</p>
<p>2、从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量为 256G，也不能将所有 内存用作 Redis 存储内存，一般来说，单台 Redis 最大使用内存不应该超过 20G。 电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<p><strong>对于这种场景，我们可以使如下这种架构：</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503160753.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503160753.png" alt="image-20210503160753106"></a></p>
<p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主 二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用 Redis！</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>只配置从库，不用配置主库！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line">127.0.0.1:6379&gt; info replication # 查看当前库的信息</span><br><span class="line"># Replication</span><br><span class="line">role:master # 角色 master</span><br><span class="line">connected_slaves:0 # 没有从机</span><br><span class="line">master_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882a</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<p>复制 3 个配置文件，然后修改对应的信息：</p>
<p>1、端口</p>
<p>2、pid 名字</p>
<p>3、log 文件名字</p>
<p>4、dump.rdb 名字</p>
<p>修改完毕之后，启动我们的 3 个 redis 服务器，可以通过进程信息查看~</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503162204.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503162204.png" alt="image-20210503162204439"></a></p>
<h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p>&#x3D;&#x3D;默认情况下，每台 Redis 服务器都是主节点；&#x3D;&#x3D;我们一般情况下只用配置从机就好了！</p>
<p>认老大！ 一主 （79）二从（80，81）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379 #SLAVEOF host port 找谁当自己的老大 认主机</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave #当前角色是从机</span><br><span class="line">master_host:127.0.0.1 #可以看到主机的信息</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:e3379979becc4e424bf681c1a5fe7672bee18d37</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line">#在主机中查看</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1 #多了从机的配置</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=28,lag=0 #可以查看从机的信息</span><br><span class="line">master_replid:e3379979becc4e424bf681c1a5fe7672bee18d37</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:28</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:28</span><br></pre></td></tr></table></figure>

<p>如果两个都配置完了，就是有两个从机的</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503162814.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503162814.png" alt="image-20210503162814852"></a></p>
<p>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！</p>
<blockquote>
<p>细节</p>
</blockquote>
<p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！</p>
<p>主机写：</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503163100.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503163100.png" alt="image-20210503163059937"></a></p>
<p>从机只能读取内容！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503163113.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503163113.png" alt="image-20210503163113429"></a></p>
<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p>
<p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从 主机中获取值！</p>
<blockquote>
<p>复制原理</p>
</blockquote>
<p>Slave 启动成功连接到 master 后会发送一个 sync 同步命令</p>
<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行 完毕之后，&#x3D;&#x3D;master 将传送整个数据文件到 slave，并完成一次完全同步。&#x3D;&#x3D;</p>
<ul>
<li>全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步</li>
</ul>
<p><strong>但是只要是重新连接 master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中 看到！</strong></p>
<blockquote>
<p>层层链路</p>
</blockquote>
<p>上一个 M 链接下一个 S！</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503174711.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503174711.png" alt="image-20210503174711032"></a></p>
<p>这时候也可以完成我们的主从复制！</p>
<blockquote>
<p>如果没有老大了，这个时候能不能选择一个老大出来呢？ 手动！</p>
</blockquote>
<p>&#x3D;&#x3D;谋朝篡位&#x3D;&#x3D;</p>
<p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code> 让自己变成主机！其他的节点就可以手动连 接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！</p>
<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>（自动选举老大的模式）</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。Redis 从 2.8 开始正式提供了 Sentinel（哨兵） 架构来解决这个问题。</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数&#x3D;&#x3D;自动将从库转换为主库&#x3D;&#x3D;。</p>
<p>哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503180007.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503180007.png" alt="image-20210503180007839"></a></p>
<p>这里的哨兵有两个作用</p>
<ul>
<li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到 master 宕机，会自动将 slave 切换成 master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503180127.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503180127.png" alt="image-20210503180127096"></a></p>
<p>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵 1 主观的认 为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover[故障转移]操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 <strong>客观下线</strong>。</p>
<blockquote>
<p>测试！</p>
</blockquote>
<p>目前的状态是：一主二从！</p>
<p>1、配置哨兵配置文件 <code>sentinel.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"># sentinel monitor 被监控的名称 host port 1</span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<p>后面的这个数字 1，代表主机挂了，slave 投票看让谁接替成为主机，票数最多的，就会成为主机！</p>
<p>2、启动哨兵</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">[root@ouwen bin]# redis-sentinel owconfig/sentinel.conf</span><br><span class="line">5922:X 03 May 2021 18:13:03.144 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">5922:X 03 May 2021 18:13:03.144 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=5922, just started</span><br><span class="line">5922:X 03 May 2021 18:13:03.144 # Configuration loaded</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ &#x27;&#x27;-._</span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 5.0.8 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._</span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 26379</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 5922</span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;</span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|</span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io</span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;</span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|</span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |</span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;</span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;</span><br><span class="line">          `-._        _.-&#x27;</span><br><span class="line">              `-.__.-&#x27;</span><br><span class="line"></span><br><span class="line">5922:X 03 May 2021 18:13:03.145 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">5922:X 03 May 2021 18:13:03.150 # Sentinel ID is 0ab5ef20110ebfc67bc2a5e93addbe0871ffd748</span><br><span class="line">5922:X 03 May 2021 18:13:03.150 # +monitor master myredis 127.0.0.1 6379 quorum 1</span><br><span class="line">5922:X 03 May 2021 18:13:03.151 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><span class="line">5922:X 03 May 2021 18:13:03.156 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>如果 Master 节点断开了，这个时候就会从从机中随机选择一个服务器！（这里面有一个投票算法！）</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503181753.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="image-20210503181752988"></a></p>
<p><strong>哨兵日志：</strong></p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503181828.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503181828.png" alt="image-20210503181828520"></a></p>
<p>如果主机此时回来了，&#x3D;&#x3D;只能归并到新的主机下，当做从机&#x3D;&#x3D;，这就是哨兵模式的规则！</p>
<blockquote>
<p>哨兵模式</p>
</blockquote>
<p><strong>优点：</strong></p>
<p>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</p>
<p>2、主从可以切换，故障可以转移，系统的可用性就会更好</p>
<p>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p>
<p><strong>缺点：</strong></p>
<p>1、Redis 不好做在线扩容的，集群容量一旦达到上限，在线扩容就会十分麻烦！</p>
<p>2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</p>
<blockquote>
<p>哨兵模式的全部配置！！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line"># Example sentinel.conf</span><br><span class="line"># 哨兵sentinel实例运行的端口 默认26379</span><br><span class="line">port 26379</span><br><span class="line"># 哨兵sentinel的工作目录</span><br><span class="line">dir /tmp</span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port</span><br><span class="line"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><span class="line"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="line"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><br><span class="line">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="line">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那</span><br><span class="line">里同步数据时。</span><br><span class="line">#3.当想要取消一个正在进行的failover所需要的时间。</span><br><span class="line">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，</span><br><span class="line">slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line"># 默认三分钟</span><br><span class="line"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"># SCRIPTS EXECUTION</span><br><span class="line">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知</span><br><span class="line">相关人员。</span><br><span class="line">#对于脚本的运行结果有以下规则：</span><br><span class="line">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="line">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="line">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="line">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="line">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="line">#通知脚本</span><br><span class="line"># shell编程</span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"># 客户端重新配置主节点参数脚本</span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="line"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line"># 目前&lt;state&gt;总是“failover”,</span><br><span class="line"># &lt;role&gt;是“leader”或者“observer”中的一个。</span><br><span class="line"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！</span><br></pre></td></tr></table></figure>

<h1 id="Redis-缓存穿透和雪崩"><a href="#Redis-缓存穿透和雪崩" class="headerlink" title="Redis 缓存穿透和雪崩"></a>Redis 缓存穿透和雪崩</h1><blockquote>
<p>服务的高可用问题！</p>
</blockquote>
<p>在这里我们不会详细的区分析解决方案的底层！</p>
<p>Redis 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一 些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>
<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503183005.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503183005.png" alt="image-20210503183005078"></a></p>
<h2 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存穿透的概念很简单，用户想要查询一个数据，发现 redis 内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒 杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503183137.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503183137.png" alt="image-20210503183137788"></a></p>
<p><strong>缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503183210.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503183210.png" alt="image-20210503183210887"></a></p>
<p>但是这种方法会存在两个问题：</p>
<p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多 的空值的键；</p>
<p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于 需要保持一致性的业务会有影响。</p>
<h2 id="缓存击穿（量太大，缓存过期！）"><a href="#缓存击穿（量太大，缓存过期！）" class="headerlink" title="缓存击穿（量太大，缓存过期！）"></a>缓存击穿（量太大，缓存过期！）</h2><blockquote>
<p>概述</p>
</blockquote>
<p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一 个屏障上凿开了一个洞。</p>
<p>当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机~</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商 品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><a href="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503183725.png"><img src="https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210503183725.png" alt="image-20210503183725407"></a></p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>redis 高可用</strong></p>
<p>这个思想的含义是，既然 redis 有可能挂掉，那我多增设几台 redis，这样一台挂掉之后其他的还可以继续 工作，其实就是搭建的集群。（异地多活！）</p>
<p><strong>限流降级</strong></p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对 某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数 据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
